<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML><HEAD><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1"><META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css"><META NAME="GENERATOR" CONTENT="Adobe FrameMaker 7.0/HTML Export Filter"><LINK REL="STYLESHEET" HREF="DLL.css" CHARSET="ISO-8859-1" TYPE="text/css"><TITLE> Writing a DLL in HLA</TITLE></HEAD><BODY BGCOLOR="#ffffff"><DIV><H1 CLASS="Title"><A NAME="pgfId-997347"></A>Writing a DLL in HLA</H1><P CLASS="Body"><A NAME="pgfId-997352"></A>Dynamic link libraries provide an efficient mechanism for sharing code and cross-language linkage.  The HLA language does not require any specific syntax to create a DLL;  most of the work is done by the linker.  However, to successfully write and call DLLs with HLA, you must follow some standard conventions.</P><P CLASS="Body"><A NAME="pgfId-997353"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997354"></A>Acknowledgement: I learned much of the material needed to write DLLs in HLA by visiting the following web page and looking at the CRCDemo file (which demonstrates how to write DLLs in assembly language).  For more information on DLLs in assembly, you might want to take a look at this page yourself:</P><P CLASS="Body"><A NAME="pgfId-997355"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997356"></A>http://www.geocities.com/SiliconValley/Heights/7394/index.html</P><P CLASS="Body"><A NAME="pgfId-997361"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997362"></A>I certainly acknowledge stealing lots of information and ideas from this CRC code and documentation.</P><P CLASS="Body"><A NAME="pgfId-997363"></A>&nbsp;</P><DIV><H3 CLASS="Heading2"><A NAME="pgfId-997364"></A>Creating a Dynamic Link Library</H3><P CLASS="Body"><A NAME="pgfId-997374"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997375"></A>Win32 Dynamic Link Libraries provide a mechanism whereby two or more programs can share the same set of library object modules on the disk.  At the very least, DLLs save space on the disk;  if properly written and loaded into memory, DLLs can also share run-time memory and reduce swap space usage on the hard disk.</P><P CLASS="Body"><A NAME="pgfId-997376"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997377"></A>Perhaps even more important that saving space, DLLs provide a mechanism whereby two different programming languages may communicate with one another.  Although there is usually no problems calling an assembly language (i.e., HLA) module from any given high level language, DLLs do provide one higher level of generality.  In order to achieve this generality, Microsoft had to carefully describe the calling mechanism between DLLs and other modules.  In order to communicate data, all languages that support DLLs need to agree on the calling and parameter passing mechanisms.</P><P CLASS="Body"><A NAME="pgfId-997378"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997379"></A>Microsoft has laid down the following rules for DLLs (among others):</P><P CLASS="Body"><A NAME="pgfId-997380"></A>&nbsp;</P><UL><LI CLASS="Bulleted"><A NAME="pgfId-997381"></A>Procedures/functions with a fixed parameter list use the stdcall calling mechanism.</LI><LI CLASS="Bulleted"><A NAME="pgfId-997385"></A>Procedures/functions with a variable number of parameters use the C calling mechanism.</LI><LI CLASS="Bulleted"><A NAME="pgfId-997386"></A>Parameters can be bytes, words, doublewords, pointers, or strings.  Pointers are machine addresses; strings are pointers to a zero-terminated sequence of characters, and it is up to the two modules to agree on how to interpret byte, word, or dword data (e.g., char, int16, uns32, etc.)</LI></UL><P CLASS="Body"><A NAME="pgfId-997387"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997400"></A>Stdcall procedures push their parameters from left to right as they are encountered in the parameter list.  In stdcall procedures, it is the procedure's responsibility to clean up the parameters pushed on the stack.</P><P CLASS="Body"><A NAME="pgfId-997391"></A>HLA uses the stdcall calling mechanism for the HLL-style procedure calls, so this simplifies the interface to DLL code when using fixed parameter lists (variable parameter lists are rare in DLLs, but should they be necessary, one can always drop down into &quot;pure&quot; assembly in HLA and accomodate the DLL).</P><P CLASS="Body"><A NAME="pgfId-997392"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997401"></A>The only other issue, with respect to stdcall conventions, is the naming convention.  The stdcall mechanism mangles procedure names.  In particular, a procedure name like &quot;XXXX&quot; is translated to &quot;_XXX@nn&quot; where &quot;nn&quot; is the number of bytes of parameters passed to the procedure.  HLA does not automatically mangle procedure names, but using the &quot;external&quot; directive you can easily specify the mangled name.</P><P CLASS="Body"><A NAME="pgfId-997407"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997408"></A>DLLs must provide a special procedure that Windows calls to initialize the procedure.  This DLL entry point must use an HLA definition like the following:</P><P CLASS="Body"><A NAME="pgfId-997412"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997415"></A>procedure dll( instance:dword; reason:dword; reserved:dword );   external( &quot;_dll@12&quot; );</P><P CLASS="Body"><A NAME="pgfId-997413"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997420"></A>This function must return true in AL if the DLL can be successfully initialized;  it returns false if it cannot properly initialize the DLL.  Note that &quot;dll&quot; and &quot;_dll@12&quot; are example names;  you may use any reasonable identifiers you choose here.</P><P CLASS="Body"><A NAME="pgfId-997423"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997424"></A>The DLL initialization function always has three parameters.  The second parameter is the only one of real interest to the DLL initialization code.  This parameter contains the reason for calling this code, which is one of the following constants defined in the w.hhf header file:</P><P CLASS="Body"><A NAME="pgfId-997425"></A>&nbsp;</P><UL><LI CLASS="Bulleted"><A NAME="pgfId-997427"></A>w.DLL_PROCESS_ATTACH</LI><LI CLASS="Bulleted"><A NAME="pgfId-997431"></A>w.DLL_PROCESS_DETACH</LI><LI CLASS="Bulleted"><A NAME="pgfId-997432"></A>w.DLL_THREAD_ATTACH</LI><LI CLASS="Bulleted"><A NAME="pgfId-997433"></A>w.DLL_THREAD_DETACH</LI></UL><P CLASS="Body"><A NAME="pgfId-997434"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997438"></A>The w.DLL_XXXXX_ATTACH values indicate that some program is linking in the DLL.  During these calls, you should open any files, initialize any variables, and execute any other initialization code that may be necessary for the proper operation of the DLL.  Note that, by default, all processes that attach to a DLL get their own copy of any data defined in the DLL.  Therefore, you do not have to worry about disturbing previous links to the DLL during the current initialization process.</P><P CLASS="Body"><A NAME="pgfId-997439"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997440"></A>The w.DLL_XXXXX_DETACH values indicate that a process or thread is shutting down.  During these calls, you should close any files and perform any other necessary cleanup (e.g., freeing memory) that you would normally do before a program ends.</P><P CLASS="Body"><A NAME="pgfId-997461"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997462"></A>The following code demonstrates a short DLL:</P><P CLASS="Body"><A NAME="pgfId-997463"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997760"></A>unit dllExample;</P><P CLASS="code"><A NAME="pgfId-997761"></A>#include( &quot;w.hhf&quot; );</P><P CLASS="code"><A NAME="pgfId-997762"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997763"></A>static</P><P CLASS="code"><A NAME="pgfId-997764"></A>    ThisInstance: dword;</P><P CLASS="code"><A NAME="pgfId-997765"></A>    </P><P CLASS="code"><A NAME="pgfId-997766"></A>procedure dll( instance:dword; reason:dword; reserved:dword ); </P><P CLASS="code"><A NAME="pgfId-997767"></A>        @stdcall; @external( &quot;_dll@12&quot; );</P><P CLASS="code"><A NAME="pgfId-997768"></A>        </P><P CLASS="code"><A NAME="pgfId-997769"></A>procedure dllFunc1( dw:dword ); @stdcall; @external( &quot;_dllFunc1@4&quot; );</P><P CLASS="code"><A NAME="pgfId-997770"></A>procedure dllFunc2( dw2:dword ); @stdcall; @external( &quot;_dllFunc2@4&quot; );</P><P CLASS="code"><A NAME="pgfId-997771"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997772"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997773"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997774"></A>procedure dll( instance:dword; reason:dword; reserved:dword ); @nodisplay;</P><P CLASS="code"><A NAME="pgfId-997775"></A>begin dll;</P><P CLASS="code"><A NAME="pgfId-997776"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997777"></A>    // Save the instance value.</P><P CLASS="code"><A NAME="pgfId-997778"></A>    </P><P CLASS="code"><A NAME="pgfId-997779"></A>    mov( instance, eax );</P><P CLASS="code"><A NAME="pgfId-997780"></A>    mov( eax, ThisInstance );</P><P CLASS="code"><A NAME="pgfId-997781"></A>    </P><P CLASS="code"><A NAME="pgfId-997782"></A>    if( reason = w.DLL_PROCESS_ATTACH ) then</P><P CLASS="code"><A NAME="pgfId-997783"></A>    </P><P CLASS="code"><A NAME="pgfId-997784"></A>        // Do this code if we're attaching this DLL to a process...</P><P CLASS="code"><A NAME="pgfId-997785"></A>        </P><P CLASS="code"><A NAME="pgfId-997786"></A>    endif;</P><P CLASS="code"><A NAME="pgfId-997787"></A>    </P><P CLASS="code"><A NAME="pgfId-997788"></A>    // Return true if successful, false if unsuccessful.</P><P CLASS="code"><A NAME="pgfId-997789"></A>    </P><P CLASS="code"><A NAME="pgfId-997790"></A>    mov( true, eax );</P><P CLASS="code"><A NAME="pgfId-997791"></A>    </P><P CLASS="code"><A NAME="pgfId-997792"></A>end dll;</P><P CLASS="code"><A NAME="pgfId-997793"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997794"></A>    </P><P CLASS="code"><A NAME="pgfId-997795"></A>procedure dllFunc1( dw:dword ); @nodisplay;</P><P CLASS="code"><A NAME="pgfId-997796"></A>begin dllFunc1;</P><P CLASS="code"><A NAME="pgfId-997797"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997798"></A>    mov( dw, eax );</P><P CLASS="code"><A NAME="pgfId-997799"></A>    </P><P CLASS="code"><A NAME="pgfId-997800"></A>end dllFunc1;</P><P CLASS="code"><A NAME="pgfId-997801"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997802"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997803"></A>procedure dllFunc2( dw2:dword ); @nodisplay;</P><P CLASS="code"><A NAME="pgfId-997804"></A>begin dllFunc2;</P><P CLASS="code"><A NAME="pgfId-997805"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997806"></A>    push( edx );</P><P CLASS="code"><A NAME="pgfId-997807"></A>    mov( dw2, eax );</P><P CLASS="code"><A NAME="pgfId-997808"></A>    mul( dw2, eax );</P><P CLASS="code"><A NAME="pgfId-997809"></A>    pop( edx );</P><P CLASS="code"><A NAME="pgfId-997810"></A>    </P><P CLASS="code"><A NAME="pgfId-997811"></A>end dllFunc2;</P><P CLASS="code"><A NAME="pgfId-997812"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997464"></A>end dllExample;</P><P CLASS="Body"><A NAME="pgfId-997426"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997610"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997611"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997612"></A>As you can see here, there is very little difference between a standard unit and an HLA unit intended to become a DLL.  The name mangling is one difference, placing the external declarations directly in the file (rather than in an include file) is another difference.  The only functional difference is the presence of the DLL initialization procedure (&quot;dll&quot; in this example).</P><P CLASS="Body"><A NAME="pgfId-997615"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997616"></A>The real work in creating a DLL occurs during the link phase.  You cannot compile a DLL the same way you compile a standard HLA program - some additional steps are necessary.  Creating a DLL requires lots of command line parameters, so it is best to create a makefile and a &quot;linker&quot; file to avoid excess typing at the command line.  Consider the following make file for the module above:</P><P CLASS="Body"><A NAME="pgfId-997620"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997627"></A>dll.dll: dll.obj</P><P CLASS="code"><A NAME="pgfId-997628"></A>	link dll.obj @dll.linkresp</P><P CLASS="code"><A NAME="pgfId-997629"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997630"></A>dll.obj: dll.hla</P><P CLASS="code"><A NAME="pgfId-997631"></A>	hla -@ -c dll.hla</P><P CLASS="Body"><A NAME="pgfId-997622"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997637"></A>This makefile generates the dll.dll file (it will also produce several other files, dll.lib being the most important one).  The real work appears in the &quot;dll.linkresp&quot; linker file.  This file contains the following text:</P><P CLASS="Body"><A NAME="pgfId-997638"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997642"></A>-DLL </P><P CLASS="code"><A NAME="pgfId-997643"></A>-entry:dll </P><P CLASS="code"><A NAME="pgfId-997647"></A>-base:0x40000000 </P><P CLASS="code"><A NAME="pgfId-997648"></A>-out:dll.dll </P><P CLASS="code"><A NAME="pgfId-997649"></A>-export:dll </P><P CLASS="code"><A NAME="pgfId-997650"></A>-export:dllFunc1 </P><P CLASS="code"><A NAME="pgfId-997651"></A>-export:dllFunc2</P><P CLASS="Body"><A NAME="pgfId-997639"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997665"></A>The &quot;-DLL&quot; option tells the linker to produce a &quot;dll.dll&quot; and a &quot;dll.lib&quot; file rather than just a &quot;dll.exe&quot; file (note: the linker will also produce some other files, but these two are the ones important to us).</P><P CLASS="Body"><A NAME="pgfId-997666"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997667"></A>The &quot;-entry:dll&quot; option tells the linker that the name of the DLL initialization code is the procedure &quot;dll&quot;.  If you change the name of your DLL initialization code, you should also change this option.</P><P CLASS="Body"><A NAME="pgfId-997671"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997674"></A>The &quot;-base:0x40000000&quot; option tells the linker that this DLL has a base address of 1GByte.  For efficiency reasons, you should try to specify a unique value here.  If two active DLLs specify the same base address, different processes cannot concurrently share the two DLLs.  The programs will still operate, but they will not share the code, wasting some memory and requiring longer load times.</P><P CLASS="Body"><A NAME="pgfId-997675"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997676"></A>The &quot;-out:dll.dll&quot; command specifies the output name for the DLL.  The suffix should be &quot;.dll&quot; and the base filename should be an appropriate name for your DLL (&quot;dll&quot; was appropriate in this case, it would not be appropriate in other cases).</P><P CLASS="Body"><A NAME="pgfId-997677"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997678"></A>The &quot;-export&quot; options specify the names of the external procedures you wish to make available to other modules.  Alternately, you may create a &quot;.DEF&quot; file and use the &quot;-DEF:deffilename.def&quot; option to pass the exported file names on to the linker (see the Microsoft documentation for a description of DEF files).</P><P CLASS="Body"><A NAME="pgfId-997679"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997640"></A>If you run this make file, it will compile the dll.hla source file producing the dll.dll and dll.lib object modules.</P><P CLASS="Body"><A NAME="pgfId-997680"></A>&nbsp;</P></DIV><DIV><H3 CLASS="Heading2"><A NAME="pgfId-997687"></A>Linking and Calling Procedures in a Dynamic Link Library</H3><P CLASS="Body"><A NAME="pgfId-997691"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997692"></A>Creating a DLL in HLA is only half the battle.  The other half is calling a procedure in a DLL from an HLA program.  Here is a sample program that calls the DLL procedures in the previous section:</P><P CLASS="Body"><A NAME="pgfId-997696"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997824"></A>// Sample program that calls routines in dll.dll.</P><P CLASS="code"><A NAME="pgfId-997825"></A>//</P><P CLASS="code"><A NAME="pgfId-997826"></A>//  Compile this with the command line option:</P><P CLASS="code"><A NAME="pgfId-997827"></A>//</P><P CLASS="code"><A NAME="pgfId-997828"></A>//      hla dllmain dll.lib</P><P CLASS="code"><A NAME="pgfId-997829"></A>//</P><P CLASS="code"><A NAME="pgfId-997830"></A>//  Of course, you must build the DLL first.</P><P CLASS="code"><A NAME="pgfId-997831"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997832"></A>program callDLL;</P><P CLASS="code"><A NAME="pgfId-997833"></A>#include( &quot;stdlib.hhf&quot; );</P><P CLASS="code"><A NAME="pgfId-997834"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997835"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997836"></A>procedure dllFunc1( dw:dword ); @stdcall; @external( &quot;_dllFunc1@4&quot; );</P><P CLASS="code"><A NAME="pgfId-997837"></A>procedure dllFunc2( dw:dword ); @stdcall; @external( &quot;_dllFunc2@4&quot; );</P><P CLASS="code"><A NAME="pgfId-997838"></A>     </P><P CLASS="code"><A NAME="pgfId-997839"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997840"></A>begin callDLL;</P><P CLASS="code"><A NAME="pgfId-997841"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997842"></A>    xor( eax, eax );</P><P CLASS="code"><A NAME="pgfId-997843"></A>    dllFunc1( 12345 );</P><P CLASS="code"><A NAME="pgfId-997844"></A>    stdout.put( &quot;After dllFunc1, eax = &quot;, (type uns32 eax ), nl );</P><P CLASS="code"><A NAME="pgfId-997845"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997846"></A>    dllFunc2( 100 );</P><P CLASS="code"><A NAME="pgfId-997847"></A>    stdout.put( &quot;After dllFunc2, eax = &quot;, (type uns32 eax ), nl );</P><P CLASS="code"><A NAME="pgfId-997848"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997849"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997697"></A>end callDLL;</P><P CLASS="Body"><A NAME="pgfId-997698"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997742"></A>To compile this main program, you would use the following HLA command line:</P><P CLASS="Body"><A NAME="pgfId-997743"></A>&nbsp;</P><P CLASS="code"><A NAME="pgfId-997735"></A>hla dllmain dll.lib</P><P CLASS="Body"><A NAME="pgfId-997681"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997748"></A>The &quot;dll.lib&quot; file contains the linkages necessary to load and link in the dll module at run-time.</P><P CLASS="Body"><A NAME="pgfId-997752"></A>&nbsp;</P><P CLASS="Body"><A NAME="pgfId-997753"></A>&nbsp;</P></DIV><DIV><H3 CLASS="Heading2"><A NAME="pgfId-997754"></A>Going Farther</H3><P CLASS="Body"><A NAME="pgfId-997758"></A>This document only explains &quot;implicitly loaded&quot; DLLs.  Implicitly loaded DLLs are always loaded into memory when the main module loads into memory.  If you want to control the loading of the DLL module into memory, you will want to take a look at &quot;explicitly loaded&quot; DLLs.  Such DLLs, however, will have to be the subject of a different example.</P><P CLASS="Body"><A NAME="pgfId-997862"></A>&nbsp;</P></DIV></DIV></BODY></HTML>