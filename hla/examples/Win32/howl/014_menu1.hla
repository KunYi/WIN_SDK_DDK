// menu1-
//
//  This program demonstrates the use of menus on a form.

program menu1;
#linker( "comdlg32.lib" ) 
#linker( "comctl32.lib" )

?@NoDisplay     := true;
?@NoStackAlign  := true;

#includeOnce( "stdlib.hhf" )
#includeOnce( "howl.hhf" )

const
    applicationName := "Menus #1";
    formX           := w.CW_USEDEFAULT; // Let Windows position this guy
    formY           := w.CW_USEDEFAULT;
    formW           := 600;
    formH           := 600;

    
    
    
// Forward declarations for the onClick widgetProcs that we're going to
// call when an event occurs.

proc nullProc           :widgetProc; @forward;
proc onQuit             :widgetProc; @forward;



// Here's the main form definition for the app:

wForm( mainAppWindow );

    wMainMenu;
    
        wSubMenu( file_1, "file" );
    
            wMenuItem( dummy1, false, "dummy", nullProc );
            wMenuSeparator; 
            wMenuItem( menu_exit, false, "Exit", onQuit );
            
        endwSubMenu; 
                    
    endwMainMenu;
    
    
    
endwForm


// Must invoke the following macro to emit the code generated by
// the wForm macro:

mainAppWindow_implementation();
    






// nullProc does nothing.

proc nullProc:widgetProc;
begin nullProc;

    stdout.put( "Pressed the dummy  menu entry" nl );
    
end nullProc;



// Here's the onClick event handler for our quit button on the form.
// This handler will simply quit the application:

proc onQuit:widgetProc;
begin onQuit;

    // Quit the app:
    
    w.PostQuitMessage( 0 );

end onQuit;





// We'll use the main application form's onCreate method to initialize
// the various buttons on the form.
//
// This could be done in appStart, but better to leave appStart mainly
// as boilerplate code. Also, putting this code here allows us to use
// "this" to access the mainAppWindow fields (a minor convenience).
        
method mainAppWindow_t.onCreate;
begin onCreate;
end onCreate;

    
    
///////////////////////////////////////////////////////////////////////////////
//
//
// The following is mostly boilerplate code for all apps (about the only thing
// you would change is the size of the main app's form)
//
//
///////////////////////////////////////////////////////////////////////////////
//  
// When the main application window closes, we need to terminate the 
// application. This overridden method handles that situation.  Notice the
// override declaration for onClose in the wForm declaration given earlier.
// Without that, mainAppWindow_t would default to using the wVisual_t.onClose
// method (which does nothing). 
        
method mainAppWindow_t.onClose;
begin onClose;
    
    // Tell the winmain main program that it's time to terminate.
    // Note that this message will (ultimately) cause the appTerminate
    // procedure to be called.
    
    w.PostQuitMessage( 0 );
    
    
end onClose;

               
  
               
   
// When the application begins execution, the following procedure
// is called.  This procedure must create the main
// application window in order to kick off the execution of the
// GUI application:
  
procedure appStart;
begin appStart;

    push( esi );
    
    // Create the main application window:
    
    mainAppWindow.create_mainAppWindow
    (
        applicationName,        // Window title
        w.WS_EX_CONTROLPARENT,  // Need this to support TAB control selection
        w.WS_OVERLAPPEDWINDOW,  // Style 
        NULL,                   // No parent window                                     
        formX,                  // x-coordinate for window. 
        formY,                  // y-coordinate for window.
        formW,                  // Width
        formH,                  // Height
        howl.bkgColor_g,        // Background color
        true                    // Make visible on creation 
    );
    mov( esi, pmainAppWindow ); // Save pointer to main window object.
    pop( esi );

end appStart;



// appTerminate-
//
//  Called when the application is quitting, giving the app a chance
// to clean up after itself.
//
// Note that this is called *after* the mainAppWindow_t.onClose method
// executes (indeed, mainAppWindow_t.onClose, by posting the quit message,
// is what actually causes the program to begin terminating, which leads
// to the execution of this procedure).

procedure appTerminate;
begin appTerminate;
    
    // Clean up the main application's form.
    // Note that this will recursively clean up all the widgets on the form.
    
    mainAppWindow.destroy();
    
end appTerminate;


// appException-
//
// Gives the application the opportunity to clean up before
// aborting when an unhandled exception comes along:

procedure appException
( 
	theException	:dword in eax;
	raiseAdrs		:dword in ebx;
	filename		:string in ecx;
	userCode		:dword in edx;
	lineNum			:uns32 in edi 
);
begin appException;

    raise( eax );

end appException;



// The main program for a HOWL application must 
// call the HowlMainApp procedure.

begin menu1;

	// Set up the background and transparent colors that the
	// form will use when registering the window_t class:
	
	// Use a special gray color to differentiate the menu bar
	// from the main client area on the form:
	
	mov( RGB(224, 224, 224), eax );
	mov( eax, howl.bkgColor_g );
	or( $FF00_0000, eax );
	mov( eax, howl.transparent_g );
	w.CreateSolidBrush( howl.bkgColor_g );
	mov( eax, howl.bkgBrush_g );

	// Start the HOWL Framework Main Program:
	
	HowlMainApp();
	
	// Delete the brush we created earlier:
	
	w.DeleteObject( howl.bkgBrush_g );			
                
end menu1;
 