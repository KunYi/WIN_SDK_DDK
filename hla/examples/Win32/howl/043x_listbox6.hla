// pgm_listbox6x-
//
//	This program demonstrates the use of list box controls on a form.
//
// This version of the program implements the object manually, without using the
// wForm..endwForm macro (the HOWL declarative language).

program pgm_listbox6x;
#linker( "comdlg32.lib" ) 
#linker( "comctl32.lib" )

?@NoDisplay 	:= true;
?@NoStackAlign	:= true;

#includeOnce( "stdlib.hhf" )
#includeOnce( "howl.hhf" )

const
	applicationName := "ListBox #6x";
	formX			:= w.CW_USEDEFAULT;	// Let Windows position this guy
	formY			:= w.CW_USEDEFAULT;
	formW			:= 600;
	formH			:= 600;



	
	
// Forward declarations for the onClick widgetProcs that we're going to
// call when an event occurs.

proc deleteText			:widgetProc; @forward;
proc insertText			:widgetProc; @forward;
proc changeColor		:widgetProc; @forward;
proc resetListBox		:widgetProc; @forward;
proc getCount			:widgetProc; @forward;
proc search4Text		:widgetProc; @forward;
proc search4Prefix		:widgetProc; @forward;
proc onQuit			   	:widgetProc; @forward;
	

type

	// Create a new class for our main application window.
	// All application forms must be derived from wForm_t:
		
	mainAppWindow_t:
		class inherits( wForm_t );
		
			// We have to add VAR declarations for all our widgets
			// here.
			
			var
				listBox1		:wListBox_p;
				editBox1		:wEditBox_p;
				editBox2		:wEditBox_p;
				editBox3		:wEditBox_p;
				label1			:wLabel_p;
				label2			:wLabel_p;
				label3			:wLabel_p;
				label4			:wLabel_p;
				button2			:wPushButton_p;
				button3			:wPushButton_p;
				button4			:wPushButton_p;
				button5			:wPushButton_p;
				button6			:wPushButton_p;
				button7			:wPushButton_p;
				button8			:wPushButton_p;
				quitButton		:wPushButton_p;
	
		
			// We need to override these (actually, onClose is the
			// only one that is important):
			
			override method onClose;
			override method onCreate;
			
			// Every main application window must have a
			// constructor with the following prototype:
			
			procedure create_mainAppWindow
			(
			        caption :string;
			        exStyle :dword;
			        style   :dword;
			        parent  :dword;
			        x       :dword;
			        y       :dword;
			        width   :dword;
			        height  :dword;
			        bkgClr  :dword;
			        visible :boolean
			);
			
		endclass;
		
		mainAppWindow_p	:pointer to mainAppWindow_t;

// Must have the following declarations in all (manually written) HOWL apps:
	
static
    vmt( mainAppWindow_t );
    mainAppWindow: mainAppWindow_t;
    pmainAppWindow: mainAppWindow_p := &mainAppWindow;	





// Here is the constructor we must supply for the mainAppWindow class:

procedure mainAppWindow_t.create_mainAppWindow
(
        caption :string;
        exStyle :dword;
        style   :dword;
        parent  :dword;
        x       :dword;
        y       :dword;
        width   :dword;
        height  :dword;
        bkgClr  :dword;
        visible :boolean
);
var
    main 	:mainAppWindow_p;
	rs		:wRadioSet_p;
	rsHndl	:dword;

begin create_mainAppWindow;

    push( eax );
    push( ebx );
    push( ecx );
    push( edx );
	
	// Standad main form initialization:
	//
	// If a class procedure call (not typical), then allocate storage
	// for this object:
	
    if( esi = NULL ) then
        mem.alloc( @size( mainAppWindow_t ));
        mov( eax, esi );
        mov( true, cl );
    else
        mov( this.wBase_private.onHeap, cl );
    endif;
	
	// Call the wForm_t constructor to do all the default initialization:
	
    (type wForm_t [esi]).create_wForm
    (
        "mainAppWindow",
        caption,
        exStyle,
        style,
        parent,
        x,
        y,
        width,
        height,
        bkgClr,
        visible
    );
	
	// Initialize the VMT pointer:
	
    mov( &mainAppWindow_t._VMT_, this._pVMT_ );
	
	// Retrieve the onHeap value from above and store it into
	// the onHeap data field:
	
    mov( cl, this.wBase_private.onHeap );
	
	// Preserve "this" because we're about to make an object call
	// that will overwrite this' value:
	
    mov( esi, main );
	
	//////////////////////////////////////////////
	//
	// Create all the widgets on this form:
	//
	//////////////////////////////////////////////
	
	wListBox_t.create_wListBox
	(
		"listBox1",					// wlbName		:string;
		this.handle,				// parent		:dword; 									
		10,							// x			:dword; 
		10,							// y			:dword;
		200,						// width		:dword;
		500,						// height		:dword;
		true,						// sort		:boolean;
		NULL						// onClick		:widgetProc 
	);
	mov( esi, eax );					// Save ptr to new listbox		
	(type wListBox_t [esi]).show();		// Show the listbox.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.listBox1 );			// Save editbox pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.
	

	mov( main, esi );					// Retrieve ptr to main app's object
	wLabel_t.create_wLabel
	(
		"label1",						// Label name
		"Enter Text:",					// Text for label
		this.handle,					// Parent window handle
		250,							// x position 
		10,								// y position 
		200,							// width 
		25,								// height 
		0,								// label style
		RGB( 0, 0, 0 ),					// foreground color (black)
		howl.bkgColor_g					// background color (gray)
	);
	mov( esi, eax );					// Save ptr to new label		
	(type wLabel_t [esi]).show();		// Show the label.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.label1 );			// Save label pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.
	
	
	mov( main, esi );					// Retrieve ptr to main app's object
	wEditBox_t.create_wEditBox
	(
		"editBox1",						// Editbox name
		"",								// initial text
		this.handle,					// Parent window handle
		250,							// x position 
		35,								// y position 
		200,							// width 
		35,	 							// height
		0,								// style
		NULL							// No onChange handler
	);
	mov( esi, eax );					// Save ptr to new label		
	(type wEditBox_t [esi]).show();		// Show the editbox.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.editBox1 );			// Save editbox pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.


	
	// The insert/delete buttons on the form:
	
	mov( main, esi );					// Retrieve ptr to main app's object
	wPushButton_t.create_wPushButton
	(
		"button2",						// Button name
		"Insert Text",					// Caption for push button
		this.handle,					// Parent window handle
		250,							// x position 
		80,								// y position 
		200,							// width 
		25,								// height 
		&insertText						// initial "on click" event handler 
	);
	mov( esi, eax );					// Save ptr to new button		
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.button2 );			// Save button pointer.
	this.insertWidget( eax );			// Add button to wForm's widget list.
	
	mov( main, esi );					// Retrieve ptr to main app's object
	wPushButton_t.create_wPushButton
	(
		"button3",						// Button name
		"Delete Text",					// Caption for push button
		this.handle,					// Parent window handle
		250,							// x position 
		115,							// y position 
		200,							// width 
		25,								// height 
		&deleteText						// initial "on click" event handler 
	);
	mov( esi, eax );					// Save ptr to new button		
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.button3 );			// Save button pointer.
	this.insertWidget( eax );			// Add button to wForm's widget list.
	
	mov( main, esi );					// Retrieve ptr to main app's object
	wPushButton_t.create_wPushButton
	(
		"button4",						// Button name
		"Change Color",					// Caption for push button
		this.handle,					// Parent window handle
		250,							// x position 
		150,							// y position 
		200,							// width 
		25,								// height 
		&changeColor					// initial "on click" event handler 
	);
	mov( esi, eax );					// Save ptr to new button		
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.button4 );			// Save button pointer.
	this.insertWidget( eax );			// Add button to wForm's widget list.


	
	mov( main, esi );					// Retrieve ptr to main app's object
	wPushButton_t.create_wPushButton
	(
		"button5",						// Button name
		"Reset",						// Caption for push button
		this.handle,					// Parent window handle
		250,							// x position 
		185,							// y position 
		200,							// width 
		25,								// height 
		&resetListBox					// initial "on click" event handler 
	);
	mov( esi, eax );					// Save ptr to new button		
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.button5 );			// Save button pointer.
	this.insertWidget( eax );			// Add button to wForm's widget list.
	


	mov( main, esi );					// Retrieve ptr to main app's object
	wLabel_t.create_wLabel
	(
		"label2",						// Label name
		"Item Count: ",					// Text for label
		this.handle,					// Parent window handle
		250,							// x position 
		220,								// y position 
		200,							// width 
		25,								// height 
		0,								// label style
		RGB( 0, 0, 0 ),					// foreground color (black)
		howl.bkgColor_g					// background color (gray)
	);
	mov( esi, eax );					// Save ptr to new label		
	(type wLabel_t [esi]).show();		// Show the label.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.label2 );			// Save label pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.


	
	mov( main, esi );					// Retrieve ptr to main app's object
	wPushButton_t.create_wPushButton
	(
		"button6",						// Button name
		"Refresh Count",				// Caption for push button
		this.handle,					// Parent window handle
		250,							// x position 
		245,							// y position 
		200,							// width 
		25,								// height 
		&getCount					// initial "on click" event handler 
	);
	mov( esi, eax );					// Save ptr to new button		
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.button6 );			// Save button pointer.
	this.insertWidget( eax );			// Add button to wForm's widget list.
	


	mov( main, esi );					// Retrieve ptr to main app's object
	wLabel_t.create_wLabel
	(
		"label3",						// Label name
		"Search For Text:",				// Text string
		this.handle,					// Parent window handle
		250,							// x position 
		280,							// y position 
		200,							// width 
		25,								// height 
		0,								// label style
		RGB( 0, 0, 0 ),					// foreground color (black)
		howl.bkgColor_g					// background color (gray)
	);
	mov( esi, eax );					// Save ptr to new label		
	(type wLabel_t [esi]).show();		// Show the label.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.label3 );			// Save label pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.
	
	
	mov( main, esi );					// Retrieve ptr to main app's object
	wEditBox_t.create_wEditBox
	(
		"editBox2",						// Editbox name
		"",								// initial text
		this.handle,					// Parent window handle
		250,							// x position 
		315,							// y position 
		200,							// width 
		35,	 							// height
		0,								// style
		NULL							// No onChange handler
	);
	mov( esi, eax );					// Save ptr to new label		
	(type wEditBox_t [esi]).show();		// Show the editbox.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.editBox2 );			// Save editbox pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.
	
	


	
	mov( main, esi );					// Retrieve ptr to main app's object
	wPushButton_t.create_wPushButton
	(
		"button7",						// Button name
		"Search for Text",				// Caption for push button
		this.handle,					// Parent window handle
		250,							// x position 
		360,							// y position 
		200,							// width 
		25,								// height 
		&search4Text					// initial "on click" event handler 
	);
	mov( esi, eax );					// Save ptr to new button		
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.button7 );			// Save button pointer.
	this.insertWidget( eax );			// Add button to wForm's widget list.
	
	
	
	
	mov( main, esi );					// Retrieve ptr to main app's object
	wLabel_t.create_wLabel
	(
		"label4",						// Label name
		"Search For Prefix:",			// Text string
		this.handle,					// Parent window handle
		250,							// x position 
		395,							// y position 
		200,							// width 
		25,								// height 
		0,								// label style
		RGB( 0, 0, 0 ),					// foreground color (black)
		howl.bkgColor_g					// background color (gray)
	);
	mov( esi, eax );					// Save ptr to new label		
	(type wLabel_t [esi]).show();		// Show the label.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.label4 );			// Save label pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.
	
	
	mov( main, esi );					// Retrieve ptr to main app's object
	wEditBox_t.create_wEditBox
	(
		"editBox3",						// Editbox name
		"",								// initial text
		this.handle,					// Parent window handle
		250,							// x position 
		430,							// y position 
		200,							// width 
		35,	 							// height
		0,								// style
		NULL							// No onChange handler
	);
	mov( esi, eax );					// Save ptr to new label		
	(type wEditBox_t [esi]).show();		// Show the editbox.
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.editBox3 );			// Save editbox pointer.
	this.insertWidget( eax );			// Add label to wForm's widget list.
	
	


	
	mov( main, esi );					// Retrieve ptr to main app's object
	wPushButton_t.create_wPushButton
	(
		"button8",						// Button name
		"Search for Prefix",				// Caption for push button
		this.handle,					// Parent window handle
		250,							// x position 
		475,							// y position 
		200,							// width 
		25,								// height 
		&search4Prefix					// initial "on click" event handler 
	);
	mov( esi, eax );					// Save ptr to new button		
	mov( main, esi );					// Retrieve ptr to main app's object
	mov( eax, this.button8 );			// Save button pointer.
	this.insertWidget( eax );			// Add button to wForm's widget list.
	
	

	
	// We need to create a quit button and store the pointer to the
	// new button object in the this.button field on the form:
	
	wPushButton_t.create_wPushButton
	(
		"quitButton",				// Button name
		"Quit",						// Caption
		this.handle,				// parent window handle
		450,						// x position 
		525,						// y position 
		125,						// width 
		25,							// height 
		&onQuit						// "on click" event handler 
	);
	mov( esi, eax );				// Save ptr to new button		
	mov( main, esi );				// Retrieve ptr to main app's object
	mov( eax, this.quitButton );	// Save button pointer.
	this.insertWidget( eax );		// Add button to wForm's widget list.
	
    this.onCreate();				// Be nice, call this guy (even if empty).
    pop( edx );
    pop( ecx );
    pop( ebx );
    pop( eax );

end create_mainAppWindow;	


	

	


	
// Here's the onClick event handler for the search4Prefix button:

proc search4Prefix:widgetProc;
var
	srchText	:string;
	
begin search4Prefix;

	mov( mainAppWindow.editBox3, esi );
	(type wEditBox_t [esi]).a_get_text();
	mov( eax, srchText );
	
	stdout.put( "Searching for prefix '", srchText, "'" nl );
	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).find_prefix( srchText, 0 );
	if( eax <> w.LB_ERR ) then
	
		stdout.put( "Found at index: ", (type uns32 eax), nl );
		(type wListBox_t [esi]).set_curSel( eax );
		
	else
	
		stdout.put( "String not found" nl );
		
	endif;
	str.free( srchText );
	
end search4Prefix;


	


// Here's the onClick event handler for the search4Text button:

proc search4Text:widgetProc;
var
	srchText	:string;
	
begin search4Text;

	mov( mainAppWindow.editBox2, esi );
	(type wEditBox_t [esi]).a_get_text();
	mov( eax, srchText );
	
	stdout.put( "Searching for '", srchText, "'" nl );
	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).find_string( srchText, 0 );
	if( eax <> w.LB_ERR ) then
	
		stdout.put( "Found at index: ", (type uns32 eax), nl );
		(type wListBox_t [esi]).set_curSel( eax );
		
	else
	
		stdout.put( "String not found" nl );
		
	endif;
	str.free( srchText );
	
end search4Text;



// Here's the onClick event handler for the getCount button:

proc getCount:widgetProc;
var
	count		:string;
	countBuf	:char[128];
	
begin getCount;

	str.init( countBuf, @size( countBuf ));
	mov( eax, count );
	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).get_count();
	str.put( count, "Item Count: ", (type uns32 eax) );
	
	mov( mainAppWindow.label2, esi );
	(type wLabel_t [esi]).set_caption( count );
	
end getCount;
	

	


	
// Here's the onClick event handler for the reset button:

proc resetListBox:widgetProc;
begin resetListBox;

	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).reset();
	
end resetListBox;
	

	


	
// Here's the onClick event handler for the change color button:

proc changeColor:widgetProc;
begin changeColor;

	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).get_textColor();
	if( eax = RGB( 0, 0, 0 ) ) then
	
		(type wListBox_t [esi]).set_textColor( RGB( 255, 255, 0 ) );
		(type wListBox_t [esi]).set_bkgColor( RGB( 0, 0, 255 ) );
		
	else
	
		(type wListBox_t [esi]).set_textColor( RGB( 0, 0, 0 ) );
		(type wListBox_t [esi]).set_bkgColor( RGB( 255, 255, 255 ) );
		
	endif;
	w.InvalidateRect( (type wListBox_t [esi]).handle, NULL, true );
	
end changeColor;
	

	


	
// Here's the onClick event handler for the insert text button:

proc insertText:widgetProc;
var
	insertStr	:string;
	
begin insertText;

	mov( mainAppWindow.editBox1, esi );
	(type wEditBox_t [esi]).a_get_text();
	mov( eax, insertStr );
	
	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).add_string( insertStr );
	str.free( insertStr );
	
end insertText;
	

	


	
// Here's the onClick event handler for the delete text button:

proc deleteText:widgetProc;
var
	curSel		:dword;
	insertStr	:string;
	
begin deleteText;

	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).get_curSel();
	mov( eax, curSel );
	
	mov( mainAppWindow.listBox1, esi );
	(type wListBox_t [esi]).delete_string( curSel );
	
end deleteText;
	

	


	
// Here's the onClick event handler for our quit button on the form.
// This handler will simply quit the application:

proc onQuit:widgetProc;
begin onQuit;

	// Quit the app:
	
	w.PostQuitMessage( 0 );

end onQuit;





// We'll use the main application form's onCreate method to initialize
// the various buttons on the form.
//
// This could be done in appStart, but better to leave appStart mainly
// as boilerplate code. Also, putting this code here allows us to use
// "this" to access the mainAppWindow fields (a minor convenience).
		
method mainAppWindow_t.onCreate;
begin onCreate;
end onCreate;
	

	
	

///////////////////////////////////////////////////////////////////////////////
//
//
// The following is mostly boilerplate code for all apps (about the only thing
// you would change is the size of the main app's form)
//
//
///////////////////////////////////////////////////////////////////////////////
//	
// When the main application window closes, we need to terminate the 
// application. This overridden method handles that situation.  Notice the
// override declaration for onClose in the wForm declaration given earlier.
// Without that, mainAppWindow_t would default to using the wVisual_t.onClose
// method (which does nothing). 
		
method mainAppWindow_t.onClose;
begin onClose;
	
	// Tell the winmain main program that it's time to terminate.
	// Note that this message will (ultimately) cause the appTerminate
	// procedure to be called.
	
	w.PostQuitMessage( 0 );
	
	
end onClose;

			   
   

			   
   
// When the application begins execution, the following procedure
// is called.  This procedure must create the main
// application window in order to kick off the execution of the
// GUI application:
  
procedure appStart;
begin appStart;

	push( esi );
	
	// Create the main application window:
	
	mainAppWindow.create_mainAppWindow
	(
		applicationName,		// Window title
		w.WS_EX_CONTROLPARENT,	// Need this to support TAB control selection
		w.WS_OVERLAPPEDWINDOW,	// Style 
		NULL,					// No parent window 									
		formX,					// x-coordinate for window. 
		formY,					// y-coordinate for window.
		formW,					// Width
		formH,					// Height
		howl.bkgColor_g,		// Background color
		true					// Make visible on creation 
	);
	pop( esi );

end appStart;



// appTerminate-
//
//	Called when the application is quitting, giving the app a chance
// to clean up after itself.
//
// Note that this is called *after* the mainAppWindow_t.onClose method
// executes (indeed, mainAppWindow_t.onClose, by posting the quit message,
// is what actually causes the program to begin terminating, which leads
// to the execution of this procedure).

procedure appTerminate;
begin appTerminate;
	
	// Clean up the main application's form.
	// Note that this will recursively clean up all the widgets on the form.
	
	mainAppWindow.destroy();
	
end appTerminate;


// appException-
//
// Gives the application the opportunity to clean up before
// aborting when an unhandled exception comes along:

procedure appException
( 
	theException	:dword in eax;
	raiseAdrs		:dword in ebx;
	filename		:string in ecx;
	userCode		:dword in edx;
	lineNum			:uns32 in edi 
);
begin appException;

	raise( eax );

end appException;



// The main program for a HOWL application must 
// call the HowlMainApp procedure.

begin pgm_listbox6x;

	// Set up the background and transparent colors that the
	// form will use when registering the window_t class:
	
	w.GetSysColor( w.COLOR_MENU );
	mov( eax, howl.bkgColor_g );
	or( $FF00_0000, eax );
	mov( eax, howl.transparent_g );
	w.CreateSolidBrush( howl.bkgColor_g );
	mov( eax, howl.bkgBrush_g );

	// Start the HOWL Framework Main Program:
	
	HowlMainApp();
	
	// Delete the brush we created earlier:
	
	w.DeleteObject( howl.bkgBrush_g );			
				
end pgm_listbox6x;
 