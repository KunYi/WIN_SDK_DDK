// pgm_surface1-
//
//	This program demonstrates how to create a subclass of wView_t to
// create a drawing surface.

program pgm_surface1;
#linker( "comdlg32.lib" ) 
#linker( "comctl32.lib" )

?compileAll		:= true;

?@NoDisplay 	:= true;
?@NoStackAlign	:= true;

#includeOnce( "stdlib.hhf" )

#includeOnce( "howl.hhf" )


const
	windowTitle	:string := "Surface Demo #1";
	formX			:= w.CW_USEDEFAULT;	// Let Windows position this guy
	formY			:= w.CW_USEDEFAULT;
	formW			:= 600;
	formH			:= 600;
	
type
	mySurface:
		class inherits( wView_t );
		
			procedure create_wMySurface
			(
				wsName		:string;
				parent		:dword; 									
				x			:dword; 
				y			:dword;
				width		:dword;
				height		:dword;
				bkgColor	:dword;
				onPaint		:widgetProc 
			);
							
		endclass;
	
	mySurface_p	:pointer to mySurface;
	
static
	align( 4 );
	vmt( mySurface );
	
	
	
procedure mySurface.create_wMySurface
(
	wsName		:string;
	parent		:dword; 									
	x			:dword; 
	y			:dword;
	width		:dword;
	height		:dword;
	bkgColor	:dword;
	onPaint		:widgetProc 
);
begin create_wMySurface;

	push( eax );
	push( ecx );
	push( edx );
	

	// We're going to create a surface object here.
	
	(type wView_t [esi]).create_wView
	(
		wsName,
		0,								// ex style
		w.WS_CHILD | w.WS_VISIBLE,		// style
		parent,									
		x,	  
		y,	  
		width, 
		height,
		bkgColor,
		true
	);
	mov( cl, this.wBase_private.onHeap );
	mov( &mySurface._VMT_, this._pVMT_ );
	mov( onPaint, eax );
	mov( eax, this.wSurface_private.onPaint );
	w.InvalidateRect( this.handle, NULL, true );
	
	pop( edx );
	pop( ecx );			   
	pop( eax );

end create_wMySurface;

	
	
// Forward declaration for the onClick widgetProc that we're going to
// call when a button is pressed.

proc onQuit:widgetProc; @forward;



// Here's the main form definition for the app:

wForm( mainAppWindow );

	var
		view1	:mySurface_p;

	// Place a quit button in the lower-right-hand corner of the form:
	
	wPushButton
	(
		button,				// Field name in mainWindow object
		"Quit",				// Caption for push button
		450,				// x position 
		525,				// y position 
		125,				// width 
		25,					// height 
		onQuit				// "on click" event handler 
	)
	
endwForm


// Must invoke the following macro to emit the code generated by
// the wForm macro:

mainAppWindow_implementation();
	


// Here's the onPaint event handler for our view on the form.

proc onPaint:widgetProc;
const
	ths	:text := "(type wSurface_t [esi])";
	
var
	r			:w.RECT;
	hdc			:dword;
	pen			:dword;
	brush		:dword;
	oldBrush	:dword;
	oldPen		:dword;
	ps			:w.PAINTSTRUCT;

begin onPaint;

	mov( thisPtr, esi );
	w.BeginPaint( ths.handle, ps );
		
		mov( eax, hdc );
		
		mov( 0, r.left );
		mov( ths.wVisual_private.width, eax );
		mov( eax, r.right );
		
		mov( 0, r.top );
		mov( ths.wVisual_private.height, eax );
		mov( eax, r.bottom );

		// Fill the wTabPage's window with the background color:
		
		w.FillRect( hdc, r, ths.wVisual_private.bkgBrush );
		
		// Select the round rect's pen and fill values:
		
		w.CreatePen( w.PS_SOLID, 0, RGB( 255, 0, 0 ) );
		mov( eax, pen );
		w.SelectObject( hdc, eax );
		mov( eax, oldPen );
		
		w.CreateSolidBrush( RGB( 0, 0, 255) );
		mov( eax, brush );
		w.SelectObject( hdc, eax );
		mov( eax, oldBrush );
							   			
		// Draw a wRoundRect:
		
		w.RoundRect
		( 
			hdc, 
			0,
			0,
			ths.wVisual_private.width,
			ths.wVisual_private.height,
			25,
			25
		);
		
		w.SelectObject( hdc, oldBrush );
		w.SelectObject( hdc, oldPen );
		w.DeleteObject( pen );
		w.DeleteObject( brush );
		
		
		// Select the ellipse's pen and fill values:
		
		w.CreatePen( w.PS_SOLID, 0, RGB( 0, 0, 0 ) );
		mov( eax, pen );
		w.SelectObject( hdc, eax );
		mov( eax, oldPen );
		
		w.CreateSolidBrush( RGB( 0, 255, 0) );
		mov( eax, brush );
		w.SelectObject( hdc, eax );
		mov( eax, oldBrush );
							   			
		// Draw a circle:
		
		w.Ellipse
		( 
			hdc, 
			0,
			0,
			ths.wVisual_private.width,
			ths.wVisual_private.height
		);
		
		w.SelectObject( hdc, oldBrush );
		w.SelectObject( hdc, oldPen );
		w.DeleteObject( pen );
		w.DeleteObject( brush );
		
					
	w.EndPaint( ths.handle, ps );

end onPaint;


// Here's the onClick event handler for our quit button on the form.
// This handler will simply quit the application:

proc onQuit:widgetProc;
begin onQuit;

	// Quit the app:
	
	w.PostQuitMessage( 0 );

end onQuit;


// The following gets called immediately after the main application
// window is created. It must be provided, even if it does nothing.
		
method mainAppWindow_t.onCreate;
begin onCreate;

	// Surface objects aren't supported by the HOWL declarative
	// language, so we have to manually create one here:
	
	push( esi );
	mySurface.create_wMySurface
	(
		"surface1",			// wpName:string;
		this.handle,		// parentWindowHandle:dword;
		10,					// x:dword;
		10,					// y:dword;
		100,				// width:dword;
		100,				// height:dword;
		howl.bkgColor_g,	// fillColor :dword
		&onPaint			// onPaint:widgetProc 									
	);
	mov( esi, mainAppWindow.view1 );
	(type mySurface [esi]).show();
	mov( esi, eax );
	pop( esi );
	this.insertWidget( eax );
	w.InvalidateRect( this.handle, NULL, true );
	
end onCreate;

			   
	
	
///////////////////////////////////////////////////////////////////////////////
//
//
// The following is mostly boilerplate code for all apps (about the only thing
// you would change is the size of the main app's form)
//
//
///////////////////////////////////////////////////////////////////////////////
//	
// When the main application window closes, we need to terminate the 
// application. This overridden method handles that situation.  Notice the
// override declaration for onClose in the wForm declaration given earlier.
// Without that, mainAppWindow_t would default to using the wVisual_t.onClose
// method (which does nothing). 
		
method mainAppWindow_t.onClose;
begin onClose;
	
	// Tell the winmain main program that it's time to terminate.
	// Note that this message will (ultimately) cause the appTerminate
	// procedure to be called.
	
	w.PostQuitMessage( 0 );
	
	
end onClose;

			   
   
   
// When the application begins execution, the following procedure
// is called.  This procedure must create the main
// application window in order to kick off the execution of the
// GUI application:
  
procedure appStart;
begin appStart;

	push( esi );
	
	// Create the main application window:
	
	mainAppWindow.create_mainAppWindow
	(
		windowTitle,			// Window title
		w.WS_EX_CONTROLPARENT,	// Need this to support TAB control selection
		w.WS_OVERLAPPEDWINDOW,	// Style 
		NULL,					// No parent window 									
		formX,					// x-coordinate for window. 
		formY,					// y-coordinate for window.
		formW,					// Width
		formH,					// Height
		howl.bkgColor_g,		// Background color
		true					// Make visible on creation 
	);
	mov( esi, pmainAppWindow );	// Save pointer to main window object.
	pop( esi );

end appStart;



// appTerminate-
//
//	Called when the application is quitting, giving the app a chance
// to clean up after itself.
//
// Note that this is called *after* the mainAppWindow_t.onClose method
// executes (indeed, mainAppWindow_t.onClose, by posting the quit message,
// is what actually causes the program to begin terminating, which leads
// to the execution of this procedure).

procedure appTerminate;
begin appTerminate;
	
	// Clean up the main application's form.
	// Note that this will recursively clean up all the widgets on the form.
	
	mainAppWindow.destroy();
	
end appTerminate;


// appException-
//
// Gives the application the opportunity to clean up before
// aborting when an unhandled exception comes along:

procedure appException
( 
	theException	:dword in eax;
	raiseAdrs		:dword in ebx;
	filename		:string in ecx;
	userCode		:dword in edx;
	lineNum			:uns32 in edi 
);
begin appException;

	raise( eax );

end appException;



// The main program for a HOWL application must 
// call the HowlMainApp procedure.

begin pgm_surface1;

	// Set up the background and transparent colors that the
	// form will use when registering the window_t class:
	
	w.GetSysColor( w.COLOR_MENU );
	mov( eax, howl.bkgColor_g );
	or( $FF00_0000, eax );
	mov( eax, howl.transparent_g );
	w.CreateSolidBrush( howl.bkgColor_g );
	mov( eax, howl.bkgBrush_g );

	// Start the HOWL Framework Main Program:
	
	HowlMainApp();
	
	// Delete the brush we created earlier:
	
	w.DeleteObject( howl.bkgBrush_g );			
				
end pgm_surface1;
 