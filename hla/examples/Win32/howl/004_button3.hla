// button3-
//
//	This program expands on button2 by demonstrating multiple buttons,
// simulated button clicks, double clicks, showing and hiding buttons,
// enabling and disabling buttons, moving buttons, and resizing buttons.

program button3;
#linker( "comdlg32.lib" ) 
#linker( "comctl32.lib" )

?compileAll		:= true;

?@NoDisplay 	:= true;
?@NoStackAlign	:= true;

#includeOnce( "stdlib.hhf" )

#includeOnce( "howl.hhf" )



const
	applicationName := "Button Demo #3";
	formX			:= w.CW_USEDEFAULT;	// Let Windows position this guy
	formY			:= w.CW_USEDEFAULT;
	formW			:= 600;
	formH			:= 600;



	
// Forward declarations for the onClick widgetProcs that we're going to
// call when a button is pressed.

proc onSetFocus1			:widgetProc; @forward;
proc onKillFocus1			:widgetProc; @forward;
proc onClickChange1			:widgetProc; @forward;
proc onClickChange2			:widgetProc; @forward;
proc hideShowButton			:widgetProc; @forward;
proc enableDisableButton	:widgetProc; @forward;
proc moveButton				:widgetProc; @forward;
proc resizeButton			:widgetProc; @forward;
proc onDblClick				:widgetProc; @forward;
proc onQuit					:widgetProc; @forward;



// Here's the main form definition for the app:

wForm( mainAppWindow );

	var
		showState	:boolean;
		b1Enabled	:boolean;
		align(4);
	
	wPushButton
	(
		button1,				// Field name in mainWindow object
		"Button #1",			// Caption for push button
		10,						// x position 
		10,						// y position 
		125,					// width 
		25,						// height 
		onClickChange1			// initial "on click" event handler 
	)
	
	
	wPushButton
	(
		button2,				// Field name in mainWindow object
		"Hide button 1",		// Caption for push button
		175,					// x position 
		10,						// y position 
		125,					// width 
		25,						// height 
		hideShowButton			// initial "on click" event handler 
	)
	
	
	wPushButton
	(
		button3,				// Field name in mainWindow object
		"Disable button 1",		// Caption for push button
		175,					// x position 
		40,						// y position 
		125,					// width 
		25,						// height 
		enableDisableButton		// initial "on click" event handler 
	)
	
	
	wPushButton
	(
		button4,				// Field name in mainWindow object
		"Move button 1",		// Caption for push button
		175,					// x position 
		70,						// y position 
		125,					// width 
		25,						// height 
		moveButton				// initial "on click" event handler 
	)
	
	
	wPushButton
	(
		button5,				// Field name in mainWindow object
		"Resize button 1",		// Caption for push button
		175,					// x position 
		100,					// y position 
		125,					// width 
		25,						// height 
		resizeButton			// initial "on click" event handler 
	)
	
	
	wPushButton
	(
		button6,				// Field name in mainWindow object
		"DblClick to Click",	// Caption for push button
		175,					// x position 
		130,					// y position 
		125,					// width 
		25,						// height 
		NULL					// no single click handler 
	)
	
	
	// Place a quit button in the lower-right-hand corner of the form:
	
	wPushButton
	(
		quitButton,				// Field name in mainWindow object
		"Quit",					// Caption for push button
		450,					// x position 
		525,					// y position 
		125,					// width 
		25,						// height 
		onQuit					// "on click" event handler 
	)
	
endwForm


// Must invoke the following macro to emit the code generated by
// the wForm macro:

mainAppWindow_implementation();
	






// The onDblClick widget proc will handle a double click on button6
// and simulate a single click on button 1.

proc onDblClick:widgetProc;
begin onDblClick;

	mov( mainAppWindow.button1, esi );
	(type wPushButton_t [esi]).click();
	
end onDblClick;
	


// The resizeButton widget proc will resize button1 between widths 125 and 150.

proc resizeButton:widgetProc;
begin resizeButton;

	mov( mainAppWindow.button1, esi );
	(type wPushButton_t [esi]).get_width();
	if( eax = 125 ) then
	
		stdout.put( "Resizing button to width 150" nl );
		(type wPushButton_t [esi]).set_width( 150 );
		
	else
	
		stdout.put( "Resizing button to width 125" nl );
		(type wPushButton_t [esi]).set_width( 125 );
		
	endif;
	
end resizeButton;
	


// The moveButton widget proc will move button1 between y positions 10 and 40.

proc moveButton:widgetProc;
begin moveButton;

	mov( mainAppWindow.button1, esi );
	(type wPushButton_t [esi]).get_y();
	if( eax = 10 ) then
	
		stdout.put( "Moving button to y-position 40" nl );
		(type wPushButton_t [esi]).set_y( 40 );
		
	else
	
		stdout.put( "Moving button to y-position 10" nl );
		(type wPushButton_t [esi]).set_y( 10 );
		
	endif;
	
end moveButton;
	


// The enableDisableButton widget proc will enable and disable button1.

proc enableDisableButton:widgetProc;
begin enableDisableButton;

	mov( thisPtr, esi );
	if( mainAppWindow.b1Enabled ) then
	
		(type wPushButton_t [esi]).set_text( "Enable button 1" );
		mov( false, mainAppWindow.b1Enabled );
		stdout.put( "Disabling button 1" nl );
		mov( mainAppWindow.button1, esi );
		(type wPushButton_t [esi]).disable();
		
	else
	
		(type wPushButton_t [esi]).set_text( "Disable button 1" );
		mov( true, mainAppWindow.b1Enabled );
		stdout.put( "Enabling button 1" nl );
		mov( mainAppWindow.button1, esi );
		(type wPushButton_t [esi]).enable();
		
	endif;	
	
end enableDisableButton;
	


// The hideShowButton widget proc will hide and show button1.

proc hideShowButton:widgetProc;
begin hideShowButton;

	mov( thisPtr, esi );
	if( mainAppWindow.showState ) then
	
		(type wPushButton_t [esi]).set_text( "Hide button 1" );
		mov( false, mainAppWindow.showState );
		stdout.put( "Showing button 1" nl );
		mov( mainAppWindow.button1, esi );
		(type wPushButton_t [esi]).show();
		
	else
	
		(type wPushButton_t [esi]).set_text( "Show button 1" );
		mov( true, mainAppWindow.showState );
		stdout.put( "Hiding button 1" nl );
		mov( mainAppWindow.button1, esi );
		(type wPushButton_t [esi]).hide();
		
	endif;	
	
end hideShowButton;
	


// The onSetFocus and onKillFocus widgetProcs simply print to the console
// what has happened.

proc onSetFocus1:widgetProc;
begin onSetFocus1;

	stdout.put( "Set focus to button 1" nl );
	
end onSetFocus1;


proc onKillFocus1:widgetProc;
begin onKillFocus1;

	stdout.put( "Shifted focus from button 1" nl );
	
end onKillFocus1;


// Here's 1 of 2 onClick handlers for button1. This widgetProc
// changes the caption to "Restore caption" and sets the 
// onClick pointer to point at the second onClick handler.


proc onClickChange1:widgetProc;
var
	curCaption	:string;
	curCapBuf	:char[256];
	
begin onClickChange1;

	str.init( curCapBuf, @size( curCapBuf ));
	mov( eax, curCaption );
	
	mov( thisPtr, esi );		// ESI already contains this, but just in case...
	
	// Print the current caption to the console window:
	
	(type wPushButton_t [esi]).get_text( curCaption );
	stdout.put( "Current caption1: ", curCaption, nl );
	

	// Change the caption:
	
	(type wPushButton_t [esi]).set_text( "Restore Button #1" );
	
	// Point the onClick handler at onClickChange2:
	
	(type wPushButton_t [esi]).set_onClick( &onClickChange2 );

	
	// Print the new caption to the console window:
	
	(type wPushButton_t [esi]).a_get_text();
	stdout.put( "New caption1: ", (type string eax), nl nl );
	str.free( eax );

end onClickChange1;
	
	

// Here's 2 of 2 onClick handlers for button1. This widgetProc
// changes the caption back to "Restore caption" and sets the 
// onClick pointer to point at the first onClick handler.


proc onClickChange2:widgetProc;
var
	curCaption	:string;
	curCapBuf	:char[256];
	
begin onClickChange2;

	str.init( curCapBuf, @size( curCapBuf ));
	mov( eax, curCaption );
	
	mov( thisPtr, esi );		// ESI already contains this, but just in case...
	
	// Print the current caption to the console window:
	
	(type wPushButton_t [esi]).get_text( curCaption );
	stdout.put( "Current caption2: ", curCaption, nl );
	

	// Change the caption:
	
	(type wPushButton_t [esi]).set_text( "Button #1" );
	
	// Point the onClick handler at onClickChange1:
	
	(type wPushButton_t [esi]).set_onClick( &onClickChange1 );

	
	// Print the new caption to the console window:
	
	(type wPushButton_t [esi]).a_get_text();
	stdout.put( "New caption2: ", (type string eax), nl nl );
	str.free( eax );

end onClickChange2;
	
	

// Here's the onClick event handler for our quit button on the form.
// This handler will simply quit the application:

proc onQuit:widgetProc;
begin onQuit;

	// Quit the app:
	
	w.PostQuitMessage( 0 );

end onQuit;





// We'll use the main application form's onCreate method to initialize
// the various buttons on the form.
//
// This could be done in appStart, but better to leave appStart mainly
// as boilerplate code. Also, putting this code here allows us to use
// "this" to access the mainAppWindow fields (a minor convenience).
		
method mainAppWindow_t.onCreate;
var
	thisPtr	:dword;
	
begin onCreate;

	mov( esi, thisPtr );
	
	// Initialize the showState and enableDisableButton data fields:
		
	mov( false, this.showState );
	mov( true, this.b1Enabled );
	
	// Lets set up the button1's onSetFocus and onKillFocus event handlers:
	
	mov( this.button1, esi );
	(type wPushButton_t [esi]).set_onSetFocus( &onSetFocus1 );
	(type wPushButton_t [esi]).set_onKillFocus( &onKillFocus1 );
	
	// Set up button6's onDblClick handler:
	
	mov( thisPtr, esi );
	mov( this.button6, esi );
	(type wPushButton_t [esi]).set_onDblClick( &onDblClick );

end onCreate;

	
	
///////////////////////////////////////////////////////////////////////////////
//
//
// The following is mostly boilerplate code for all apps (about the only thing
// you would change is the size of the main app's form)
//
//
///////////////////////////////////////////////////////////////////////////////
//	
// When the main application window closes, we need to terminate the 
// application. This overridden method handles that situation.  Notice the
// override declaration for onClose in the wForm declaration given earlier.
// Without that, mainAppWindow_t would default to using the wVisual_t.onClose
// method (which does nothing). 
		
method mainAppWindow_t.onClose;
begin onClose;
	
	// Tell the winmain main program that it's time to terminate.
	// Note that this message will (ultimately) cause the appTerminate
	// procedure to be called.
	
	w.PostQuitMessage( 0 );
	
	
end onClose;

			   
  
			   
   
// When the application begins execution, the following procedure
// is called.  This procedure must create the main
// application window in order to kick off the execution of the
// GUI application:
  
procedure appStart;
begin appStart;

	push( esi );
	
	// Create the main application window:
	
	mainAppWindow.create_mainAppWindow
	(
		applicationName,		// Window title
		w.WS_EX_CONTROLPARENT,	// Need this to support TAB control selection
		w.WS_OVERLAPPEDWINDOW,	// Style 
		NULL,					// No parent window 									
		formX,					// Form x-coordinate 
		formY,					// Form y-coordinate
		formW,					// Width
		formH,					// Height
		howl.bkgColor_g,		// Background color
		true					// Make visible on creation 
	);
	mov( esi, pmainAppWindow );	// Save pointer to main window object.

	pop( esi );

end appStart;



// appTerminate-
//
//	Called when the application is quitting, giving the app a chance
// to clean up after itself.
//
// Note that this is called *after* the mainAppWindow_t.onClose method
// executes (indeed, mainAppWindow_t.onClose, by posting the quit message,
// is what actually causes the program to begin terminating, which leads
// to the execution of this procedure).

procedure appTerminate;
begin appTerminate;
	
	// Clean up the main application's form.
	// Note that this will recursively clean up all the widgets on the form.
	
	mainAppWindow.destroy();
	
end appTerminate;


// appException-
//
// Gives the application the opportunity to clean up before
// aborting when an unhandled exception comes along:

procedure appException
( 
	theException	:dword in eax;
	raiseAdrs		:dword in ebx;
	filename		:string in ecx;
	userCode		:dword in edx;
	lineNum			:uns32 in edi 
);
begin appException;

	raise( eax );

end appException;



// The main program for a HOWL application must 
// call the HowlMainApp procedure.

begin button3;

	// Set up the background and transparent colors that the
	// form will use when registering the window_t class:
	
	w.GetSysColor( w.COLOR_MENU );
	mov( eax, howl.bkgColor_g );
	or( $FF00_0000, eax );
	mov( eax, howl.transparent_g );
	w.CreateSolidBrush( howl.bkgColor_g );
	mov( eax, howl.bkgBrush_g );

	// Start the HOWL Framework Main Program:
	
	HowlMainApp();
	
	// Delete the brush we created earlier:
	
	w.DeleteObject( howl.bkgBrush_g );			
				
end button3;
 