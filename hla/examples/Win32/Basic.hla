// HLABasic
//
//	This project started out as a conversion of Sylvain's "Mini-Basic" 
// from MASM32 to HLA.  However, I quickly decided that I wanted a relatively
// full-featured BASIC and I didn't want a pure interpreter (for performance
// reasons.  Hence, very little of this code is at all similar to the original
// "Mini-BASIC" interpreter by Sylvain.  I have maintained many of the console
// statements, however.
//
//	There are two documents accompanying this code: the HLABasic user's manual
// that explains the language to a BASIC programmer and the HLABasic
// implementor's guide that explains the organization of this source code.
// If you're interested in modifying this BASIC interpreter for your own
// purposes, you'll want to take a look at this latter document.  If you just
// want to use the BASIC interpreter as-is, then the former document is
// probably all that you will need.
//
//	This code was converted to HLA.  You can down load HLA from
//	Webster at http://webster.cs.ucr.edu.
//
//	Randall Hyde, 4/19/2001
//
//
//	Warning: This code was written just for fun.  It has not been rigorously
//	tested.  It is your responsbility to determine the fitness of this code
//	for any application.  The author supplies this code strictly on an "as-is"
//	basis without warranty of any kind.
//
// Note: HLABASIC uses the old Win32 console routines from the standard
// library. You must explicitly compile and link in that library with this
// code.





program MiniBASIC;
#include( "win32cons.hhf" )
#include( "stdlib.hhf" )

static
	Sleep:procedure( ms:dword ); @external( "__imp__Sleep@4" );

const
	DEBUG := true;
	

	// Win API declarations:
	
	procedure FillConsoleOutputAttribute
	( 
		var lpNumberOfAttrsWritten:dword;
			dwWriteCoord: win.COORD;
			nLength: dword;
			wAttribute: word;
			hConsoleOutput: dword
	);
		@external( "_FillConsoleOutputAttribute@20" );
		

	procedure FillConsoleOutputCharacter
	( 
		var lpNumberOfCharsWritten:dword;
			dwWriteCoord: win.COORD;
			nLength: dword;
			cCharacter:char;
			hConsoleOutput: dword
	);
		@external( "_FillConsoleOutputCharacterA@20" );
		
	procedure GetLargestConsoleWindowSize( handle:dword );
		@external( "_GetLargestConsoleWindowSize@4" );
		

	procedure SetConsoleWindowInfo
	(
		lpConsoleWindow: win.small_rect;
		bAbsolute:boolean;
		hConsoleOutput: dword
	);
		@external( "_SetConsoleWindowInfo@12" );
		
		
	procedure SetConsoleScreenBufferSize
	(
		dwSize: win.COORD;
		hConsoleOutput: dword
	);
		@external( "_SetConsoleScreenBufferSize@8" );


	procedure VkKeyScan( c:char ); @external( "_VkKeyScanA@4" );
	
	procedure WriteConsoleInput
	(
		var lpNumberOfEventsWritten: dword;
			nLength:dword;
		var	ker:win.KEY_EVENT_RECORD;
			hConsoleInput:dword
	);
		@external( "_WriteConsoleInputA@16" );
		
		

const
	MaxArraySize	:= 65536;		// Maximum # of elements in an array.
	MaxNestedFors	:= 32;			// Maximum # of nested FOR loops.
	MaxNestedGosubs	:= 64;			// Maximum # of nested GOSUB invocations.
	MaxLabelLength	:= 32;			// Maximum length of an identifier.
	
	// Exceptions defined for this program:
	
	BasicError				:= 1024;		
	StmtTooLongException	:= BasicError + 1;
	LineNumberException		:= StmtTooLongException + 1;
	SyntaxErrorException	:= LineNumberException + 1;
	BadPgmDataException		:= SyntaxErrorException + 1;
	NoSuchLineException		:= BadPgmDataException + 1;
	RtnWOGosubException		:= NoSuchLineException + 1;
	PgmStopException		:= RtnWOGosubException + 1;
	LabelSyntaxException	:= PgmStopException + 1;
	ExprSyntaxException		:= LabelSyntaxException + 1;
	
	// Warning: Because of the "interesting" way that MASM assembles
	// large arrays, you probably don't want to make the following
	// constant much larger than about 256K because it will take a long
	// time for MASM to assemble HLA's output if you do.
	// If you really want to set aside a large amount of space for the
	// BASIC program, either dynamically allocate this storage or put
	// it in a VAR section (see PgmSpace below).
	
	PgmSize			:= $10000;		// 64K for BASIC program text area.



	
type
	ProcType:	procedure;

	// ForRecord-  Data structure for the FOR loop stack:
	
	ForRecord: record
	
		VarAdrs:	dword;		// Adress of FOR loop variable 
		Limit:		int32;		// Higher value of FOR variable
		Increment:	int32;		// STEP increment or 1
		Line:		dword;
		Stmt:		dword;		// Address to go back with NEXT 
		
	endrecord;

	// GosubRecord-	Data structure for the Gosub stack:
	
	GosubRecord: record
	
		RtnAdrs:	dword;		// Ptr to byte GOSUB
		LinePtr:	dword;		// Ptr to line containing GOSUB.
		
	endrecord;
	
	// StmtRec- Data structure for a basic statement.
	
	StmtRec: record
	
		size:		uns8;		// Size of this line.
		leading:	uns8;		// # of spaces between line# and stmt.
		lineNum:	uns16;		// Binary form of line number.
		stmt:		byte;		// Start of stmt text.
		
	endrecord;
	
	
	// Reserved word tokens:
	
	ReservedWords: 
		enum
		{
			StmtEndtkn,		// Must be first
			StmtSeptkn,		// Must be second.
			Labeltkn,
			
			IDtkn,
			INTtkn,
			FLTtkn,
			STRtkn,

			ACOSftkn, 
			ASCftkn, 
			ASINftkn, 
			ATANftkn, 
			CHRftkn, 
			COSftkn, 
			EXPftkn, 
			INTftkn,	
			LEFTftkn, 
			LENftkn, 
			LOGftkn, 
			MIDftkn, 
			RANDOMIZEftkn,							
			RIGHTftkn,
			RNDftkn,				
			ROUNDftkn,				
			SINftkn, 
			SQRTftkn, 
			STRftkn, 
			TANftkn, 
			VALftkn, 

			
			LTtkn,
			LEtkn,
			GTtkn,
			GEtkn,
			EQtkn,
			NEtkn,
			ORtkn,
			ANDtkn,
			NOTtkn,
			PLUStkn,
			MINUStkn,
			MULtkn,
			DIVtkn,
			MODtkn,
			LPARENtkn,
			RPARENtkn,
			LBRACKtkn,
			RBRACKtkn,
			COMMAtkn,
			SEMICOLONtkn,
						
			BEEPtkn,
			CLStkn,
			COLORtkn,
			DEBUGtkn,
			DIMtkn,
			ELSEtkn,
			ENDIFtkn,
			FORtkn,
			GETtkn,
			GOSUBtkn,
			GOTOtkn,
			GOTOXYtkn,
			IFtkn,
			INPUTtkn,
			LETtkn,
			NEXTtkn,
			ONtkn,
			ONGOSUBtkn,
			ONGOTOtkn,
			PRINTtkn,
			READLNtkn,
			REMtkn,
			RETURNtkn,
			RUNtkn,
			STEPtkn,
			STOPtkn,
			TOtkn,
			THENtkn,
			WAITtkn			
		}; 
	
	
	
	// vTypes specifies the data types that HLABasic supports:
	
	vTypes:
		enum
		{ 
			Undefined_c,
			Label_c,
			LabelVar_c,
			Array_c, 
			Integer_c, 
			Real_c, 
			String_c 
		};
		
	
	// The value of a HLABasic variable is held within a variable
	// of the Variant type:
	
	Variant: record
	


		union
		
			a: record
			
				elements:	uns32;	// Number of elements for this array.
				array:		dword;	// Pointer to array data.
				
			endrecord;
			i:int32;		// Integer value if Integer_c object.
			l:dword;		// Stmt address if Label_c object.
			r:real64;		// Real value if Real_c object.
			s:string;		// String value if String_c object.
			
		endunion;
		
		DataType: vTypes;	// Type of this particular variable.
		
		// For arrays, make this an even multiple of four bytes
		// (for performance reasons).
		
		align(4);			
		
	endrecord;
	
	


static
	align( 4 );
	EditColors:	dword	:= $70;		// Gray background, black foreground.
	EditSizeX:	word 	:= 80;		// Default screen width.
	EditSizeY:	word 	:= 30;		// Default screen height.
	PromptChar:	char 	:= '>';		// Input prompt.
	PromptColor:byte 	:= $c;		// Red foreground.
	Disp1Char:	char 	:= ' ';
	
	inputRec:	win.INPUT_RECORD;
	
			

storage
	
	dtemp1:		dword;					// Dummy dest var for Win APIs.
	Sstack:		dword;					//Here is saved the stack pointer
	
	// cbsi holds the console window information.
	
	csbi: 			win.CONSOLE_SCREEN_BUFFER_INFO;
	SmallRect:		win.small_rect;		// Coordinates of console screen in 
										//   Console Screen Buffer.
										
	align( 4 ); 
	ColorsCurrent: dword;				// Current colors used
	ConsoleCharNbr:dword;				// Number of char. in current console   
										//  screen (1 = Insert, 0 = Normal)

	EventBuffer: win.KEY_EVENT_RECORD;	// Keyboard input information. 

	align( 4 );
	hStdIn:			dword;				// Standard input and output 
	hStdOut:		dword;				//	handles given by Windows.


	Input:			string;				// Used to read strings from user.
	LineNumberStr:	string;				// Holds line number from input line.
	LineStr:		string;				// Holds line after line number.
	
	CurLineNum:		uns16;
	LastLineNum:	uns16;
								
	
	Vars:			pointer to table;	// Lookup table for symbols.									


	// Stacks to maintain FOR/NEXT and GOSUB/RETURN statements

	ForStackPtr:	dword;
	ForStack:		ForRecord[ MaxNestedFors ];
	
	GosubStackPtr:	dword;
	GosubStack:		GosubRecord[ MaxNestedGosubs ];
	
	ExprStack:		Variant[ 64 ];
	

	// Program storage space and pointer variables:
	
	align( 4 );
	
	TxtStart:		dword;				// Basic text area
	TxtEnd:			dword;				// End of Basic Text pointer

	PgmSpace:		byte[ PgmSize ];	// Program storage space.
	
	
	// DEBUG control
	
	debugFlag:		boolean;			// Turns run-time trace on/off.


	
readonly

	BasicTitle	:string := "HLA-Basic V1.0" nl;
	WinTitle	:string := "HLA-Basic V1.0";
	ClearInput	:string := "          ";	// Fill input area with spaces
	
	
	
	
	
/*****************************************************/
/* 	                                                 */
/* FreeVars-                                         */
/*                                                   */
/* This is the "FreeValue" procedure that this code  */
/* passes to the table.destroy method.               */                            
/* On entry, EBX points at a hash table entry        */
/* for a variable.  This procedure frees the         */
/* storage associated with that variable.            */
/*                                                   */
/*****************************************************/


procedure FreeVars; @nodisplay; @noframe;

	// RecursiveFree- Local procedure that does most of the
	// real work for FreeVars.
	//
	// On entry, EBX points at the VARIANT object to free.
	// This code wipes out EBX, ECX, and EDX.
	
	procedure RecursiveFree; @nodisplay; @noframe;
	begin RecursiveFree;
	
		// First, check to see if this variable is undefined.
		// If so, we don't have to do anything.
		
		if( ebx = NULL ) then
		
			ret();
			
		endif;
		
		// Next, check to see if this is an array
		// or a string variable and deallocate the 
		// storage if this is one of these.
		
		if( (type Variant [ebx]).DataType = Array_c ) then
		
			// We've got an array.  Let's check to see if there
			// has been any storage allocated for this array
			// (if so, the a.array field will be non-NULL).
			
			if( (type Variant [ebx]).a.array <> NULL ) then
			
				// Okay, we've got an array.  Therefore, we have
				// to step through each element of the array and
				// manually deallocate those elements.
				
				push( ebx );
				push( ecx );
				mov( (type Variant [ebx]).a.elements, ecx );
				mov( (type Variant [ebx]).a.array, ebx );
				while( ecx > 0 ) do
				
					RecursiveFree();
					add( @size( Variant ), ebx );
					dec( ecx );
					
				endwhile;
				
				// Okay, now free the array data:
				
				pop( ecx );
				pop( ebx );
				free( ebx );
				
			endif;
				
		
		// If we get down here, we've got a scalar object.  We only
		// have to do something special if it's a string.
				
		elseif( (type Variant [ebx]).DataType = String_c ) then
		
			strfree( (type Variant [ebx]).s );
			
		endif;
		ret();
		
	end RecursiveFree;
	
begin FreeVars;

	
	push( ebx );
	mov( (type tableNode [ebx]).Value, ebx );
	push( ebx );
	
	// Free the storage (if any) associated with each
	// the variant object (i.e., strings an arrays).
	 
	RecursiveFree();

	// Now deallocate the storage associated with the
	// variable itself.

	pop( ebx );
	free( ebx );
	
	pop( ebx );
	ret();
		
end FreeVars;




/******************************************************************************	

Tokenized line format:

Each line of text in the PgmSpace buffer takes the following form:


|   1 byte  |      1 byte    |   2 bytes   |  n bytes  | 1 byte |
| Line_Size | Leading_Spaces | Line_Number | Line_Text |   0    |

n = LineSize - 5

Line_Size is the number of bytes for the entire statement, including
the overhead bytes (Line_Size, Leading_Spaces, Line_Number, and
zero terminating byte).  Note that Line_Text is limited to 250
characters in length (this isn't necessarily 250 characters of
source because tokenization can actually expand certain lines).

Leading_Spaces is the number of space characters (minus one) between
the line number and the start of the (non-blank) text in the statement.
This allows the user to indent their code the editor will maintain
the indentation.

Line_Number is the uns16 binary equivalent of the line number associated
with this statement.

Line_Text is a tokenized form of the source line.  Token descriptions
appear a little later.  Statements always begin with a statement token.

All source lines end with a zero terminating (sentinel) byte to help
make determining the end of a statement more efficient.

	
******************************************************************************/






procedure GetLineNum( ln:string ); @nodisplay; @returns( "ax" );
begin GetLineNum;

	conv.strTou32( ln, 0 );
	if( eax not in 1..65535 ) then
	
		raise( LineNumberException );
		
	endif;
	
end GetLineNum;



/*****************************************/
/*                                       */
/* AtLineNumber-                         */
/*                                       */
/* A little utility routine that prints  */
/* " at line number xx" where xx is the  */
/* current source file line number (this */
/* code assumes that EBX is pointing at  */
/* the start of the current line).       */
/*                                       */
/*****************************************/

procedure AtLineNumber; @nodisplay; @noframe;
begin AtLineNumber;

	stdout.put( " at line number ", (type StmtRec [ebx]).lineNum, nl );
	ret();
	
end AtLineNumber;


//////////////////////////////////////////////////////////////////////////////
//
//	Run-time stuff (time critical)
//
//////////////////////////////////////////////////////////////////////////////



/************************************************************/
/*                                                          */
/* AllocCons- Initializes the standard input/output handles */
/*                                                          */
/************************************************************/

procedure AllocCons; @noframe; @nodisplay;
begin AllocCons;

	mov( stdin.handle(), hStdIn );
	mov( stdout.handle(), hStdOut );
	ret();

end AllocCons;




/****************************************************************************/
/*                                                                          */
/* RedimWindow-                                                             */
/*                                                                          */
/* Redim a new console window with sizes Y and X and update                 */
/* screen colors attributes Tests if new size fits in Window's screen sizes */
/*                                                                          */
/****************************************************************************/

procedure CLS; forward;

procedure RedimWindow( x:word; y:word ); @nodisplay; 
begin RedimWindow;

	// Get the current console information and make sure
	// that the user's parameters are within range.
	
	win32cons.info( csbi );
	GetLargestConsoleWindowSize( hStdOut );
	if( x > ax ) then
	
		stdout.put( "Console width is too large." nl );
		raise( BasicError );
		
	endif;
	rol( 16, eax );
	if( y > ax ) then
	
		stdout.put( "Console height is too large." nl );
		raise( BasicError );
		
	endif;
	
	// Compute the new window buffer size based on the
	// parameter values:
	
	mov( x, si );
	mov( y, di );
	 
	mov( si, ax );
	mul( di );
	push( eax );				// Save requested buffer size.
	
	mov( csbi.dwSize.X, ax );	// Compute current buffer size.
	mul( csbi.dwSize.Y );
	
	mov( si, csbi.dwSize.X );	// Set new coordinate size.
	mov( di, csbi.dwSize.Y );
	mov( 0, csbi.srWindow.left );
	mov( 0, csbi.srWindow.top );
	
	dec( si );
	dec( di );
	mov( si, csbi.srWindow.right );
	mov( di, csbi.srWindow.bottom );
	
	pop( ebx );					// Retrieve the size we saved.
	cmp( ax, bx );
	if( @ne ) then				// The size has changed if ax <> bx
	
		mov( ebx, ConsoleCharNbr );	// New console size.
		if( @a ) then
		
			// Current buffer is larger;  so redim Window first
			// and the buffer second.
			
			SetConsoleWindowInfo
			(
				csbi.srWindow,
				true,
				hStdOut
			);
			SetConsoleScreenBufferSize
			(
				csbi.dwSize,
				hStdOut
			);
		
		else

			// Current buffer is smaller;  so redim buffer first
			// and the Window second.
			
			SetConsoleScreenBufferSize
			(
				csbi.dwSize,
				hStdOut
			);
			SetConsoleWindowInfo
			(
				csbi.srWindow,
				true,
				hStdOut
			);
		
		endif;
		
	endif;
	
	// Update the csbi variable with the new console info:
	
	win32cons.info( csbi );
	
	push( ColorsCurrent );							// Set the output colors.
	call win32cons.setOutputAttr;
	
	CLS();

	
end RedimWindow;



/***************************************************************/
/*                                                             */
/* WinEdit - Sets up the console with default colors and size. */
/*                                                             */
/***************************************************************/

procedure WinEdit; @noframe; @nodisplay;
begin WinEdit;

	mov( EditColors, eax );
	mov( eax, ColorsCurrent );
	RedimWindow( EditSizeX, EditSizeY );

end WinEdit;


/***********************************************************/
/*                                                         */
/* CLS- Clears the screen.	                               */
/*                                                         */
/* WARNING!  Code above falls through to this procedure.   */
/* Do not insert code between these two procedures, do not */
/* move either of these procedures!                        */
/*                                                         */
/***********************************************************/

	
procedure CLS; @noframe; @nodisplay;
begin CLS;

	FillConsoleOutputAttribute
	( 
		dtemp1,
		win.COORD:[0,0],
		ConsoleCharNbr, 
		(type word ColorsCurrent), 
		hStdOut 
	);
	FillConsoleOutputCharacter
	(
		dtemp1,
		win.COORD:[0,0],
		ConsoleCharNbr,
		' ',
		hStdOut
	);
	win32cons.gotoxy( 0, 0 );
	win32cons.setTitle( WinTitle );
	ret();
	
end CLS;



/********************************************************/
/*                                                      */
/* InitP initialize FOR..NEXT and GOSUB stack pointers  */
/*                                                      */
/********************************************************/

procedure InitP; @nodisplay; @noframe;
begin InitP;

	mov( &GosubStack, GosubStackPtr );
	mov( &ForStack, ForStackPtr );
	ret();
	
end InitP;




/***************************************************************/
/*                                                             */
/* FindLine-                                                   */
/*                                                             */
/* Looks for a same line number as LineNum in Basic text       */
/* StartTxt is used as text pointer.                           */
/*                                                             */
/* Returns a pointer in EDX that is the address of the         */
/* matching line or the line with the smallest line number     */
/* greater than LineNum, or just beyond the end of the program */
/* if LineNum is greater than all line numbers in the program. */
/*                                                             */
/* Returns TRUE in AL if it finds the line, false otherwise.   */
/*                                                             */
/* Obliterates value in EBX.                                   */
/*                                                             */
/***************************************************************/





procedure FindLine
( 
	StmtPtr:dword in edx; 
	LineNumber:uns16 in bx 
); 
	@nodisplay;
	@noframe;
	@returns( "al" );
	
begin FindLine;

	// Zero out EAX so we don't have to zero extend
	// the return result or the line size in this function.
	
	xor( eax, eax );
	
	forever
	

		if( edx < TxtEnd ) then
		
			cmp( (type StmtRec [edx]).lineNum, bx );
			if( @b ) then
			
				// We've haven't reached the line number we're
				// searching for.  So move on to the next
				// line and try again.
				
				mov( (type StmtRec [edx]).size, al );
				add( eax, edx );
				continue;
				
			endif;
		
			// Either we've found the desired line, or we've found
			// the first line whose line number is greater than
			// the desired value.  In either case, return.
			// Function result (true/false) depends on whether
			// we found the exact line we were searching for.
			
			sete( al );
			ret();
			
			
		
		else // We've reached the end of the source file.  Return failure.
		
			xor( eax, eax );  // Return false in EAX.
			ret();
		
		endif;
		
		// Note: should never get to this point.
		
	endfor;
	
	// Should never get to this point, either.

end FindLine;

/*****************************************************************/
/*                                                               */
/* Compile-                                                      */
/*                                                               */
/* This procedure makes a quick pass over the source file and    */
/* computes the address of all the statement labels in the file. */
/* This allows transfer of control instructions to run much more */
/* quickly since the interpreter won't have to search for each   */
/* label during interpretation.                                  */
/*                                                               */
/* This code also fills in addresses for the statements          */
/* that have context-free productions associated with            */
/* them (e.g., FOR..NEXT).                                       */
/*                                                               */
/*****************************************************************/




procedure Compile; @nodisplay; @noframe;

	procedure CompileCFG; @nodisplay;
	var
		VarPtr:		dword;
		StmtPtr:	dword;
		
	begin CompileCFG;
	
		// Note: to simplify parsing, we require all
		// CFG-type statements to start at the beginning
		// of the line.  This includes the following
		// statements:
		//
		//	for..next
		//  if..endif
		
		
		// Get the first token on this line:
		
		mov( (type StmtRec [ebx]).stmt, al );
		
		// Caller is responsible for handling the
		// following reserved words:
		//
		//	NEXT
		//	ELSE
		//	ENDIF
		
		if( al = NEXTtkn ) then
		
			// Note: NEXT without an ID does not end
			// the current FOR loop.  So check for an
			// ID token immediately after the NEXTtkn
			// before returning.
			
			cmp( (type StmtRec [ebx]).stmt[1], IDtkn );
			je RtnToCaller;
				
		else
		
			cmp( al, ELSEtkn );
			je RtnToCaller;
			cmp( al, ENDIFtkn );
			je RtnToCaller;
			
		endif;
		
		// Look for reserved words that begin a context-free
		// production.  These include the following:
		//
		//	FOR
		
		if( al = FORtkn ) then
		
			// Save a pointer to this statement, save a pointer
			// the the variable's hash table entry, and then process 
			// the statements between the FOR and NEXT clauses:
			
			mov( ebx, StmtPtr );
			mov( [ebx+9], eax );
			mov( eax, VarPtr );
			
			// Move on to the next statement (NEXT <id> clause must
			// always appear at the beginning of a line).
			
			xor( eax, eax );
			mov( (type StmtRec [ebx]).size, al );
			add( eax, ebx );
			
			
			// Process the statements between the FOR and NEXT clauses:
			
			forever
			
				
				// Bail with an error if we hit the end of the source
				// file without finding the corresponding NEXT clause:
				
				if( ebx >= TxtEnd ) then
				
					mov( VarPtr, eax );
					stdout.put
					(
						nl
						"FOR w/o corresponding NEXT statement"
						nl
						"(control variable is '",
						(type tableNode [eax]).id,
						"')"
					);
					mov( StmtPtr, ebx );
					AtLineNumber();
					raise( BasicError );
				
				endif;
				
				// Check for a NEXT.  Exit the loop if we find one.
				
				if( (type StmtRec [ebx]).stmt = NEXTtkn ) then
				
					breakif( (type StmtRec [ebx]).stmt[1] = IDtkn );
					
				endif;
				
				// If not NEXT, recursively call CompileCFG to handle
				// nested FOR..NEXT loops:
				
				CompileCFG();
				
			endfor;
			
			// We arrive at this point when we find the NEXT that matches
			// the FOR we saw earlier.  Verify that the IDs in the FOR and 
			// NEXT statements are the same:
			
			mov( [ebx+6], eax );
			mov( VarPtr, edx );
			if( eax <> edx ) then
			
				stdout.put
				(
					"NEXT identifier ('",
					(type tableNode [eax]).id,
					"') is not the same as the"
					nl
					"corresponding FOR identifier ('",
					(type tableNode [edx]).id,
					"')"
				);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			// Okay, patch the target address field of the
			// FOR statement so that it points at the NEXT clause.
			
			mov( StmtPtr, edx );
			mov( ebx, [edx+5] );
			 			
		elseif( al = IFtkn ) then
		
			// Save a pointer to this statement and then process 
			// the statements between the IF and ELSE or ENDIF clauses:
			
			mov( ebx, StmtPtr );
			
			// Move on to the next statement (ELSE/ENDIF clause must
			// always appear at the beginning of a line).
			
			xor( eax, eax );
			mov( (type StmtRec [ebx]).size, al );
			add( eax, ebx );
			
			
			// Process the statements between the IF and ELSE/ENDIF clauses:
			
			forever
			
				
				// Bail with an error if we hit the end of the source
				// file without finding the corresponding ENDIF clause:
				
				if( ebx >= TxtEnd ) then
				
					mov( VarPtr, eax );
					stdout.put
					(
						nl
						"IF w/o corresponding ENDIF statement"
						nl
					);
					mov( StmtPtr, ebx );
					AtLineNumber();
					raise( BasicError );
				
				endif;
				
				// If we come across an ELSE, patch the IF statement's
				// target field so that it points at the ELSE and then
				// set the ELSE as the current statement.
				//
				// Minor bug: if there is no corresponding ENDIF in the
				// file, this code will report the error on the ELSE
				// clause rather than the IF statement, but this isn't
				// completely non-intuitive.
				
				mov( (type StmtRec [ebx]).stmt, al );
				if( al = ELSEtkn ) then
				
					mov( StmtPtr, edx );	// Patch IF.
					mov( ebx, [edx+5] );
					mov( ebx, StmtPtr );	// Make ELSE the new statement.
					
					// Skip the statement with the ELSE clause:
					
					xor( eax, eax );
					mov( (type StmtRec [ebx]).size, al );
					add( eax, ebx );
				
				endif;
				
				// Check for an ENDIF.
				
				breakif( al = ENDIFtkn );
				
				// If not ENDIF, recursively call CompileCFG to handle
				// nested statements:
				
				CompileCFG();
				
			endfor;
			
			// We arrive at this point when we find the ENDIF that matches
			// the IF we saw earlier. Now we must patch the target address 
			// field of the IF or ELSE we processed earlier so tht it
			// points at the ENDIF clause
			
			mov( StmtPtr, edx );
			mov( ebx, [edx+5] );
			 			
		endif;
		
		// Move on to the next statement:
		
		xor( eax, eax );
		mov( (type StmtRec [ebx]).size, al );
		add( eax, ebx );
		
	RtnToCaller:
	
		mov( (type StmtRec [ebx]).stmt, al );
		
	end CompileCFG;
	
	
	
	
	
begin Compile;

	// Phase one- Go through the hash table and set the label
	// address fields of each Label_c entry to NULL
	
	foreach Vars.item() do
	
		mov( (type tableNode [eax]).Value, ebx );
		if( ebx = NULL ) then
		
			mov( eax, ebx );
			malloc( @size( Variant ));
			mov( eax, (type tableNode [ebx]).Value );
			mov( eax, ebx );
			mov( Undefined_c, (type Variant [ebx]).DataType );
			
		elseif( (type Variant [ebx]).DataType = Label_c ) then
		
			mov( 0, (type Variant [ebx]).l );
			
		endif; 
	
	endfor;
	 
	// Okay, do phase two (compute the address of all the labels).
	
	mov( TxtStart, ebx );
	while( ebx < TxtEnd ) do

		// Grab the first token and see if it's a label token

		if( (type byte [ebx+4]) = Labeltkn ) then
		
			// Okay, we've got a label.  The next four bytes
			// provide the address of this label's entry in
			// the hash table.  Grab that and update the address
			// field with the address of this statement.

			mov( [ebx+5], esi );
			mov( (type tableNode [esi]).Value, edi );
			mov( ebx, (type Variant [edi]).l );		// label field.
			
		endif;
		
		// Move on to the next statement in the file:
		
		movzx( (type StmtRec [ebx]).size, eax );
		add( eax, ebx );
		
		
	endwhile;
	
	// Third phase - process the statements that have context-free
	// productions associated with them (fill in the addresses that
	// point at their "end" statements).
	
	mov( TxtStart, ebx );
	while( ebx <> TxtEnd ) do
	
		CompileCFG();
		if( al = NEXTtkn ) then
		
			if( (type StmtRec [ebx]).stmt[1] = IDtkn ) then
			
				stdout.put( "NEXT w/o corresponding FOR" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
		endif;
		if( al = ELSEtkn ) then
		
			stdout.put( "ELSE w/o corresponding IF" );
			AtLineNumber();
			raise( BasicError );
			
		endif;
		if( al = ENDIFtkn ) then
		
			stdout.put( "ENDIF w/o corresponding IF" );
			AtLineNumber();
			raise( BasicError );
			
		endif;
		
		
	endwhile;
	ret();
	
end Compile;


/******************************************************************/
/*                                                                */
/* DoDebug-                                                       */
/*                                                                */
/* This procedure gets called whenever the interpreter begins the */
/* execution of a new line of statements and DEBUG (trace) mode   */
/* is active.                                                     */
/*                                                                */
/******************************************************************/

procedure DoDebug( lineNumber:uns16 in ax ); @nodisplay; @noframe;
begin DoDebug;

	stdout.put( '#', (type uns16 ax), nl );
	ret();
	
end DoDebug;


/***************************************************************/
/*                                                             */
/* RealToStr-                                                  */
/*                                                             */
/* Generic Real64 to String conversion routine.                */
/* If number is in the range 0.01 .. 1e10, then this           */
/* function converts it to the decimal representation with     */
/* two positions to the right of the decimal point.            */
/* If the number is outside this range, then this routine      */
/* converts it to exponential form.                            */
/*                                                             */
/* This routine allocates storage for the string on the heap.  */
/* It is the caller's responsibility to free this storage when */
/* the caller is through with the string.                      */
/*                                                             */
/***************************************************************/

procedure RealToStr( r:real64 ); @nodisplay; @returns( "eax" );
begin RealToStr;

	fld( 0.01 );
	fld( r );
	fcompp();
	fstsw( ax );
	sahf();
	jb Exponential;
	
	fld( 1.0e10 );
	fld( r );
	fcompp();
	fstsw( ax );
	sahf();
	ja Exponential;

	stralloc( 16 );
	conv.r64ToStr( r, 14, 2, ' ', eax );
	str.trim( eax );
	exit RealToStr;
	
  Exponential:
  	stralloc( 24 );
	conv.e64ToStr( r, 20, eax );

end RealToStr;






/*********************************************************/
/*                                                       */
/* StrToNumber-                                          */
/*                                                       */
/* The top of the evaluation stack contains a string.    */
/* Attempt to convert this string to the integer or real */
/* value that it represents.  If successful, return the  */
/* converted value in the TOS element.  If unsuccessful, */
/* raise an appropriate exception.                       */
/*                                                       */
/* Input-                                                */
/*                                                       */
/* 	ESI points at the ExprStack element just above       */
/* 	the TOS.                                             */
/* 	                                                     */
/* Must preserve EBX, ECX, and ESI.                      */
/*														 */
/* Returns new TOS data type in AL.						 */
/*                                                       */
/*********************************************************/



procedure StrToNumber( ExprSP:dword in esi ); @noframe; @nodisplay;
begin StrToNumber;

	// Okay, now try converting it to an integer:
	
  	push( esi );		// Must save in case there's an exception.
	push( ecx );
	push( ebx );
	try
	
		conv.strToi32( (type Variant [esi-@size( Variant )]).s, 0 );
		
		// If success, return an integer value:
		
		strfree( (type Variant [esi-@size( Variant )]).s );
		mov( eax, (type Variant [esi-@size( Variant )]).i );
		mov( Integer_c, al );
		mov( al, (type Variant [esi-@size( Variant )]).DataType );
		
	  unprotected
	  
	  	pop( ebx );
		pop( ecx );
		pop( esi );
		ret();
		
	  anyexception
	  
	  	if( eax <> ex.ConversionError ) then
		
			stdout.put( nl "Exception" );
			mov( [esp], ebx );
			AtLineNumber();
			raise( eax );
			
		endif;
		
	endtry;
	mov( [esp], ebx );
	mov( [esp+4], ecx );
	mov( [esp+8], esi );

	// Okay, integer conversion failed.  See if it's a real value:
	
	try
	
		conv.strToFlt( (type Variant [esi-@size( Variant )]).s, 0 );
		
		// If success, return a real64 value:
		
		strfree( (type Variant [esi-@size( Variant )]).s );
		fstp( (type Variant [esi-@size( Variant )]).r );
		mov( Real_c, al );
		mov( al, (type Variant [esi-@size( Variant )]).DataType );
		
	  unprotected
	  
	  	pop( ebx );
		pop( ecx );
		pop( esi );
		ret();
		
	  anyexception
	  
		stdout.put( nl "Exception" );
		mov( [esp], ebx );
		AtLineNumber();
		raise( eax );
						
	endtry;
	
	// Shouldn't ever get here, but just in case:
	
	stdout.put( "Internal BASIC error (VAL)" nl );
	raise( BasicError );

end StrToNumber;



/*******************************************************************/
/*                                                                 */
/* NumberToStr-                                                    */
/*                                                                 */
/* The top of stack contains some object.                          */
/* Convert it to a string if it's an integer or a real value.      */
/* Note that real values always consume exactly 20 print positions */
/* (since we don't have the information to format the value).      */
/*                                                                 */
/* Input:                                                          */
/* 	ESI - points just above the ExprStack item on TOS.             */
/* 	                                                               */
/* Output-                                                         */
/* 	AL contains String_c and the TOS contains the                  */
/* 	string representation of the original TOS.                     */
/* 	                                                               */
/* Note: This code leaves string operands untouched and            */
/* raises an exception for non-string/numeric data types.          */
/* 	                                                               */
/*******************************************************************/


procedure NumberToStr( EvalStack:dword in esi ); @nodisplay; @noframe;
begin NumberToStr;

	mov( (type Variant [esi-@size(Variant)]).DataType, al );
	if( al <> String_c ) then
	
		if( al = Integer_c ) then
		
			// Convert integer value to a string:
			
			stralloc( 24 );
			conv.i32ToStr
			(
				(type Variant [esi-@size(Variant)]).i,
				0,
				' ',
				eax
			);
			
		elseif( al = Real_c ) then
		
			// Convert the real value to a string:
			
			conv.e64ToStr
			(
				(type Variant [esi-@size(Variant)]).r,
				20,
				eax
			);
			
		elseif( al <> String_c ) then
		
							
			stdout.put( nl "Illegal parameter data type in LEN function" );
			AtLineNumber();
			raise( BasicError );
							
		endif;
		mov( eax, (type Variant [esi-@size(Variant)]).s );
		mov( String_c, al );
		mov( al, (type Variant [esi-@size(Variant)]).DataType );
		
	endif;
	ret();


end NumberToStr;




/*************************************************************/
/*                                                           */
/* MakeInt-                                                  */
/*                                                           */
/* Many calls to EvalExpr require an integer result.         */
/* This function attempts to convert the result returned     */
/* by EvalExpr to an integer.  If not possible, this code    */
/* aborts the program with an error.  If possible, this code */
/* returns the value in the EAX register.                    */
/*                                                           */
/* Returns: Integer_c in AL.                                 */
/*                                                           */
/*************************************************************/


procedure MakeInt( CurType:vTypes in al; msg:string ); 
	@nodisplay; 
	@returns( "eax" ); 
	
begin MakeInt;

	if( al = String_c ) then
	
		lea( esi, ExprStack[ @size( Variant ) ]); 
		StrToNumber( esi );
		
	endif;
	if( al = Real_c ) then
	
		// Convert real value to integer via truncation:
		
		fld( ExprStack.r );
		
		sub( 4, esp );				// Space for ctrl word.
		fstcw( (type word [esp]) );	// Get FPU ctrl word.
		
		// Bits 10 & 11 control the FPU rounding mode.
		// %11 means "truncate".
		
		mov( [esp], ax );
		or( %0110_0000_0000, ax );	
		mov( ax, [esp] );
		fldcw( (type word [esp]) );
		
		// Convert to a truncated integer:
		
		fistp( ExprStack.i );
		
		// Restore rounding mode to "round to nearest even".
		
		and( %1111_1001_1111_1111, ax );
		mov( ax, [esp] );
		fldcw( (type word [esp]) );
		add( 4, esp );
		
		
	elseif( al <> Integer_c ) then
	
		stdout.put( nl, msg );
		AtLineNumber();
		raise( BasicError );
						
	endif;
	mov( ExprStack.i, eax );


end MakeInt;


/**********************************************************************/
/* Expr-                                                              */
/*                                                                    */
/* Expression evaluator.                                              */
/*                                                                    */
/* Here's the grammar for hlaBASIC expressions:                       */
/*                                                                    */
/* 	expr-> ORx { relop ORx }*                                         */
/* 	relop -> < | <= | = | <> | >= | >                                 */
/* 	                                                                  */
/* 	ORx -> ANDx { or ANDx }*                                          */
/* 	                                                                  */
/* 	ANDx -> ADDx { and ADDx }*                                        */
/* 	                                                                  */
/* 	ADDx -> MULx { addop MULx }*                                      */
/* 	addop -> + | -                                                    */
/* 	                                                                  */
/* 	MULx -> Factor { mulop Factor }*                                  */
/* 	mulop -> * | / | %                                                */
/* 	                                                                  */
/* 	Factor ->	not Factor                                            */
/* 			|	- Factor                                              */
/* 			|	FuncID ( exprList )                                   */
/* 			|	ID [ expr ]                                           */
/* 			|	ID                                                    */
/* 			|	strConst                                              */
/* 			|	intConst                                              */
/* 			|	realConst                                             */
/* 			|	( expr )                                              */
/* 			                                                          */
/* 	FuncID ->                                                         */
/* 			|	ASC                                                   */
/* 			|	CHR                                                   */
/* 			|	STR                                                   */
/* 			|	VAL                                                   */
/* 			|	SIN                                                   */
/* 			|	COS                                                   */
/* 			|	TAN                                                   */
/* 			|	ASIN                                                  */
/* 			|	ACOS                                                  */
/* 			|	ATAN                                                  */
/* 			|	LOG                                                   */
/* 			|	EXP                                                   */
/* 			|	SQRT                                                  */
/* 			|	LEN                                                   */
/* 			|	LEFT                                                  */
/* 			|	MID                                                   */
/* 			|	RIGHT                                                 */
/* 	 		                                                          */
/* 			                                                          */
/* 	exprList -> expr { , expr }*                                      */
/* 	                                                                  */
/*                                                                    */
/* Each Non-terminal in this grammar has a "Variant" attribute        */
/* associated with it (that holds the value associated with           */
/* that non-terminal).  Mixed type expressions are legal and          */
/* subject to the following semantics:                                */
/*                                                                    */
/* note: r=real, i=integer, s=string                                  */
/*                                                                    */
/* i op i- produces i                                                 */
/*                                                                    */
/* r op r-	produces r                                                */
/*                                                                    */
/* s op s- returns s.                                                 */
/*                                                                    */
/* i op r-	promotes the integer to a real and then                   */
/* r op i	returns a real result (r op r semantics).                 */
/*                                                                    */
/* i op s- attempts to convert string to an integer,                  */
/* s op i	if successful, then does i op i.  If unsuccessful,        */
/* 		attempts to convert s to real.  If successful,                */
/* 		then computes i op r or r op i.  If unsuccessful,             */
/* 		then raises an exception.                                     */            
/* 		                                                              */
/* r op s-	Attempts to convert s to a real.  If successful,          */
/* s op r	computes r op r.  If unsuccessful, raises an exception.   */                                
/* 		                                                              */
/* Notes:                                                             */
/*                                                                    */
/* If i, r, or s is an array ID, then the code defaults               */
/* to the first element (i[0], r[0], or s[0]).                        */
/*                                                                    */
/* If i, r, or s is an ID and the value is undefined,                 */
/* the system raises an exception.                                    */
/*                                                                    */
/* Each of the following expression evaluation functions update       */
/* ECX to point at the next available token in the source.            */
/*                                                                    */
/* They also leave their result on the expression evaluation stack.   */
/* The call to EvalExpr should leave a single value at location       */
/* "ExprStack[0]" containing the result of the expression.            */
/*                                                                    */
/* This functions return the type of the expression in AL.            */
/* This is one of the following:                                      */
/*                                                                    */
/* 	Integer_c,                                                        */
/* 	Real_c                                                            */
/* 	String_c                                                          */
/*                                                                    */
/**********************************************************************/


/*
** This code is ugly and needs to be replaced.
**
**	A recursive descent parse is not the right way to do this.
**	A slightly better solution would be to use a operator-precedence
**	parser.
**
**	A much better solution would be to change the tokenizer (which is
**	not time critical) to emit postfix (RPN) code and have the expression
**	evaluator simply process this postfix notation.  That conversion, alas,
**	must wait for a future version.
*/	
	
procedure EvalExpr( ip:dword in ecx ); @nodisplay; @noframe; @returns( "al" );

	procedure ORx( ip:dword in ecx; ExprStackPtr:dword in esi ); forward;

	////////////////////////////////////////////////////////////////////
	//
	// MakeCompatible-
	//
	//	ESI points just above two Variant items on the evaluation
	// stack.  This function coerces and converts those values so
	// that they have the same type (this function raises an
	// appropriate exception if conversion is not possible).
	
		
	procedure MakeCompatible
	( 
		ExprStackPtr:dword in esi 
	); 
		@nodisplay; 
		@noframe;
		@returns( "al" );
		
	begin MakeCompatible;
	
		// If the two types are equal (the most common case), then
		// get out of here as quickly as possible.
		
		mov( (type Variant [esi - @size( Variant )*2]).DataType, al );
		mov( (type Variant [esi - @size( Variant )]).DataType, ah );
		if( al = ah ) then
		
			ret();
			
		endif;
		
		// Okay, the types are not equal.  Let's coerce them as best
		// we can (see the semantic rules above ).
		//
		// Handle i op r here:
		
		if
		(#{
			cmp( al, Integer_c );
			jne false;
			cmp( ah, Real_c );
			jne false;
		}#) then
		
			fild( (type Variant [esi - @size( Variant )*2]).i );
			fstp( (type Variant [esi - @size( Variant )*2]).r );
			mov( Real_c, al );
			mov( al, (type Variant [esi - @size( Variant )*2]).DataType );
			ret();
			
		endif;
		
		// Handle r op i here:
		
		if
		(#{
			cmp( al, Real_c );
			jne false;
			cmp( ah, Integer_c );
			jne false;
		}#) then
		
			fild( (type Variant [esi - @size( Variant )]).i );
			fstp( (type Variant [esi - @size( Variant )]).r );
			mov( Real_c, al );
			mov( al, (type Variant [esi - @size( Variant )]).DataType );
			ret();
			
		endif;
		
		
		// Handle i op s here:
		
		if
		(#{
			cmp( al, Integer_c );
			jne false;
			cmp( ah, String_c );
			jne false;
		}#) then
		
			// First, try to convert the string to an integer:
			
			push( esi );	// Note: exceptions leave registers undefined!
			push( ecx );
			push( ebx );
			try
			
				conv.strToi32
				(
					(type Variant [esi - @size( Variant )]).s,
					0
				);
				
				
				// If successful, then convert the string to an integer:
				
				push( eax );
				strfree( (type Variant [esi - @size( Variant )]).s );
				pop( eax );
				mov( eax, (type Variant [esi - @size( Variant )]).i );
				mov( Integer_c, al );
				mov( al, (type Variant [esi - @size( Variant )]).DataType );
				
		      unprotected
			  	pop( ebx );
			  	pop( ecx );
				pop( esi );
			  	ret();
				
			  anyexception
			  
			  	if( eax <> ex.ConversionError ) then
				
					stdout.put( nl "Exception" nl );
					mov( [esp], ebx );
					AtLineNumber();
					raise( eax );
					
				endif;
				
			endtry;
			mov( [esp], ebx );
			mov( [esp+4], ecx );
			mov( [esp+8], esi );

			  
		  	// Okay, it wasn't a valid integer.  Let's see if it
			// is a real value:
			
			try
			
				conv.strToFlt
				(
					(type Variant [esi - @size( Variant )]).s,
					0
				);
				
				// If successful, then convert the string to a real
				// and the integer operand to a real:
				
				strfree( (type Variant [esi - @size( Variant )]).s );
				fstp( (type Variant [esi - @size( Variant )]).r );
				mov
				( 
					Real_c, 
					(type Variant [esi - @size( Variant )]).DataType 
				);
			
				fild( (type Variant [esi - @size( Variant )*2]).i );
				fstp( (type Variant [esi - @size( Variant )*2]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi - @size( Variant )*2]).DataType );
				
			  unprotected
			  
			  	pop( ebx );
			  	pop( ecx );
				pop( esi );
				ret();

			  anyexception
			  
			  	if( eax <> ex.ConversionError ) then
				
					stdout.put( nl "Exception" nl );
					mov( [esp], ebx );
					AtLineNumber();
					raise( eax );
					
				endif;
				
			endtry;
			pop( ebx );

			// If we couldn't convert the string to an integer or real
			// value, then raise an exception.
			
			stdout.put( nl "Type mismatch in expression (int op str)" );
			AtLineNumber();
			raise( BasicError );
			
		endif;
		
		
		// Handle s op i here:
		
		if
		(#{
			cmp( al, String_c );
			jne false;
			cmp( ah, Integer_c );
			jne false;
		}#) then
		
			// First, try to convert the string to an integer:
			
			push( esi );	// Exceptions scramble the registers!
			push( ecx );
			push( ebx );
			try
			
				conv.strToi32
				(
					(type Variant [esi - @size( Variant )*2]).s,
					0
				);
				
				// If successful, then convert the string to an integer:
				
				push( eax );
				strfree( (type Variant [esi - @size( Variant )*2]).s );
				pop( eax );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				mov( Integer_c, al );
				mov( al, (type Variant [esi - @size( Variant )*2]).DataType );
				
			  unprotected
			  	pop( ebx );
			  	pop( ecx );
				pop( esi );
			  	ret();

			  anyexception
			  
			  	if( eax <> ex.ConversionError ) then
				
					stdout.put( nl "Exception" nl );
					mov( [esp], ebx );
					AtLineNumber();
					raise( eax );
					
				endif;
				
			endtry;
			mov( [esp], ebx );
			mov( [esp+4], ecx );
			mov( [esp+8], esi );
			
				
		  	// Okay, it wasn't a valid integer.  Let's see if it
			// is a real value:
			
			try
			
				conv.strToFlt
				(
					(type Variant [esi - @size( Variant )*2]).s,
					0
				);
				
				// If successful, then convert the string to a real
				// and the integer operand to a real:
				
				strfree( (type Variant [esi - @size( Variant )*2]).s );
				fstp( (type Variant [esi - @size( Variant )*2]).r );
				mov
				( 
					Real_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
			
				fild( (type Variant [esi - @size( Variant )]).i );
				fstp( (type Variant [esi - @size( Variant )]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi - @size( Variant )]).DataType );
			  
			  unprotected
			  	pop( ebx );
			  	pop( ecx );
				pop( esi );
				ret();
				
			  anyexception
			  
			  	if( eax <> ex.ConversionError ) then
				
					stdout.put( nl "Exception" nl );
					mov( [esp], ebx );
					AtLineNumber();
					raise( eax );
					
				endif;
				
			endtry;
			pop( ebx );
			  
		  	// Well, if it wasn't an integer and it wasn't a real,
			// raise an exception.
			
			stdout.put( nl "Type mismatch in expression (str op int)" );
			AtLineNumber();
			raise( BasicError );
			
		endif;
		
		
		
		
		// Handle r op s here:
		
		if
		(#{
			cmp( al, Real_c );
			jne false;
			cmp( ah, String_c );
			jne false;
		}#) then
		
			// First, try to convert the string to a real:
			
			push( esi );	// If an exception occurs, it will mess up
			push( ecx );	// the registers!
			push( ebx );
			try
			
				conv.strToFlt
				(
					(type Variant [esi - @size( Variant )]).s,
					0
				);
				
				// If successful, then convert the string to a real64:
				
				strfree( (type Variant [esi - @size( Variant )]).s );
				fstp( (type Variant [esi - @size( Variant )]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi - @size( Variant )]).DataType );
			  
			  unprotected
			  	pop( ebx );
			  	pop( ecx );
				pop( esi );
			  	ret();
				
			  anyexception
			  
			  	if( eax <> ex.ConversionError ) then
				
					stdout.put( nl "Exception" nl );
					mov( [esp], ebx );
					AtLineNumber();
					raise( eax );
					
				endif;
				
			endtry;
			mov( [esp], ebx );
			mov( [esp+4], ecx );
			mov( [esp+8], esi );
			  
		  	// Okay, it wasn't a valid real value.  Raise an exception.
			
			stdout.put( nl "Type mismatch in expression (real op str)" );
			AtLineNumber();
			raise( BasicError );
					
		endif;
		
		
		// Handle s op r here:
		
		if
		(#{
			cmp( al, String_c );
			jne false;
			cmp( ah, Real_c );
			jne false;
		}#) then
		
			// First, try to convert the string to an integer:
			
			push( esi );	// Exceptions mess up the registers!
			push( ecx );
			push( ebx );
			try
			
				conv.strToFlt
				(
					(type Variant [esi - @size( Variant )*2]).s,
					0
				);
				
				// If successful, then convert the string to a real64:
				
				strfree( (type Variant [esi - @size( Variant )*2]).s );
				fstp( (type Variant [esi - @size( Variant )*2]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi - @size( Variant )*2]).DataType );
				
			  unprotected
			    pop( ebx );
			  	pop( ecx );
				pop( esi );
			  	ret();
				
			  anyexception
			  
			  	if( eax <> ex.ConversionError ) then
				
					stdout.put( nl "Exception" nl );
					mov( [esp], ebx );
					AtLineNumber();
					raise( eax );
					
				endif;
				
			endtry;
			pop( ebx );
			  
		  	// Okay, it wasn't a valid real value.  Raise an exception:
			
			stdout.put( nl "Type mismatch in expression (str op real)" );
			AtLineNumber();
			raise( BasicError );
					
		endif;
		
	end MakeCompatible;
	
	
	
	/////////////////////////////////////////////////////////////////////////
	//
	// Factor-
	// 
	// Handles IDs, constants, parenthetical expressions, functions, and the 
	// unary operators.
	
	
	
	procedure Factor
	( 
		ip:dword in ecx; 
		ExprStackPtr:dword in esi 
	);
		@noframe;
		@nodisplay;
		@returns( "al" );
		
	begin Factor;

	  ZeroOrMoreFactors:
	  
	  	xor( eax, eax );
		mov( (type ReservedWords [ecx]), al );
		switch( eax )
		
		  case( INTtkn )
		
			mov( [ecx+1], eax );
			mov( eax, (type Variant [esi]).i );
			mov( Integer_c, al );
			mov( al, (type Variant [esi]).DataType );
			add( @size( Variant ), esi );
			add( 5, ecx );
			ret();
			
		  case( FLTtkn )
		
			mov( [ecx+1], eax );
			mov( eax, (type dword (type Variant [esi]).r) );
			mov( [ecx+5], eax );
			mov( eax, (type dword (type Variant [esi+4]).r) );
			mov( Real_c, al );
			mov( al, (type Variant [esi]).DataType );
			add( @size( Variant ), esi );
			
			// Okay, skip over the binary and string representations
			// of this real value:
			
			xor( edx, edx );
			add( 9, ecx );
			mov( [ecx], dl );
			stc();
			adc( edx, ecx );
			ret();
			
		 case( STRtkn )
		
			// Push a string object onto the evaluation stack:


			xor( edx, edx );
			inc( ecx );
			mov( [ecx], dl );
			mov( String_c, (type Variant [esi]).DataType );

			stralloc( edx );
			mov( eax, (type Variant [esi]).s );
			mov( edx, (type str.strRec [eax]).length );
			add( @size( Variant ), esi );
			
			// Copy the string data:

			push( ecx );
			push( esi );
			lea( esi, [ecx+1] );
			mov( eax, edi );
			mov( edx, ecx );
			cld();
			rep.movsb();
			mov( 0, (type byte [edi]));
			pop( esi );
			pop( ecx );
			
			// Okay, skip over the string in the source code:

			stc();
			adc( edx, ecx );

			mov( String_c, al );
			ret();
			
			
			
		  case( IDtkn )
		
			mov( [ecx+1], edi );	// Get ptr to ID's hash table entry.
			mov( (type tableNode [edi]).Value, edx );
			add( 5, ecx );			// Skip ID token bytes.
			if( edx = NULL ) then

				stdout.put( nl "Attempt to use uninitialized variable" );
				AtLineNumber();
				raise( BasicError );

			endif;
			while( (type Variant [edx]).DataType = Array_c ) do
			
				// Okay, we've got an array.  Let's verify that an appropriate
				// index follows this variable in the token stream.
				
				if( (type byte [ecx]) <> LBRACKtkn ) then
				
					stdout.put
					(
						nl 
						"Expected an array index on variable ",
						(type tableNode [edi]).id
					);
					AtLineNumber();
					raise( BasicError );
					
				endif;
				inc( ecx );
				push( edx );		// Save ptr to variable.
				ORx( ecx, esi );	// Get index expression.
				pop( edx );			// Restore pointer.

				// Deal with the index here:
				
				mov( (type Variant [esi-@size( Variant )]).DataType, al );
				if( al = String_c ) then
				
					StrToNumber( esi );
					
				endif;
				if( al <> Integer_c ) then
				
					stdout.put
					( 
						nl "Array index must be an integer expression" 
					);
					AtLineNumber();
					raise( BasicError );
					
				endif;
				
				// Now check the bounds of the array:
				
				mov( (type Variant [esi-@size( Variant )]).i, eax );
				

				sub( @size( Variant ), esi );	// Remove index from stack.
				if( eax >= (type Variant [edx]).a.elements ) then
				
					stdout.put
					(
						nl 
						"Array bounds violation for variable ",
						(type tableNode [edi]).id,
						nl
						"Index = ",
						(type uns32 eax),
						" must be less than ",
						(type Variant [edx]).a.elements,
						nl
					);
					AtLineNumber();
					raise( BasicError );
					
				endif;
				
				// Okay, now select the specied element:
				
				mov( (type Variant [edx]).a.array, edx );
				intmul( @size( Variant ), eax );
				lea( edx, [edx+eax] ); 

				// Skip over the ']' token.
				
				inc( ecx );			
		 
				
			endwhile;
			mov( (type Variant [edx]).DataType, al ); 
			if( al = Integer_c ) then
			
				mov( al, (type Variant [esi]).DataType );
				mov( (type Variant [edx]).i, edx );
				mov( edx, (type Variant [esi]).i );
				add( @size( Variant ), esi );
				ret();
				
			endif;
			
			if( al = Real_c ) then
			
				mov( al, (type Variant [esi]).DataType );
				fld( (type Variant [edx]).r );
				fstp( (type Variant [esi]).r );
				add( @size( Variant ), esi );
				ret();
				
			endif;
			
			if( al = String_c ) then
			
				mov( al, (type Variant [esi]).DataType );
				str.a_cpy( (type Variant [edx]).s );
				mov( eax, (type Variant [esi]).s );
				add( @size( Variant ), esi );
				mov( String_c, al );
				ret();
				
			endif;
			
			if( al = Undefined_c ) then
			
				stdout.put( nl "Attempt to use uninitialized variable" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			stdout.put( nl "Unsupported variable type in expression" );
			AtLineNumber();
			raise( BasicError );
						
			
		  case( LBRACKtkn )
		  
		  	stdout.put( nl "Unexpected array index" );
			AtLineNumber();
			raise( BasicError );
			
			
		  case( LPARENtkn )
		
			inc( ecx );
			ORx( ecx, esi );
			inc( ecx );			// Skip RPARENtkn
			ret();
			
			
		  // Handle the unary operators down here:
		
		  case( MINUStkn )
		  
		  	inc( ecx );			// Skip the '-'
			Factor( ecx, esi );	// Grab the following expression.
			
			if( al = Integer_c ) then
			
				neg( (type Variant [esi-@size(Variant)]).i );
				ret();
				
			elseif( al = Real_c ) then
			
				fld( (type Variant [esi-@size(Variant)]).r );
				fchs();
				fstp( (type Variant [esi-@size(Variant)]).r );
				ret();
				
			else
			
				stdout.put(	nl "Type mismatch error in expression"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
		  
		  case( NOTtkn )
		  
		  	inc( ecx );			// Skip the 'NOT'
			Factor( ecx, esi );	// Grab the following expression.
			
			if( al = Integer_c ) then
			
				xor( edx, edx );
				cmp( (type Variant [esi-@size(Variant)]).i, 0 );
				sete( dl );
				mov( edx, (type Variant [esi-@size(Variant)]).i ); 
				ret();
				
			else
			
				stdout.put( nl "Type mismatch error in expression" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
		  
		  
		  ////////////////////////////////////////////////////////////////////
		  //
		  // Handle the built-in functions down here:
		  //
		  ////////////////////////////////////////////////////////////////////

			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // ACOS- computes the arc cosine of the angle supplied in radians.
		  
		  case( ACOSftkn )
		  
		  	add( 2, ecx );		// Skip the ACOS and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in ACOS function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in ACOS function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the trignometric arc cosine and return:
			
			math.acos( (type Variant [esi-@size(Variant)]).r );
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // ASC function returns the ASCII code of the first
		  // character of its string parameter (zero if the
		  // string is empty).
		  
		  case( ASCftkn )
		  
		  	add( 2, ecx );		// Skip the ASC and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in ASC function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			if( al <> String_c ) then
			
				stdout.put( nl "Expected a string expression in ASC call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx ); 		// Skip the ')'.
			xor( edx, edx );
			mov( (type Variant [esi-@size(Variant)]).s, eax );
			mov( [eax], dl );	// Get character code for first character.
			strfree( eax );
			mov( edx, (type Variant [esi-@size(Variant)]).i );
			mov( Integer_c, al );
			mov( al, (type Variant [esi-@size(Variant)]).DataType );
			ret();
			
		  
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // ASIN- computes the arc sine of the angle supplied in radians.
		  
		  case( ASINftkn )
		  
		  	add( 2, ecx );		// Skip the ASIN and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in ASIN function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in ASIN function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the trignometric arc sine and return:
			
			math.asin( (type Variant [esi-@size(Variant)]).r );
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
		  
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // ATAN- computes the arc tangent of the angle supplied in radians.
		  
		  case( ATANftkn )
		  
		  	add( 2, ecx );		// Skip the ATAN and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in ATAN function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in ATAN function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the trignometric arc sine and return:
			
			fld( (type Variant [esi-@size(Variant)]).r );
			fld1();
			fpatan();
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
		  
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // CHR- converts the single integer parameter into a single
		  // character string whose character has the specified ASCII code.
		  
		  case( CHRftkn )
		  
		  	add( 2, ecx );		// Skip the CHR and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in CHR function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			if( al <> Integer_c ) then
			
				stdout.put( nl "Expected an integer expression in CHR call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			stralloc( 2 );		// Allocate storage for the string
			
			// Build the one-character string using the integer as
			// the ASCII code:
			
			mov( (type Variant [esi-@size(Variant)]).i, edx );
			mov( eax,(type Variant [esi-@size(Variant)]).s ); 
			mov( dl, [eax] );
			mov( 1, (type str.strRec [eax]).length );
			
			mov( String_c, al );
			mov( al, (type Variant [esi-@size(Variant)]).DataType );
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // COS- computes the sine of the angle supplied in radians.
		  
		  case( COSftkn )
		  
		  	add( 2, ecx );		// Skip the COS and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in COS function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in COS function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the trignometric cosine and return:
			
			fld( (type Variant [esi-@size(Variant)]).r );
			fcos();
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // DIM- Creates an array of the specified size
		  
		  
		  case( DIMtkn )
		
			add( 2, ecx );		// Skip DIM and "(" tokens.
			
			// Make room for the array object return location on
			// the evaluation stack:
			
			add( @size( Variant ), esi );
			
			// Evaluate the expression that specifies the
			// size of the array:
			
			ORx( ecx, esi );
			
			
			// If the expression was a string expression, convert
			// it to a number (if possible).
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				mov
				(
					(type Variant [esi-@size(Variant)]).DataType,
					al 
				);
				
			endif;
			
			if( al <> Integer_c ) then
			
				stdout.put
				( 
					nl 
					"Dimension size must be an integer" 
				);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			// Get the pointer to the array object on the evaluation
			// stack so we can fill in the fields
			
			lea( edx, (type Variant [esi-@size(Variant)*2]) );
			mov( Array_c, (type Variant [edx]).DataType );
			
			// Get the number of elements:
			
			mov( (type Variant [esi-@size(Variant)]).i, eax );
			if( (type int32 eax ) not in 0..(MaxArraySize-1) ) then
			
				stdout.put
				( 
					nl
					"Dimension size must be greater than zero "
					nl
					"and less than ", MaxArraySize 
				);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			mov( eax, (type Variant [edx]).a.elements );
			mov( eax, edi );
			
			// Compute the number of bytes we will need and
			// allocate storage for the array.
			
			intmul( @size( Variant ), eax ); 
			malloc( eax );
			mov( eax, (type Variant [edx]).a.array );
			
			// Step through the array and set each element to
			// "uninitialized".
			
			xor( edx, edx );
			repeat
			
				mov( Undefined_c, (type Variant [eax]).DataType );
				add( @size( Variant ), eax );
				dec( edi );
				
			until( @z );
			
			// Skip over the ')' token at the end:
			
			inc( ecx );
			
			// Remove the array index from the evaluation stack so
			// that we simply return the array object:
			
			sub( @size( Variant ), esi );
			ret();
			
		  
		  		  
		  ////////////////////////////////////////////////////////////////////
		  //
		  // EXP- computes e**x.
		  
		  case( EXPftkn )
		  
		  	add( 2, ecx );		// Skip EXP and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in EXP function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in EXP function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute e**x return:
			
			math.exp( (type Variant [esi-@size(Variant)]).r );
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // INT- Truncates a real expression.
		  
		  case( INTftkn )
		  
		  	add( 2, ecx );		// Skip INT and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in INT function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx );		// Skip the ")".
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Real_c ) then
			
				// Convert real value to integer via truncation:
				
				fld( (type Variant [esi-@size(Variant)]).r );
				
				sub( 4, esp );				// Space for ctrl word.
				fstcw( (type word [esp]) );	// Get FPU ctrl word.
				
				// Bits 10 & 11 control the FPU rounding mode.
				// %11 means "truncate".
				
				mov( [esp], ax );
				or( %0110_0000_0000, ax );	
				mov( ax, [esp] );
				fldcw( (type word [esp]) );
				
				// Convert to a truncated integer:
				
				fistp( (type Variant [esi-@size(Variant)]).i );
				
				// Restore rounding mode to "round to nearest even".
				
				and( %1111_1001_1111_1111, ax );
				mov( ax, [esp] );
				fldcw( (type word [esp]) );
				add( 4, esp );
				
				mov( Integer_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				ret();
				
			elseif( al <> Integer_c ) then
			
				stdout.put( nl "Illegal parameter data type in INT function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			ret();			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // LEFT- computes a substring based at position zero.
		  
		  case( LEFTftkn )
		  
		  	add( 2, ecx );		// Skip the LEFT and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> COMMAtkn ) then 
			
				stdout.put( nl "Too few parameters in LEFT function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx );			// Skip the "," token
			ORx( ecx, esi );	// Extract the second parameter.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in LEFT function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Second parameter must be an integer, verify this:
			
			if( al <> Integer_c ) then
			
				stdout.put( nl "Second LEFT parameter must be an integer" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			mov( (type Variant [esi-@size(Variant)]).i, edi );	// Save Length
			sub( @size(Variant), esi );							// Pop stack.
			
			// The first parameter should be a string.  If not, see if
			// we can convert it to a string.
			
			NumberToStr( esi );

			// Now take the zero-based substring, with the length
			// specified in EDI, of the string on the TOS.
			
			mov( (type Variant [esi-@size(Variant)]).s, edx );
			mov( (type str.strRec [edx]).length, eax );
			
			// If the user specified a length longer than the current
			// length of the string, then simply return the current
			// string.  If the string's length is greater than the
			// length specified by the second parameter, then do a
			// substring operation.
			
			if( eax > edi ) then
			
				str.a_substr( edx, 0, edi );
				strfree( edx );
				mov( eax, (type Variant [esi-@size(Variant)]).s );
								
			endif;
			mov( String_c, al );
			mov( al, (type Variant [esi-@size(Variant)]).DataType );
			ret();			
			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // LEN- computes the length of a string.
		  
		  case( LENftkn )
		  
		  	add( 2, ecx );		// Skip the LEN and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in LEN function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			// NumberToStr actually checks to see if TOS is a string,
			// however, a string operand is the most likely case, so
			// we'll optimize this a bit and do the test here rather
			// than having to make an excess function call most of
			// the time.
			
			if( al <> String_c ) then
			
				NumberToStr( esi );
				
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the length of the string:
			
			mov( (type Variant [esi-@size(Variant)]).s, edi );
			mov( (type str.strRec [edi]).length, eax );
			mov( eax, (type Variant [esi-@size(Variant)]).i );
			mov( Integer_c, al );
			mov( al, (type Variant [esi-@size(Variant)]).DataType );
			strfree( edi );
			ret();
			
			
			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // LOG- computes the base-e log of the supplied parameter.
		  
		  case( LOGftkn )
		  
		  	add( 2, ecx );		// Skip the LOG and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in LOG function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in LOG function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the base-e log and return:
			
			math.ln( (type Variant [esi-@size(Variant)]).r );
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
			
			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // MID- computes a substring.
		  
		  case( MIDftkn )
		  
		  	add( 2, ecx );		// Skip the LEFT and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> COMMAtkn ) then 
			
				stdout.put( nl "Too few parameters in MID function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx );			// Skip the "," token
			ORx( ecx, esi );	// Extract the second parameter.
			
			if( (type byte [ecx]) <> COMMAtkn ) then 
			
				stdout.put( nl "Too few parameters in MID function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			// Second parameter must be an integer, verify this:
			
			if( al <> Integer_c ) then
			
				stdout.put( nl "Second MID parameter must be an integer" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx );			// Skip the "," token
			ORx( ecx, esi );	// Extract the third parameter.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in MID function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			// Third parameter must also be an integer, verify this:
			
			if( al <> Integer_c ) then
			
				stdout.put( nl "Third MID parameter must be an integer" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx ); 		// Skip the ')'.

			mov( (type Variant [esi-@size(Variant)]).i, edi );	// Save Length
			sub( @size(Variant), esi );							// Pop stack.
			
			mov( (type Variant [esi-@size(Variant)]).i, edx );	// Save start
			sub( @size(Variant), esi );							// Pop stack.
			
			
			// The first parameter should be a string.  If not, see if
			// we can convert it to a string.
			
			NumberToStr( esi );

			// Now take the edx-based substring, with the length
			// specified in EDI, of the string on the TOS.
			
			mov( (type Variant [esi-@size(Variant)]).s, eax );
			
			// If the user-specified starting position is greater than
			// the current string length, return the empty string:
			
			if( edx > (type str.strRec [eax]).length ) then
			
				mov( 0, (type str.strRec [eax]).length );
				mov( 0, (type byte [eax]));
				ret();
				
			endif;
				 
			// Rely upon HLA's substr function to handle all the
			// other issues (e.g., desired string length is greater
			// than the number of available chars, etc).
			
			str.a_substr( eax, edx, edi );
			strfree( (type Variant [esi-@size(Variant)]).s );
			mov( eax, (type Variant [esi-@size(Variant)]).s );
			mov( String_c, al );
			mov( al, (type Variant [esi-@size(Variant)]).DataType );
			ret();						
			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // RANDOMIZE- Returns a pseudo-random number after randomizing the
		  //			generator.
		  
		  case( RANDOMIZEftkn )
		  
		  	inc( ecx );			// Skip RANDOMIZE  token.
			rand.randomize();	// Note: Requires Pentium processor.
			rand.uniform();
			mov( eax, (type Variant [esi]).i );
			mov( Integer_c, al );
			mov( al, (type Variant [esi]).DataType );
			add( @size(Variant), esi );
			ret();
			
						
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // RIGHT- computes a substring based at the end of the string.
		  
		  case( RIGHTftkn )
		  
		  	add( 2, ecx );		// Skip the RIGHT and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> COMMAtkn ) then 
			
				stdout.put( nl "Too few parameters in RIGHT function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx );			// Skip the "," token
			ORx( ecx, esi );	// Extract the second parameter.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in RIGHT function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Second parameter must be an integer, verify this:
			
			if( al <> Integer_c ) then
			
				stdout.put( nl "Second RIGHT parameter must be an integer" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			mov( (type Variant [esi-@size(Variant)]).i, edi );	// Save Length
			sub( @size(Variant), esi );							// Pop stack.
			
			// The first parameter should be a string.  If not, see if
			// we can convert it to a string.
			
			NumberToStr( esi );

			// Now take the zero-based substring, with the length
			// specified in EDI, of the string on the TOS.
			
			mov( (type Variant [esi-@size(Variant)]).s, edx );
			mov( (type str.strRec [edx]).length, eax );
			
			// If the user specified a length longer than the current
			// length of the string, then simply return the current
			// string.  If the string's length is greater than the
			// length specified by the second parameter, then do a
			// substring operation.
			
			if( eax > edi ) then
			
				// Okay, we have to compute the starting position,
				// which is the length of the string minus the
				// new length:
				
				sub( edi, eax );
				str.a_substr( edx, eax, edi );
				strfree( edx );
				mov( eax, (type Variant [esi-@size(Variant)]).s );
								
			endif;
			mov( String_c, al );
			mov( al, (type Variant [esi-@size(Variant)]).DataType );
			ret();			




		  ////////////////////////////////////////////////////////////////////
		  //
		  // RND- Returns a pseudo-random number.
		  
		  case( RNDftkn )
		  
		  	inc( ecx );			// Skip RND  token.
			rand.uniform();
			shr( 1, eax );		// Make sure it's always positive.
			mov( eax, (type Variant [esi]).i );
			mov( Integer_c, al );
			mov( al, (type Variant [esi]).DataType );
			add( @size(Variant), esi );
			ret();			

			
			
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // Round- Rounds a real expression to the nearest even integer.
		  
		  case( ROUNDftkn )
		  
		  	add( 2, ecx );		// Skip ROUND and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in ROUND function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx );		// Skip the ")".
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Real_c ) then
			
				// Convert real value to integer via rounding.
				// Note that this code assumes that the FPU is
				// in the "Round to the nearest even integer" mode.
				
				fld( (type Variant [esi-@size(Variant)]).r );
				fistp( (type Variant [esi-@size(Variant)]).i );
				mov( Integer_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				ret();
				
			elseif( al <> Integer_c ) then
			
				stdout.put
				( 
					nl 
					"Illegal parameter data type in ROUND function" 
				);
				AtLineNumber();
				raise( BasicError );
								
			endif;
			ret();			




		  ////////////////////////////////////////////////////////////////////
		  //
		  // SIN- computes the sine of the angle supplied in radians.
		  
		  case( SINftkn )
		  
		  	add( 2, ecx );		// Skip the SIN and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in SIN function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in SIN function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the trignometric sine and return:
			
			fld( (type Variant [esi-@size(Variant)]).r );
			fsin();
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
			
			 
			
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // SQRT- computes the square root of the supplied parameter.
		  
		  case( SQRTftkn )
		  
		  	add( 2, ecx );		// Skip the SQRT and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in SQRT function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in SQRT function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the trignometric sine and return:
			
			fld( (type Variant [esi-@size(Variant)]).r );
			fsqrt();
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
			
			 
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // STR- converts an integer or real expression to a string. 
		  
		  case( STRftkn )
		  
		  	add( 2, ecx );		// Skip the CHR and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			// If there is a comma, then we've got a field width
			// value.  Grab that and put it in EDX.
			 
			if( (type byte [ecx]) = COMMAtkn ) then
			
				inc( ecx );			// Skip the comma.
				ORx( ecx, esi ); 	// Get the field width.
				if( al <> Integer_c ) then
				
					stdout.put
					(
						nl
						"Expected an integer as second STR parameter"
					);
					AtLineNumber();
					raise( BasicError );
					
				endif;
				sub( @size( Variant ), esi );
				mov( (type Variant [esi]).i, edx );
				
				// Check for a third parameter.  This specifies
				// the decimal positions.
				
				push( edx );
				if( (type byte [ecx]) = COMMAtkn ) then
				
					inc( ecx );			// Skip the comma.
					ORx( ecx, esi );	// Get the decimal positions.
					if( al <> Integer_c ) then
					
						stdout.put
						(
							nl
							"Expected an integer as third STR parameter"
						);
						AtLineNumber();
						raise( BasicError );
						
					endif;
					sub( @size( Variant ), esi );
					mov( (type Variant [esi]).i, edi );
				
				else
				
					mov( -1, edi );	// No decimal positions field.
					
				endif;
				pop( edx );
				
			else
			
				// No field width (and no decimal places, either).
				// Default to zero.
				
				xor( edx, edx );
				mov( -1, edi );
				
			endif;
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in STR function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx ); 		// Skip the ')'.


			// Okay, figure out the type of data we're supposed to
			// convert and do the conversion.
			
			mov( (type Variant [esi-@size(Variant)]).DataType, al );
			if( al = Integer_c ) then
			
				// Just ignore EDI's value for integers.
				
				mov( 12, eax );
				if( eax < edx ) then
				
					mov( edx, eax );
					
				endif;
				stralloc( eax );
				conv.i32ToStr
				(
					(type Variant [esi-@size(Variant)]).i,
					edx,
					' ',
					eax
				);
				mov( eax, (type Variant [esi-@size(Variant)]).s );
				mov( String_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				ret();
				 
			
			elseif( al = Real_c ) then

				mov( 26, eax );
				if( eax < edx ) then
				
					mov( edx, eax );
					
				elseif( edx = 0 ) then
				
					mov( 24, edx );
					
				endif;
				stralloc( eax );
				if( (type int32 edi) < 0 ) then
				
					// Use exponential form if EDI < 0.
					
					conv.e64ToStr
					(
						(type Variant [esi-@size(Variant)]).r,
						edx,
						eax
					);
					
				else
				
					conv.r64ToStr
					(
						(type Variant [esi-@size(Variant)]).r,
						edx,
						edi,
						' ',
						eax
					);
				
				endif;
				mov( eax, (type Variant [esi-@size(Variant)]).s );
				mov( String_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				ret();
				 
			
			
			elseif( al = String_c ) then
			
				// This may seem weird, allowing a string parameter
				// to the STR function, but it's actually quite useful
				// for reformatting strings.
				// 
				// EDX (field width) specifies the new size of the
				// string.
				//
				// EDI (which must be less than EDX and the length of
				// the current string) specifies the number of chars
				// to copy from the original string (copy all characters
				// if EDI is zero).
				
				mov( (type Variant [esi-@size(Variant)]).s, eax );
				mov( (type str.strRec [eax]).length, eax );

				// If the number of characters to copy is greater than
				// the length of the string, then just use the string's
				// length.  If the user didn't specify the number of
				// characters to copy (and, hence, EDI contains -1 or
				// $FFFF_FFFF, then we must also use the current
				// string's length.
				
				if( edi >= eax ) then // Note that $FFFF_FFFF is always >= eax.
				
					mov( eax, edi );
					
				endif;
				
				// If the number of characters to copy (after the adjustment
				// above) is greater than the destination length, then
				// expand the destination length (to make the string short,
				// specify a smaller 3rd parameter rather than a smaller
				// second parameter).
				
				if( edi > edx ) then
				
					mov( edi, edx );
					
				endif;
				
				// Okay, all that junk's out of the way.  Let's create
				// the new string and pad it with a sufficient number
				// of spaces:
				
				stralloc( edx );
				
				str.substr
				( 
					(type Variant [esi-@size(Variant)]).s, 
					eax,  
					0,
					edi
				);

				while( edi < edx ) do
				
					mov( ' ', (type char [eax+edi]) );
					inc( edi );
					
				endwhile;
				
				// Fix the length of the new string.
				
				mov( edx, (type str.strRec [eax]).length );
				
				// Deallocate the storage for the old string:
				
				strfree( (type Variant [esi-@size(Variant)]).s );
				
				// Set this to the new string:
				
				mov( eax, (type Variant [esi-@size(Variant)]).s );
				mov( String_c, al );
				ret();
				
			else
			
				stdout.put( nl "Unsupported data type (1st parameter, STR)" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
		
		
			
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // TAN- computes the tangent of the angle supplied in radians.
		  
		  case( TANftkn )
		  
		  	add( 2, ecx );		// Skip the SIN and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in TAN function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			if( al = String_c ) then
			
				StrToNumber( esi );
				
			endif;
			if( al = Integer_c ) then
			
				// Convert integer value to float:
				
				fild( (type Variant [esi-@size(Variant)]).i );
				fstp( (type Variant [esi-@size(Variant)]).r );
				mov( Real_c, al );
				mov( al, (type Variant [esi-@size(Variant)]).DataType );
				
			elseif( al <> Real_c ) then
			
				stdout.put( nl "Illegal parameter data type in SIN function" );
				AtLineNumber();
				raise( BasicError );
								
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			// Compute the trignometric tangent and return:
			
			fld( (type Variant [esi-@size(Variant)]).r );
			fsincos();
			fdiv();
			fstp( (type Variant [esi-@size(Variant)]).r );
			ret();
			
			
			 
			
		  ////////////////////////////////////////////////////////////////////
		  //
		  // Handle the VAL function here.
		  // The single operand is a string.
		  // Convert it to an integer (if possible) or a real (if not
		  // an integer).  Raises an exception if it isn't a real or
		  // integer string.
		  
		  case( VALftkn )
		  
		  	add( 2, ecx );		// Skip the VAL and '(' tokens.
			ORx( ecx, esi );	// Evaluate the expression.
			
			if( (type byte [ecx]) <> RPARENtkn ) then	
			
				stdout.put( nl "Too many parameters in VAL function call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			if( al <> String_c ) then
			
				stdout.put( nl "Expected a string expression in VAL call" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			inc( ecx ); 		// Skip the ')'.
			
			StrToNumber( esi );
			ret();
		  
		endswitch;
		
		stdout.put
		( 
			nl
			"Illegal factor token: ", 
			(type byte [ecx]),
			" at offset ",
			ecx 
		);
		AtLineNumber();
		raise( BasicError );
		 
	end Factor;
	
	
	
	
	
	
	/////////////////////////////////////////////////////////////////////////
	//
	// MULx-
	// 
	// Handles arithmetic expressions involving the *, /, and % operators.
	
	
	procedure MULx
	( 
		ip:dword in ecx; 
		ExprStackPtr:dword in esi 
	);
		@noframe; 
		@nodisplay;
	
	begin MULx;
	
			Factor( ecx, esi );
		ZeroOrMoreExprs:
		
			mov( [ecx], dl );
			cmp( dl, MULtkn );
			je GotMULop;
			cmp( dl, DIVtkn );
			je GotDIVop;
			cmp( dl, MODtkn );
			je GotMODop;
			ret();
		
		GotMULop:
		
			// Okay, skip over the * token and grab the following subexpression:
			
			inc( ecx );
			Factor( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// At this point, the types of the two operands are identical.
			// So multiplication is pretty easy.
			
			if( al = Integer_c ) then

				mov( (type Variant [esi - @size( Variant )]).i, eax );
				intmul( (type Variant [esi - @size( Variant )*2]).i, eax );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				if( @o ) then
				
					stdout.put( nl "Integer overflow" );
					AtLineNumber();
					raise( BasicError );
					
				endif;
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = Real_c ) then
			
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fmul( (type Variant [esi - @size( Variant )]).r );
				fstp( (type Variant [esi - @size( Variant )*2]).r );
				sub( @size( Variant ), esi );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = String_c ) then
			
				stdout.put( nl "'*' operand type mismatch"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'*' does not support array operands"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( "Corrupted data type (internal error)!", nl );
			raise( BasicError );
		
		
		
		
		
		
		GotDIVop:
		
			// Okay, skip over the / token and grab the following subexpression:
			
			inc( ecx );
			Factor( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// At this point, the types of the two operands are identical.
			// So division is pretty easy.
			
			if( al = Integer_c ) then

				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cdq();
				if( (type Variant [esi - @size( Variant )]).i = 0 ) then
				
					stdout.put( nl "Divide by zero" );
					AtLineNumber();
					raise( BasicError );
					
				endif;
				push( ebx );
				try
				
					idiv( (type Variant [esi - @size( Variant )]).i, edx:eax );
					
				  unprotected
				  	pop( ebx );
					mov
					( 
						eax, 
						(type Variant [esi - @size( Variant )*2]).i 
					);
					sub( @size( Variant ), esi );
					mov( Integer_c, al );
					jmp ZeroOrMoreExprs;
				  
					
				  anyexception
				  
				  	if( eax <> ex.DivideError ) then
					
						raise( eax );
						
					endif;
					
				endtry;
				pop( ebx );
				  
				stdout.put( nl "Division overflow" );
				AtLineNumber();
				raise( BasicError );
					
			endif;
			
			
			if( al = Real_c ) then
			
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fdiv( (type Variant [esi - @size( Variant )]).r );
				fstp( (type Variant [esi - @size( Variant )*2]).r );
				sub( @size( Variant ), esi );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = String_c ) then
			
				stdout.put( nl "'/' operand type mismatch" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'/' does not support array operands"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( "Corrupted data type (internal error)!", nl );
			raise( BasicError );
		


		
		
		
		
		
		
		GotMODop:
		
			// Okay, skip over the % token and grab the following subexpression:
			
			inc( ecx );
			Factor( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// At this point, the types of the two operands are identical.
			// So division is pretty easy.
			
			if( al = Integer_c ) then

				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cdq();
				if( (type Variant [esi - @size( Variant )]).i = 0 ) then
				
					stdout.put( nl "Divide by zero" );
					AtLineNumber();
					raise( BasicError );
					
				endif;
				push( ebx );
				try
				
					idiv( (type Variant [esi - @size( Variant )]).i, edx:eax );
					
				  unprotected
				  	pop( ebx );
					mov
					( 
						edx, 
						(type Variant [esi - @size( Variant )*2]).i 
					);
					sub( @size( Variant ), esi );
					mov( Integer_c, al );
					jmp ZeroOrMoreExprs;
				  
					
				  anyexception
				  
				  	if( eax <> ex.DivideError ) then
					
						raise( eax );
						
					endif;
					
				endtry;
				pop( ebx );
				  
				stdout.put( nl "Division error" );
				AtLineNumber();
				raise( BasicError );
					
			endif;
			
			stdout.put( nl "'%' operand type mismatch at" );
			AtLineNumber();
			raise( BasicError );
				
		


	end MULx;
	
	
	
	
	
	
	/////////////////////////////////////////////////////////////////////////
	//
	// ADDx-
	// 
	// Handles arithmetic expressions involving the + and - operators.
	
	
	procedure ADDx
	( 
		ip:dword in ecx; 
		ExprStackPtr:dword in esi 
	);
		@noframe; 
		@nodisplay;
	
	begin ADDx;
		
			MULx( ecx, esi );
		ZeroOrMoreExprs:
			mov( [ecx], dl );
			cmp( dl, PLUStkn );
			je GotPLUSop;
			cmp( dl, MINUStkn );
			je GotMINUSop;
			ret();
		
		GotPLUSop:
		
			// Okay, skip over the + token and grab the following subexpression:
			
			inc( ecx );
			MULx( ecx, esi );

			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// At this point, the types of the two operands are identical.
			// So addition (or concatentation) is pretty easy.
			
			if( al = Integer_c ) then

				mov( (type Variant [esi - @size( Variant )]).i, eax );
				add( (type Variant [esi - @size( Variant )*2]).i, eax );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				if( @o ) then
				
					stdout.put( nl "Integer overflow" );
					AtLineNumber();
					raise( BasicError );
					
				endif;
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = Real_c ) then
			
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fadd( (type Variant [esi - @size( Variant )]).r );
				fstp( (type Variant [esi - @size( Variant )*2]).r );
				sub( @size( Variant ), esi );
				mov( Real_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = String_c ) then
			
				str.a_cat
				(
					(type Variant [esi - @size( Variant )*2]).s,
					(type Variant [esi - @size( Variant )]).s
				);
				strfree( (type Variant [esi - @size( Variant )*2]).s );
				strfree( (type Variant [esi - @size( Variant )]).s ); 
				mov( eax, (type Variant [esi - @size( Variant )*2]).s );
				sub( @size( Variant ), esi );
				mov( String_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'+' does not support array operands" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( "Corrupted data type (internal error)!", nl );
			raise( BasicError );
		
				 
		
		GotMINUSop:
		
			// Okay, skip over the - token and grab the following subexpression:
			
			inc( ecx );
			MULx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// At this point, the types of the two operands are identical.
			// So subtraction is pretty easy.
			
			if( al = Integer_c ) then

				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				sub( (type Variant [esi - @size( Variant )]).i, eax );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				if( @o ) then
				
					stdout.put( nl "Integer overflow" );
					AtLineNumber();
					raise( BasicError );
					
				endif;
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = Real_c ) then
			
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fsub( (type Variant [esi - @size( Variant )]).r );
				fstp( (type Variant [esi - @size( Variant )*2]).r );
				sub( @size( Variant ), esi );
				jmp ZeroOrMoreExprs;
				
			endif;
			
			
			if( al = String_c ) then
			
				strfree( (type Variant [esi - @size( Variant )*2]).s ); 
				strfree( (type Variant [esi - @size( Variant )]).s ); 
				stdout.put( nl "'-' operand type mismatch"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'-' does not support array operands" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( nl "Corrupted data type (internal error)!" );
			AtLineNumber();
			raise( BasicError );
		
				 
	end ADDx;
	
	
	
	
	
	
	
	
	
	
	/////////////////////////////////////////////////////////////////////////
	//
	// RELx-
	// 
	// Handles arithmetic expressions involving the relational operators.
	
	
	procedure RELx
	( 
		ip:dword in ecx; 
		ExprStackPtr:dword in esi 
	);
		@noframe; 
		@nodisplay;
	
	begin RELx;
	
		ADDx( ecx, esi );
		ZeroOrMoreExprs:
		
			mov( [ecx], dl );
			cmp( dl, LTtkn );
			je GotLTop;
			cmp( dl, LEtkn );
			je GotLEop;
			cmp( dl, EQtkn );
			je GotEQop;
			cmp( dl, NEtkn );
			je GotNEop;
			cmp( dl, GTtkn );
			je GotGTop;
			cmp( dl, GEtkn );
			je GotGEop;
			ret();
			
		
		////////////////////////////////////////////////////////////////////////
		//
		// Handle the "<" operator here:					
		
		GotLTop:
		
			// Okay, skip over the < token and grab the following subexpression:
			
			inc( ecx );
			ADDx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// Okay, compare the two operands, pop the second one, and store
			// true (1) or false (0) over the top of the first one:
			
			if( al =Integer_c ) then
			
				// Compare two integers on the evaluation stack:
				
				xor( edx, edx );
				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cmp( eax, (type Variant [esi - @size( Variant )]).i );
				setl( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = Real_c ) then
			
				// Compare two reals on the evaluation stack:
				
				xor( edx, edx );
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fld( (type Variant [esi - @size( Variant )]).r );
				fcompp();
				fstsw( ax );
				sahf();
				setb( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Remove the second value from the stack:
				
				sub( @size( Variant ), esi );
				
				// We've created an integer result:
				
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = String_c ) then
			
				// Compare two strings on the evaluation stack:
				
				xor( edx, edx );
				str.lt
				(
					(type Variant [esi-@size(Variant)*2]).s,
					(type Variant [esi-@size(Variant)]).s
				);
				and( 1, eax );
				mov( (type Variant [esi - @size( Variant )*2]).s, edx );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Free up string storage:
				
				strfree( (type Variant [edx]).s );
				strfree( (type Variant [esi - @size( Variant )]).s );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );

				// We've created an integer result:
				
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'<' does not support array operands"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( "Internal BASIC error (memory corruption)" nl );
			raise( BasicError );
			
		
		////////////////////////////////////////////////////////////////////////
		//
		// Handle the "<=" operator here:					
		
		GotLEop:
		
			// Okay, skip over the <= token and grab the following subexpression:
			
			inc( ecx );
			ADDx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// Okay, compare the two operands, pop the second one, and store
			// true (1) or false (0) over the top of the first one:
			
			if( al = Integer_c ) then
			
				// Compare two integers on the evaluation stack:
				
				xor( edx, edx );
				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cmp( eax, (type Variant [esi - @size( Variant )]).i );
				setle( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = Real_c ) then
			
				// Compare two reals on the evaluation stack:
				
				xor( edx, edx );
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fld( (type Variant [esi - @size( Variant )]).r );
				fcompp();
				fstsw( ax );
				sahf();
				setbe( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Remove the second value from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = String_c ) then
			
				// Compare two strings on the evaluation stack:
				
				xor( edx, edx );
				str.le
				(
					(type Variant [esi-@size(Variant)*2]).s,
					(type Variant [esi-@size(Variant)]).s
				);
				and( 1, eax );
				mov( (type Variant [esi - @size( Variant )*2]).s, edx );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Free up string storage:
				
				strfree( (type Variant [edx]).s );
				strfree( (type Variant [esi - @size( Variant )]).s );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			
			
			if( al = Array_c ) then
			
				stdout.put( "'<=' does not support array operands"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( nl "Internal BASIC error (memory corruption)" );
			AtLineNumber();
			raise( BasicError );
			
							
		
			
		
		////////////////////////////////////////////////////////////////////////
		//
		// Handle the "=" operator here:					
		
		GotEQop:
		
			// Okay, skip over the = token and grab the following subexpression:
			
			inc( ecx );
			ADDx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// Okay, compare the two operands, pop the second one, and store
			// true (1) or false (0) over the top of the first one:
			
			if( al = Integer_c ) then
			
				// Compare two integers on the evaluation stack:
				
				xor( edx, edx );
				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cmp( eax, (type Variant [esi - @size( Variant )]).i );
				sete( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = Real_c ) then
			
				// Compare two reals on the evaluation stack:
				
				xor( edx, edx );
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fld( (type Variant [esi - @size( Variant )]).r );
				fcompp();
				fstsw( ax );
				sahf();
				sete( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Remove the second value from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = String_c ) then
			
				// Compare two strings on the evaluation stack:
				
				xor( edx, edx );
				str.eq
				(
					(type Variant [esi-@size(Variant)*2]).s,
					(type Variant [esi-@size(Variant)]).s
				);
				and( 1, eax );
				mov( (type Variant [esi - @size( Variant )*2]).s, edx );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Free up string storage:
				
				strfree( (type Variant [edx]).s );
				strfree( (type Variant [esi - @size( Variant )]).s );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'=' does not support array operands"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( nl "Internal BASIC error (memory corruption)" );
			AtLineNumber();
			raise( BasicError );
			
							
		
			
		
		////////////////////////////////////////////////////////////////////////
		//
		// Handle the "<>" operator here:					
		
		GotNEop:
		
			// Okay, skip over the <> token and grab the following 
			// subexpression:
			
			inc( ecx );
			ADDx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// Okay, compare the two operands, pop the second one, and store
			// true (1) or false (0) over the top of the first one:
			
			if( al = Integer_c ) then
			
				// Compare two integers on the evaluation stack:
				
				xor( edx, edx );
				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cmp( eax, (type Variant [esi - @size( Variant )]).i );
				setne( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = Real_c ) then
			
				// Compare two reals on the evaluation stack:
				
				xor( edx, edx );
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fld( (type Variant [esi - @size( Variant )]).r );
				fcompp();
				fstsw( ax );
				sahf();
				setne( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Remove the second value from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = String_c ) then
			
				// Compare two strings on the evaluation stack:
				
				xor( edx, edx );
				str.ne
				(
					(type Variant [esi-@size(Variant)*2]).s,
					(type Variant [esi-@size(Variant)]).s
				);
				and( 1, eax );
				mov( (type Variant [esi - @size( Variant )*2]).s, edx );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Free up string storage:
				
				strfree( (type Variant [edx]).s );
				strfree( (type Variant [esi - @size( Variant )]).s );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'<>' does not support array operands" );
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( nl "Internal BASIC error (memory corruption)" );
			AtLineNumber();
			raise( BasicError );
			
							
		
			
		
		////////////////////////////////////////////////////////////////////////
		//
		// Handle the ">" operator here:					
		
		GotGTop:
		
			// Okay, skip over the > token and grab the following subexpression:
			
			inc( ecx );
			ADDx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// Okay, compare the two operands, pop the second one, and store
			// true (1) or false (0) over the top of the first one:
			
			if( al = Integer_c ) then
			
				// Compare two integers on the evaluation stack:
				
				xor( edx, edx );
				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cmp( eax, (type Variant [esi - @size( Variant )]).i );
				setg( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = Real_c ) then
			
				// Compare two reals on the evaluation stack:
				
				xor( edx, edx );
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fld( (type Variant [esi - @size( Variant )]).r );
				fcompp();
				fstsw( ax );
				sahf();
				seta( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Remove the second value from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = String_c ) then
			
				// Compare two strings on the evaluation stack:
				
				xor( edx, edx );
				str.gt
				(
					(type Variant [esi-@size(Variant)*2]).s,
					(type Variant [esi-@size(Variant)]).s
				);
				and( 1, eax );
				mov( (type Variant [esi - @size( Variant )*2]).s, edx );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Free up string storage:
				
				strfree( (type Variant [edx]).s );
				strfree( (type Variant [esi - @size( Variant )]).s );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'>' does not support array operands"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( nl "Internal BASIC error (memory corruption)" nl );
			AtLineNumber();
			raise( BasicError );
			
							
		
			
		
		////////////////////////////////////////////////////////////////////////
		//
		// Handle the ">=" operator here:					
		
		GotGEop:
		
			// Okay, skip over the >= token and grab the 
			// following subexpression:
			
			inc( ecx );
			ADDx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// Okay, compare the two operands, pop the second one, and store
			// true (1) or false (0) over the top of the first one:
			
			if( al = Integer_c ) then
			
				// Compare two integers on the evaluation stack:
				
				xor( edx, edx );
				mov( (type Variant [esi - @size( Variant )*2]).i, eax );
				cmp( eax, (type Variant [esi - @size( Variant )]).i );
				setge( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = Real_c ) then
			
				// Compare two reals on the evaluation stack:
				
				xor( edx, edx );
				fld( (type Variant [esi - @size( Variant )*2]).r );
				fld( (type Variant [esi - @size( Variant )]).r );
				fcompp();
				fstsw( ax );
				sahf();
				setae( dl );
				mov( edx, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Remove the second value from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			if( al = String_c ) then
			
				// Compare two strings on the evaluation stack:
				
				xor( edx, edx );
				str.ge
				(
					(type Variant [esi-@size(Variant)*2]).s,
					(type Variant [esi-@size(Variant)]).s
				);
				and( 1, eax );
				mov( (type Variant [esi - @size( Variant )*2]).s, edx );
				mov( eax, (type Variant [esi - @size( Variant )*2]).i );
				mov
				( 
					Integer_c, 
					(type Variant [esi - @size( Variant )*2]).DataType 
				);
				
				// Free up string storage:
				
				strfree( (type Variant [edx]).s );
				strfree( (type Variant [esi - @size( Variant )]).s );
				
				// Pop the second item from the stack:
				
				sub( @size( Variant ), esi );
				mov( Integer_c, al );
				jmp ZeroOrMoreExprs;
				
			endif;
				
			
			
			if( al = Array_c ) then
			
				stdout.put( nl "'>=' does not support array operands"	);
				AtLineNumber();
				raise( BasicError );
				
			endif;
			stdout.put( nl "Internal BASIC error (memory corruption)" );
			AtLineNumber();
			raise( BasicError );
		
	end RELx;
	
	
	
	/////////////////////////////////////////////////////////////////////////
	//
	// ANDx-
	// 
	// Handles logical expressions involving the AND operator.
	
	
	procedure ANDx
	( 
		ip:dword in ecx; 
		ExprStackPtr:dword in esi 
	);
		@noframe; 
		@nodisplay;
	
	begin ANDx;
		
			RELx( ecx, esi );
		ZeroOrMoreExprs:
		
			mov( [ecx], dl );
			cmp( dl, ANDtkn );
			je GotANDop;
			ret();
		
		GotANDop:
		
			// Okay, skip over the AND token and grab the following subexpression:
			
			inc( ecx );
			RELx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// The operands must both be integers at this point, or else
			// we've got a type conflict.  Note that both types are the
			// same here (MakeCompatible made them that way):
			
			mov( (type Variant [esi - @size( Variant )]).DataType, al );
			if( al <> Integer_c ) then
			
				if( al = String_c ) then
				
					strfree( (type Variant [esi - @size( Variant )]).s );
					strfree( (type Variant [esi - @size( Variant )*2]).s );
				
				endif;
				stdout.put( "AND requires integer operands" nl );
				raise( BasicError );
				
			endif;
				
			// Okay, compute the arithmetic AND of the two operands:
			
			xor( edx, edx );
			cmp( (type Variant [esi - @size( Variant )]).i, 0 );
			setne( dl );
			cmp( (type Variant [esi - @size( Variant )*2]).i, 0 );
			setne( ah );
			and( ah, dl );
			mov( edx, (type Variant [esi - @size( Variant )*2]).i );
			sub( @size( Variant ), esi );
			mov( Integer_c, al );
			jmp ZeroOrMoreExprs;
		
	end ANDx;
	
	
	
	
	
	
	
	/////////////////////////////////////////////////////////////////////////
	//
	// ORx-
	// 
	// Handles logical expressions involving the OR operator.
	
	
	procedure ORx
	( 
		ip:dword in ecx;
		ExprStackPtr:dword in esi 
	); 
		@noframe; 
		@nodisplay;
		
	begin ORx;

			ANDx( ecx, esi );
		ZeroOrMoreExprs:
		
			mov( [ecx], dl );
			cmp( dl, ORtkn );
			je GotORop;
			ret();
		
		GotORop:
		
			// Okay, skip over the < token and grab the following subexpression:
			
			inc( ecx );
			ANDx( ecx, esi );
			
			// Verify that the two operand types are compatible (or coerce them
			// if they're not.
			
			MakeCompatible( esi );
			
			// The operands must both be integers at this point, or else
			// we've got a type conflict.  Note that both types are the
			// same here (MakeCompatible made them that way):
			
			mov( (type Variant [esi - @size( Variant )]).DataType, al );
			if( al <> Integer_c ) then
			
				if( al = String_c ) then
				
					strfree( (type Variant [esi - @size( Variant )]).s );
					strfree( (type Variant [esi - @size( Variant )*2]).s );
				
				endif;
				stdout.put( "OR requires integer operands" nl );
				raise( BasicError );
				
			endif;
				
			// Okay, compute the arithmetic OR of the two operands:
			
			xor( edx, edx );
			mov( (type Variant [esi - @size( Variant )]).i, eax );
			or( (type Variant [esi - @size( Variant )*2]).i, eax );
			setne( dl );
			mov( edx, (type Variant [esi - @size( Variant )*2]).i );
			sub( @size( Variant ), esi );
			mov( Integer_c, al );
			jmp ZeroOrMoreExprs;
		
	end ORx;
		
		
/****************************************************************************/			


begin EvalExpr;

	push( ebx );
	push( edx );
	push( edi );
	pushfd();
	
	mov( &ExprStack, esi );
	ORx( ecx, esi );
	sub( @size( Variant ), esi );
	
	// Should use assert, but it is broken in HLA v1.25:
	
	#if( @defined( DEBUG ))
	
		if( esi <> &ExprStack ) then
		
			stdout.put( "Evaluation stack error! (internal error)", nl );
			raise( BasicError );
			
		endif;
		
	#endif
	
	popfd();
	pop( edi );
	pop( edx );
	pop( ebx );
	ret();
	
end EvalExpr;



/************************************************************/
/*                                                          */
/* Deallocate-                                              */
/*                                                          */
/* Whenever we assign a value to a variable, we need to     */
/* deallocate any storage previously held by that variable. */
/* This routine handles that chore.                         */
/*                                                          */
/* Input:                                                   */
/* 	EAX-	Contains a pointer to the VALUE entry	        */
/* 			for the specified identifier.                   */
/*                                                          */
/************************************************************/
			

procedure Deallocate( valPtr:dword in eax ); @nodisplay; @noframe;
begin Deallocate;

	push( eax );
	push( edx );
	push( edi );
	mov( eax, edx );
	if( (type Variant [edx]).DataType = Array_c ) then
	
		// We've got an array.  Recursively call
		// this function on each element of the array.
		// Note that HLABasic array elements can be
		// different types, so we must iterate over each
		// element.
		

		mov( (type Variant [edx]).a.elements, edi );
		mov( (type Variant [edx]).a.array, eax );
		test( edi, edi );
		while( @nz ) do
		
			Deallocate( eax );
			add( @size( Variant ), eax );
			dec( edi );
			
		endwhile;
		free( (type Variant [edx]).a.array );
		
		
	else // It's a scalar variable
	
		// If it's a string, we've got to free the data associated
		// with the string data.  If it's some other data type,
		// we don't have to do anything.
		
		if( (type Variant [edx]).DataType = String_c ) then
		
			free( (type Variant [edx]).s );
			
		endif;
		 
	endif;
	pop( edi );
	pop( edx );
	pop( eax );
	ret();

end Deallocate;







/**************************************************************/
/*                                                            */
/* ProcessIndex-                                              */
/*                                                            */
/* Checks for a "[" after a variable name.                    */
/* If present, and the variable is an array object,           */
/* this code computes the index of the specified              */
/* array element.                                             */
/*                                                            */
/* Inputs-                                                    */
/* 	EDX-	Points at the hash table entry for the variable.  */
/* 	ECX-	Points at the first token beyond the var address. */
/* 	                                                          */
/* Outputs-                                                   */
/* 	EDX-	Pointer to variant object (scalar variable or     */
/*          the array element).	                              */
/*                                                            */
/**************************************************************/


procedure ProcessIndex; @nodisplay;
begin ProcessIndex;

	// If a bracket follows the ID, then we've
	// got an array index.  Process that.

	mov( (type tableNode [edx]).Value, edx );
	while( (type byte [ecx]) = LBRACKtkn ) do

		push( edx );	// Save value ptr for later.
		
		// Make sure this is an array variable before
		// we go any farther:
		
		if( edx = NULL ) then
		
			stdout.put
			( 
				nl
				"Attempt to index non-array variable" 
			);
			AtLineNumber();
			raise( BasicError );
		
		endif;
			
		if( (type Variant [edx]).DataType <> Array_c ) then
		
			stdout.put
			( 
				nl
				"Attempt to index non-array variable" 
			);
			AtLineNumber();
			raise( BasicError );
		
		endif;

		// Evaluate the expression inside the brackets:
		
		inc( ecx );			// Skip the "[" token.
		EvalExpr( ecx );	// Get Index value.
		inc( ecx );			// Skip the "]" token.
		if( al = String_c ) then
		
			// If the index is a string value,
			// attempt to convert it to an integer.
			
			StrToNumber( esi );
			
		endif;
		if( al <> Integer_c ) then
		
			stdout.put
			(
				nl
				"Expected an integer array index"
			);
			AtLineNumber();
			raise( BasicError );
			
		endif;
		pop( edx );					// Retrieve var pointer
		mov( ExprStack.i, eax );	// Get index
		if( eax >= (type Variant [edx]).a.elements ) then
		
			stdout.put( nl "Array bounds exceeded" );
			AtLineNumber();
			raise( BasicError );
			
		endif;

		// Compute the address of the desired element:
		
		intmul( @size( Variant ), eax );
		mov( (type dword (type Variant [edx]).a.array), edx );
		lea( edx, [edx+eax] );

	endwhile;

end ProcessIndex;






/*******************************************/
/*                                         */
/* RunProc-                                */
/*                                         */
/* Handles the "RUN" and "RUN #" commands. */
/*                                         */
/*******************************************/

procedure RunProc( line:uns16 ); @nodisplay;
static
	InputStr:	string;
	VarPtr:		dword;
	
begin RunProc;

	pushad();
	Compile();

	if( !FindLine( TxtStart, line ) ) then
	
		if( line <> 0 ) then
	
			raise( NoSuchLineException );
			
		endif;
		
		// If the line number was zero then we're
		// supposed to run the program from the beginning.
		// If EDX = TxtEnd at this point, then the program
		// is empty.  This, technically isn't an error, but
		// we should immediately stop execution since there
		// is nothing to do.
		
		if( edx = TxtEnd ) then
		
			raise( BasicError );
			
		endif;
		
	endif;
	
	// Okay, EDX contains the address of the statement
	// where we are to begin program execution.  Move this
	// into EBX (a safer location for the instruction pointer)
	// and begin program execution:
	
	mov( edx, ebx );
	forever
	
		lea( ecx, [ebx+4] );	// Point at start of program text.
		begin EachStmt;
		
			forever
		
				movzx( (type byte [ecx]), eax );
				switch( eax )
				
					case( BEEPtkn )
					
						stdout.putc( stdio.bell );
						inc( ecx );
						
					case( CLStkn )
					
						win32cons.cls();
						inc( ecx );
						
					
					case( COLORtkn )
					
						//	COLOR expr, expr
					
						inc( ecx );			// Skip the COLOR token.
						EvalExpr( ecx );	// Get the foreground value.
						MakeInt( al, "COLOR requires integer operands" );
						push( eax );
						inc( ecx );			// Skip the "," token.
						EvalExpr( ecx );	// Get the background color.
						MakeInt( al, "COLOR requires integer operands" );
						pop( edx );
						and( $f, eax );
						shl( 4, dl );
						or( dl, al );
						win32cons.setOutputAttr( ax );
					
						
					
					
					case( DEBUGtkn )
					
						xor( true, debugFlag );
						inc( ecx );
						
					case( ELSEtkn )
					
						// The only way we hit an ELSEtkn is by
						// falling into it from the THEN section.
						// So we must transfer control to the target
						// address (the ENDIF).
						
						mov( [ecx+1], ebx );
						lea( ecx, (type StmtRec [ebx]).stmt );
						
						
						
					case( ENDIFtkn )
					
						inc( ecx );		// Just skip over this token.
						
					
					case( FORtkn )
					
						//	FOR var = expr TO expr {STEP expr}
						
						mov( ForStackPtr, eax );
						mov( ebx, (type ForRecord [eax]).Line );
						mov( [ecx+5], edx );
						mov( (type tableNode [edx]).Value, edx );
						mov( edx, (type ForRecord [eax]).VarAdrs );
						
						push( edx );	// Save VarPtr for later use.
						
						add( 9, ecx );	// Skip FOR, adrs, and ID bytes.
						
						EvalExpr( ecx );
						MakeInt( al, "FOR loop expression must be integer" );
						
						// Free up the data associated with the loop
						// control variable:
						
						Deallocate( (type dword [esp]) );
						
						// Assign the value of the starting expression
						// to the loop control variable.
						
						mov( [esp], edi );
						mov( Integer_c, (type Variant [edi]).DataType );						
						mov( ExprStack.i, eax );
						mov( eax, (type Variant [edi]).i );
						
						// Skip over the "TO" token:
						
						inc( ecx );
						
						// Evaluate the final loop value expression:
						
						EvalExpr( ecx );
						MakeInt
						( 
							al, 
							"FOR loop ending expression must be integer" 
						);
												
						// Save the ending expression value in the
						// FORLOOP stack data structure.
						
						mov( ForStackPtr, edi );
						mov( ExprStack.i, eax );
						mov( eax, (type ForRecord [edi]).Limit );
						
						// Check to see if there is a STEP token:
						
						if( (type ReservedWords [ecx]) = STEPtkn ) then
						
							inc( ecx );		// Skip the STEP token.

							// Evaluate the increment expression:
							
							EvalExpr( ecx );
							MakeInt
							( 
								al, 
								"FOR loop STEP expression "
								"must be an integer" 
							);
													
							// Save the step expression value in the
							// FORLOOP stack data structure.
							
							mov( ForStackPtr, edi );
							mov( ExprStack.i, eax );
							mov( eax, (type ForRecord [edi]).Increment );
							
							
						else
						
							// If no STEP expression, then set the
							// increment value to +1.
							
							mov( 1, (type ForRecord [edi]).Increment );
							
						endif;
						
						// Save away the pointer to the end of the statement
						// into the FOR record:
						
						mov( ForStackPtr, edi );
						mov( ecx, (type ForRecord [edi]).Stmt );
						
						// Determine if we should even execute this
						// FOR loop once:
						
						pop( edx );		// Retrieve ptr to Loop Ctrl Var.
						mov( (type Variant [edx]).i, eax );  // Get its value.
						
						if( (type ForRecord [edi]).Increment < 0 ) then
						
							// The STEP value is negative, so ensure
							// that the loop control variable is greater
							// than or equal to the Limit value.
							
							if( eax < (type ForRecord [edi]).Limit ) then
							
								// Don't execute this loop even once.
								// Immediately skip to the statement following
								// the NEXT <ID> clause:
								
								mov( [ebx+5], ebx );	// Ptr to NEXT clause.
								lea( ecx, [ebx+9] );	// Skip over NEXT clause.

							else
							
								// Push the FOR data onto the FOR stack:
								
								add( @size( ForRecord ), ForStackPtr );
								
							endif;
							
						else 
						
							// The step value is non-negative.  Therefore,
							// we execute the body of the loop if the loop
							// control variable's value is less than or equal
							// to the final value.
							
							
							if( eax > (type ForRecord [edi]).Limit ) then
							
								// Don't execute this loop even once.
								// Immediately skip to the statement following
								// the NEXT <ID> clause:
								
								mov( [ebx+5], ebx );	// Ptr to NEXT clause.
								lea( ecx, [ebx+9] );	// Skip over NEXT clause.

							else
							
								// Push the FOR data onto the FOR stack:
								
								add( @size( ForRecord ), ForStackPtr );
								
							endif;
							
						endif;
															
						
						
						 
						 
					
													
						
					case( GETtkn )

						//	GET var
						
						pushad();
						repeat
						
							win32cons.readInput( inputRec );
							
						until( inputRec.EventType = win.KEY_EVENT );
						popad();
						
						// Deallocate any storage associated with the
						// variable:
						
						mov( [ecx+1], eax );	// Get ptr to variable.
						mov( (type tableNode [eax]).Value, eax );
						push( eax );
						Deallocate( eax );
						
						// Convert the variable to a string object and assign
						// it the ascii code of the character just read.
						
						pop( edi );
						mov( String_c, (type Variant [edi]).DataType );
						stralloc( 4 );
						mov( inputRec.Event.KeyEvent.AsciiChar, dl );
						mov( dl, [eax] );
						mov( 0, (type byte [eax+1] ));
						mov( 1, (type str.strRec [eax]).length );
						mov( eax, (type Variant [edi]).s );
						
						add( 5, ecx );			// Skip GET and Var tokens.
																		
						
					
					case( GOSUBtkn )
					
						add( 5, ecx );
						mov( GosubStackPtr, eax );
						mov( ecx, (type GosubRecord [eax]).RtnAdrs );
						mov( ebx, (type GosubRecord [eax]).LinePtr );						
						add( @size( GosubRecord ), eax );
						mov( eax, GosubStackPtr );
						lea( edx, GosubStack[ @size(GosubStack)  ] );
						if( eax >= edx ) then
						
							stdout.put( nl "Too many nested GOSUBs" );
							AtLineNumber();
							raise( BasicError );
							
						endif;
						
						// Transfer control to the specified statement:
						
						mov( [ecx-4], edi );  // Get pointer into hash table.
						mov( (type tableNode [edi]).Value, edx );
						mov( (type Variant [edx]).l, ecx );
						
						// If the symbol is undefined, then the ".l" field
						// will contain NULL (set to NULL during the "compile"
						// phase).  Stop the program if the symbol is undefined.
						
						if( ecx = 0 ) then
						
							mov( [ebx+2], ax );
							stdout.put
							( 
								nl
								"GOSUB to undefined label ('",
								(type tableNode [edi]).id,
								"')"
							);
							AtLineNumber();
							raise( BasicError );
							
						endif;
						// Okay, the statement label exists.  Update all of
						// our pointers and begin execution of the new stmt.
						
						mov( ecx, ebx );
						lea( ecx, [ebx+4] ); // Point at 1st token on line.
						
						// Since we're not dropping down to the code that
						// handles new statements, check the DEBUG flag to
						// determine if we should print trace information.
						
						if( debugFlag ) then
						
							DoDebug( (type word [ebx+2]) );
							
						endif;						
						
							
												
					case( GOTOtkn )
					
						// Immediately following the GOTO token is the
						// address of the label's hash table entry.
						// Use that pointer to determine where the
						// target statement is in memory.
						
						mov( [ecx+1], edi );  // Get pointer into hash table.
						mov( (type tableNode [edi]).Value, edx );
						mov( (type Variant [edx]).l, ecx );
						
						// If the symbol is undefined, then the ".l" field
						// will contain NULL (set to NULL during the "compile"
						// phase).  Stop the program if the symbol is undefined.
						
						if( ecx = 0 ) then
						
							mov( [ebx+2], ax );
							stdout.put
							( 
								nl
								"GOTO undefined label ('",
								(type tableNode [edi]).id,
								"')"
							);
							AtLineNumber();
							raise( BasicError );
							
						endif;
						
						// Okay, the statement label exists.  Update all of
						// our pointers and begin execution of the new stmt.
						
						mov( ecx, ebx );
						lea( ecx, [ebx+4] ); // Point at 1st token on line.
						
						// Since we're not dropping down to the code that
						// handles new statements, check the DEBUG flag to
						// determine if we should print trace information.
						
						if( debugFlag ) then
						
							DoDebug( (type word [ebx+2]) );
							
						endif;						
						
						
						
						
					case( GOTOXYtkn )
					
						//	GOTOXY expr, expr
					
						inc( ecx );			// Skip the LOCATE token.
						EvalExpr( ecx );	// Get the x-coordinate value.
						MakeInt( al, "GOTOXY requires integer operands" );
						push( eax );
						inc( ecx );			// Skip the "," token.
						EvalExpr( ecx );	// Get the y-coordinate.
						MakeInt( al, "GOTOXY requires integer operands" );
						pop( edx );
						try
						
							win32cons.gotoxy( ax, dx );
							
						  anyexception
						  
						  	stdout.put( "Cursor position is out of range" );
							AtLineNumber();
							raise( BasicError );
							
						endtry;
							
												
					
					case( IFtkn )
					
						add( 5, ecx );		// Skip IFtkn
						EvalExpr( ecx );
						MakeInt
						( 
							al, 
							"IF requires an integer expression" 
						);
						
						mov( ExprStack.i, eax );
						if( !eax ) then
						
							// Expression is false, so transfer
							// control to the ELSE or ENDIF clause:
							
							mov
							( 
								(type dword (type StmtRec [ebx]).stmt[1]), 
								ebx 
							);
							lea( ecx, (type StmtRec [ebx]).stmt[1] );
							if( (type StmtRec [ebx]).stmt = ELSEtkn ) then
							
								add( 4, ecx );	// Skip target address.
								
							endif;
							
						else
						
							// Expression is true, so skip over
							// the THEN token and continue.
							
							inc( ecx );
							
						endif;
							




							

						
					
					
					
					
					case( INPUTtkn )
					
						//	INPUT var
						
						mov( [ecx+1], edx );	// Get ptr to var's table entry.
						add( 5, ecx );			// Skip input token.

						// Handle access of an array element here:
						
						ProcessIndex();
						Deallocate( edx );		// Free the data in the VAR.
						
						// Okay, this gets tricky because variables are
						// variant objects.  We have to try to read an
						// integer first;  if that fails, we have to try
						// to read a floating point number;  if that fails,
						// we read the line as a string.
						
						stdin.a_gets();
						mov( eax, InputStr );	// Save ptr to input line.
						mov( edx, VarPtr );
						push( ebx );
						push( ecx );
						try
						
							conv.strToi32( eax, 0 );
							
							// Success! We have an integer.  Store the
							// result away in the variable.
							
						  unprotected
						  
							mov( Integer_c, (type Variant [edx]).DataType );
							mov( eax, (type Variant [edx]).i );
							strfree( InputStr );
							
						  anyexception
						  
						  	// If it was a conversion error or an overflow
							// error, then let's try converting this to
							// a floating point value.  Otherwise, just
							// re-raise the exception.
							
						  	cmp( eax, ex.ConversionError );
							je TryFloat;
							cmp( eax, ex.ValueOutOfRange );
							je TryFloat;
							
								raise( eax );
								
							TryFloat:
							
								try
								
									conv.strToFlt( InputStr, 0 );
											
									// Success! We have a real.  Store the
									// result away in the variable.
									
								  unprotected
								  
								    mov( VarPtr, edx );
									mov
									( 
										Real_c, 
										(type Variant [edx]).DataType 
									);
									fstp( (type Variant [edx]).r );
									strfree( InputStr );
									
								  anyexception
								  
								  	// If it wasn't a conversion error
									// then something weird has happened,
									// so reraise the exception.
									
								  	if( eax <> ex.ConversionError ) then
									
										raise( eax );
										
									endif;
									
									// If it was a conversion error, then
									// let's just treat the input as a string
									// input.
									
								    mov( VarPtr, edx );
									mov
									( 
										String_c, 
										(type Variant [edx]).DataType 
									);
									mov( InputStr, eax );
									mov( eax, (type Variant [edx]).s );
									
								endtry;
								
								
						endtry;
						pop( ecx );
						pop( ebx );





					case( Labeltkn )
					
						// Just skip over the label:
						
						add( 5, ecx );
						
					
					case( LBRACKtkn )
					
						stdout.put( nl "Unexpected array index" );
						AtLineNumber();
						raise( BasicError );
							
						
					case( LETtkn )
					
						// LET representation in memory:
						//
						//	<LETtkn:1>
						//	<Pointer to Hash Table Entry:4>
						//	<< optional array index:0..n >>
						//	<< implied "=" token (i.e., not really present) >>
						//
						//	<< Encoding for expression >>

						add( 5, ecx );		// Skip LET token.

						// Save a pointer to the variable's value for later
						// use:
						
						mov( [ecx-4], edx );
						
						// Handle an array index, if present:
						
						ProcessIndex();
												
						// Okay, Evaluate the expression on the right hand
						// side of the "=" operator:
						
						pushd( edx );
						EvalExpr( ecx );
						pop( edi );
						
						// x86 TOS contains a pointer to variable.  Before
						// we do anything else, deallocate the storage
						// currently held by this variable.  
						
						Deallocate( edi );
						
						// Assign the value of the expression to the variable.
						
						mov( ExprStack.DataType, al );
						mov( al, (type Variant [edi]).DataType );
						
						// Cheap!  This code assumes that the data
						// area of a Variant type is no larger than
						// eight bytes.  Change this code if this
						// assumption is not true.
						
						mov( (type dword ExprStack.a), eax );
						mov( eax, (type dword (type Variant [edi]).a) );
						mov( (type dword ExprStack.a[4]), eax );
						mov( eax, (type dword (type Variant [edi]).a[4]) );						
					
					
					case( NEXTtkn )
					
						// First, make sure that we've got an active FOR
						// statement:
						
						mov( &ForStack, eax );
						if( eax = ForStackPtr ) then
						
							stdout.put( "NEXT without FOR" );
							AtLineNumber();
							raise( BasicError );
							
						endif;
						
						// Okay, we've got an active FOR loop, now let's
						// do the NEXT operation.  Begin by updating the
						// loop control variable.

						mov( ForStackPtr, edi );
						sub( @size( ForRecord ), edi );
						mov( (type ForRecord [edi]).VarAdrs, edx );
						mov( (type Variant [edx]).i, eax );
						add( (type ForRecord [edi]).Increment, eax );
						mov( eax, (type Variant [edx]).i );
						
						// To see if we must repeat this loop, we have
						// to execute different code for negative and
						// non-negative STEP values.
						
						if( (type ForRecord [edi]).Increment < 0 ) then
						
							// The STEP value is negative, so ensure
							// that the loop control variable is greater
							// than or equal to the Limit value.

							if( eax < (type ForRecord [edi]).Limit ) then
							
								// Don't execute this loop even once.
								// Immediately skip to the statement following
								// the NEXT <ID> clause.  Note that this may
								// be an intermediate NEXT, so we have to get
								// the address of the actual NEXT statement
								// for the FOR stack.
								
								mov( (type ForRecord [edi]).Line, ebx );
								mov( [ebx+5], ebx );	// Ptr to NEXT clause.
								lea( ecx, [ebx+9] );	// Skip over NEXT clause
								
								// Remove the ForRecord for this loop from
								// the FOR stack.
								
								mov( edi, ForStackPtr );

							else
							
								// Go back to the FOR loop and repeat
								
								mov( (type ForRecord [edi]).Stmt, ecx );
								mov( (type ForRecord [edi]).Line, ebx );
								
							endif;
							
						else 
						
							// The step value is non-negative.  Therefore,
							// we execute the body of the loop if the loop
							// control variable's value is less than or equal
							// to the final value.
							
							
							if( eax > (type ForRecord [edi]).Limit ) then
							
								// Don't execute this loop even once.
								// Immediately skip to the statement following
								// the NEXT <ID> clause:
								
								mov( (type ForRecord [edi]).Line, ebx );
								mov( [ebx+5], ebx );	// Ptr to NEXT clause.
								lea( ecx, [ebx+9] );	// Skip over NEXT clause.
								
								// Remove the ForRecord for this loop from
								// the FOR stack.
								
								mov( edi, ForStackPtr );

							else
							
								// Go back to the FOR loop and repeat
								
								mov( (type ForRecord [edi]).Stmt, ecx );
								mov( (type ForRecord [edi]).Line, ebx );
																
							endif;
							
						endif;
															
						
						
						 
					
					case( ONtkn )
					
						inc( ecx );			// Skip ONtkn.
						EvalExpr( ecx );
						MakeInt( al, "ON requires an integer expression" );
						if( (type ReservedWords [ecx]) = ONGOTOtkn ) then
						
							inc( ecx );		// Skip GOTO token.
							
							// Locate the specified label in the list, if
							// it exists:
							
							mov( ExprStack.i, eax );
							forever
							
								// Get the current token 
								// (label, stmtsep, endstmt).
								
								mov( [ecx], dl );
								if( eax = 0 ) then
								
									if( dl = IDtkn )
									then

										// Immediately following the
										// GOTO token is  a list of
										// label tokens. The address of
										// each label's hash table
										// entry. Use that pointer to
										// determine where the target
										// statement is in memory.
										
										// Get pointer into hash table.
										
										mov( [ecx+1], edi );
										
										// Get the pointer to the 
										// variable's entry.
										  
										mov( (type tableNode [edi]).Value, edx );
										mov( (type Variant [edx]).l, ecx );
										
										// If the symbol is undefined,
										// then the ".l" field will
										// contain NULL (set to NULL
										// during the "compile" phase).
										// Stop the program if the
										// symbol is undefined.
										
										if( ecx = 0 ) then
										
											mov( [ebx+2], ax );
											stdout.put
											( 
												nl
												"ON..GOTO to "
												"undefined label ('",
												(type tableNode [edi]).id,
												"')"
											);
											AtLineNumber();
											raise( BasicError );
											
										endif;
										
										// Okay, the statement label
										// exists.  Update all of our
										// pointers and begin execution
										// of the new stmt.
										
										mov( ecx, ebx );
										
										// Point at 1st token on line.
										
										lea( ecx, [ebx+4] ); 
										
										// Since we're not dropping
										// down to the code that
										// handles new statements,
										// check the DEBUG flag to
										// determine if we should print
										// trace information.
										
										if( debugFlag ) then
										
											DoDebug( (type word [ebx+2]) );
											
										endif;
										break;						
											
									endif;
									
																	
								elseif( dl <> IDtkn ) then
								
									stdout.put
									(
										nl
										"Internal error in ON..GOTO " 
										"Statement (byte=$",
										dl,
										")"
									);
									AtLineNumber();
									raise( BasicError );
								
								
								endif;
								
								// Move past the current label token.
								
								add( 5, ecx );
								breakif
								( 
									(type ReservedWords [ecx]) <> COMMAtkn 
								);
								inc( ecx ); // Skip comma token.
								dec( eax ); // Adjust for next item in list.
								
							endfor;
						
						elseif( (type ReservedWords [ecx]) = ONGOSUBtkn ) then

							inc( ecx );		// Skip GOSUB token.
							
							// Locate the specified label in the list, if
							// it exists:
							
							mov( ExprStack.i, eax );
							forever
							
								// Get the current token 
								// (label, stmtsep, endstmt).
								
								mov( [ecx], dl );
								if( eax = 0 ) then
								
									if( dl = IDtkn )
									then

										// Immediately following the
										// GOSUB token is  a list of
										// label tokens. The address of
										// each label's hash table
										// entry. Use that pointer to
										// determine where the target
										// statement is in memory.
										
										// Get pointer into hash table.
										
										mov( [ecx+1], edi );
										
										// Get the pointer to the 
										// variable's entry.
										  
										mov( (type tableNode [edi]).Value, edx );
										mov( (type Variant [edx]).l, edi );
										
										// If the symbol is undefined,
										// then the ".l" field will
										// contain NULL (set to NULL
										// during the "compile" phase).
										// Stop the program if the
										// symbol is undefined.
										
										if( edi = 0 ) then
										
											mov( [ebx+2], ax );
											stdout.put
											( 
												nl
												"ON..GOSUB to "
												"undefined label ('",
												(type tableNode [edi]).id,
												"')"
											);
											AtLineNumber();
											raise( BasicError );
											
										endif;
										
										// Okay, the statement label
										// exists.  Update all of our
										// pointers and call the specified
										// subroutine.  Begin by computing
										// the "return" address at the end
										// of this statement:
										
										dec( ecx );
										repeat
										
											add( 6, ecx );
											
										until
										( 
											(type ReservedWords [ecx]) <> 
												COMMAtkn
										);
										
										mov( GosubStackPtr, eax );
										mov
										( 
											ecx, 
											(type GosubRecord [eax]).RtnAdrs 
										);
										mov
										( 
											ebx, 
											(type GosubRecord [eax]).LinePtr 
										);
										add( @size( GosubRecord ), eax );
										mov( eax, GosubStackPtr );
										lea
										( 
											edx, 
											GosubStack[ @size(GosubStack)  ] 
										);
										if( eax >= edx ) then
										
											stdout.put
											( 
												nl "Too many nested GOSUBs" 
											);
											AtLineNumber();
											raise( BasicError );
											
										endif;
										
										// Transfer control to the specified 
										// statement:										
										
										mov( edi, ebx );
										
										// Point at 1st token on line.
										
										lea( ecx, [edi+4] ); 
										
										// Since we're not dropping down to
										// the code that handles new
										// statements, check the DEBUG flag
										// to determine if we should print
										// trace information.
										
										if( debugFlag ) then
										
											DoDebug( (type word [ebx+2]) );
											
										endif;						
										break;						
											
									endif;
									
																	
								elseif( dl <> IDtkn ) then
								
									stdout.put
									(
										nl
										"Internal error in ON..GOSUB " 
										"Statement (byte=$",
										dl,
										")"
									);
									AtLineNumber();
									raise( BasicError );
								
								
								endif;
								
								// Move past the current label token.
								
								add( 5, ecx );
								breakif
								( 
									(type ReservedWords [ecx]) <> COMMAtkn 
								);
								inc( ecx ); // Skip comma token.
								dec( eax ); // Adjust for next item in list.
								
							endfor;
							
						
						else

							stdout.put
							(
								nl
										"Internal error in ON..XXXX " 
										"Statement (byte=$",
										dl,
										")"
							);
							AtLineNumber();
							raise( BasicError );
						
						endif;						 
						
						
					case( PRINTtkn )
					
						// Temporary code for testing expressions.
						
						inc( ecx );		// Skip PRINTtkn
						repeat
						
							
							EvalExpr( ecx );
							if( al = Integer_c ) then
							
								stdout.puti32( (type Variant [esi]).i );
								
							elseif( al = Real_c ) then
					
								RealToStr( (type Variant [esi]).r );
								stdout.puts( eax );
								strfree( eax );
								
							elseif( al = String_c ) then
							
								stdout.puts( (type Variant [esi]).s );
								strfree((type Variant [esi]).s); 
								
							else
							
								stdout.put( "Data type error in print", nl );
								raise( BasicError );
								
							endif;
							
							mov( (type ReservedWords [ecx]), al );
							if( al = COMMAtkn ) then
							
								stdout.put( stdio.tab );
								inc( ecx );
								mov( (type ReservedWords [ecx]), al );
								
							elseif( al = SEMICOLONtkn ) then
							
								inc( ecx );
								mov( (type ReservedWords [ecx]), al );
								
								
							endif;
								
							// Note: the following code depends upon the
							// fact that StmtSepTkn's value is one and
							// StmtEndTkn's value is zero.
							
							if( al <= StmtSeptkn ) then
							
								cmp( (type ReservedWords [ecx-1]), COMMAtkn );
								je NoNewLn;
								cmp((type ReservedWords [ecx-1]), SEMICOLONtkn);
								je NoNewLn;
								stdout.newln();
							  
							  NoNewLn:
							  
							  
							endif;
							
						until( al <= StmtSeptkn );								

							

					case( REMtkn )
					
						// Treat the REM token like the end of the line.
						
						exit EachStmt;
				

					case( RETURNtkn )
					
						mov( GosubStackPtr, eax );
						if( eax = &GosubStack ) then
						
							stdout.put
							(
								nl
								"RETURN without GOSUB"
							);
							AtLineNumber();
							raise( RtnWOGosubException );
							
						endif;
						sub( @size( GosubRecord ), eax );
						mov( eax, GosubStackPtr );
						mov( (type GosubRecord [eax]).RtnAdrs, ecx );
						mov( (type GosubRecord [eax]).LinePtr, ebx );						
							
												
					case( StmtEndtkn )
					
						// Okay, conversion is done.  
						// Move on to the next stmt.
						
						exit EachStmt;
				

					case( StmtSeptkn )
					
						// If we come across a statement separator, just
						// skip over it.
						
						inc( ecx );
				

					case( STOPtkn )
					
						push( ColorsCurrent );
						call win32cons.setOutputAttr;
						stdout.put( nl "STOP" );
						AtLineNumber();
						raise( PgmStopException );
						
						
					case( WAITtkn )
					
						inc( ecx );			// Skip WAIT token
						EvalExpr( ecx );	// Get sleep time.
						MakeInt
						( 
							al, 
							"WAIT requires an integer expression" 
						);
						pushad();
						cld();
						Sleep( ExprStack.i );
						popad();						
						
						
	
					default

						stdout.put( "Unexpected token: $", al );
						AtLineNumber();
						raise( BadPgmDataException );
					
				endswitch;
				
			endfor;
			
		end EachStmt;
		
		// We just finished executing a line of statements.
		// Now move on to the next statement, if one exists.
		
		movzx( (type StmtRec [ebx]).size, eax );
		add( eax, ebx );
		breakif( ebx >= TxtEnd );		
		if( debugFlag ) then
		
			DoDebug( (type word [ebx+2]) );
			
		endif;						
	
	endfor;
	popad();
	
end RunProc;




///////////////////////////////////////////////////////////////////////////////
//
//	Edit-Time Stuff (not particularly time critical)
//
///////////////////////////////////////////////////////////////////////////////


/*********************************************************************/
/*                                                                   */
/* Detokenize-                                                       */
/*                                                                   */
/* Converts a tokenize statement to a string for output.             */
/*                                                                   */
/* linePtr- address of a BASIC statement (starting with size field). */
/* destStr- location to store detokenized result.                    */
/*                                                                   */
/*********************************************************************/

procedure Detokenize( linePtr:dword; destStr:string ); @nodisplay;


	// DetokenizeItem-
	//
	//	Translates a single token into string form.
	
	procedure DetokenizeItem( token:dword in eax );  @nodisplay;  @noframe;
	begin DetokenizeItem;


		switch( eax )
		
			case( StmtEndtkn )
			
				// Okay, conversion is done.  Bail on this code.
				
				ret();
		
			case( StmtSeptkn )
			
				str.cat2( " : ", ebp::destStr );
				inc( esi );
		
			case( ACOSftkn )
			
				str.cat2( "acos", ebp::destStr );
				inc( esi );
				
			case( ASCftkn )
			
				str.cat2( "asc", ebp::destStr );
				inc( esi );
				
			case( ANDtkn )
			
				str.cat2( " AND ", ebp::destStr );
				inc( esi );
				
			case( ASINftkn )
			
				str.cat2( "asin", ebp::destStr );
				inc( esi );
				
			case( ATANftkn )
			
				str.cat2( "atan", ebp::destStr );
				inc( esi );
				
			case( BEEPtkn )
			
				str.cat2( "beep ", ebp::destStr );
				inc( esi );
				
			case( CHRftkn )
			
				str.cat2( "chr", ebp::destStr );
				inc( esi );
				
				
			case( CLStkn )
			
				str.cat2( "cls ", ebp::destStr );
				inc( esi );
				
			case( COLORtkn )
			
				str.cat2( "color ", ebp::destStr );
				inc( esi );
				
			case( COMMAtkn )
			
				str.cat2( ", ", ebp::destStr );
				inc( esi );
				
			case( COSftkn )
			
				str.cat2( "cos", ebp::destStr );
				inc( esi );

			case( DEBUGtkn )
			
				str.cat2( "debug ", ebp::destStr );
				inc( esi );
				
			case( DIMtkn )
			
				str.cat2( "dim", ebp::destStr );
				inc( esi );
				
			case( DIVtkn )
			
				str.cat2( " / ", ebp::destStr );
				inc( esi );
				
			case( ELSEtkn )
			
				str.cat2( "else ", ebp::destStr );
				add( 5, esi );
				
				
				
			case( ENDIFtkn )
			
				str.cat2( "endif ", ebp::destStr );
				inc( esi );
				
				
				
			case( EQtkn )
			
				str.cat2( " = ", ebp::destStr );
				inc( esi );
				
			case( EXPftkn )
			
				str.cat2( "exp", ebp::destStr );
				inc( esi );
				
			case( FLTtkn )
			
				add( 9, esi );	// Skip token and binary representation.
				
				movzx( (type byte [esi]), ecx );	// Get string length.
				mov( ecx, eax );					// Save length for later.

				push( esi );
				inc( esi );							// Skip length byte.
				
				// Compute the concatenation point 'cause we're going to
				// have to manually concatenate the label to the end of
				// our string:
				
				mov( ebp::destStr, edi );
				add( (type str.strRec [edi]).length, edi );
				
				// Concatenate the string representation of the FP value
				
				rep.movsb();
				
				mov( 0, (type byte [edi]) );
				
				// Adjust the string according to the size of the
				// real value we just concatenated:
				
				mov( ebp::destStr, edi );
				add( eax, (type str.strRec [edi]).length );
	
				pop( esi );
				lea( esi, [esi+eax+1] );
								
			
			case( FORtkn )
			
				str.cat2( "for ", ebp::destStr );
				mov( [esi + 5], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				str.cat2( " = ", ebp::destStr );
				add( 9, esi );


			case( GEtkn )
			
				str.cat2( " >= ", ebp::destStr );
				inc( esi );
				
			case( GETtkn )
			
				str.cat2( "get ", ebp::destStr );
				mov( [esi + 1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				add( 5, esi );
				
			case( GOSUBtkn )
			
				str.cat2( "gosub ", ebp::destStr );
				mov( [esi + 1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				add( 5, esi );
				
			case( GOTOtkn )
			
				str.cat2( "goto ", ebp::destStr );
				mov( [esi + 1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				add( 5, esi );
				
			case( GTtkn )
			
				str.cat2( " > ", ebp::destStr );
				inc( esi );
				
			case( IDtkn )
			
				mov( [esi+1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				add( 5, esi );
				
			case( IFtkn )
			
				str.cat2( "if", ebp::destStr );
				add( 5, esi );
				
			case( INPUTtkn )
			
				str.cat2( "input ", ebp::destStr );
				mov( [esi + 1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				add( 5, esi );

				
			case( INTftkn )
			
				str.cat2( "int", ebp::destStr );
				inc( esi );
				
				
				
			case( INTtkn )
			
				str.cati32( (type dword [esi+1]), ebp::destStr );
				add( 5, esi );

				
			case( Labeltkn )
			
				mov( [esi+1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				str.cat2( ": ", ebp::destStr );
				add( 5, esi );				


				
			case( LBRACKtkn )
			
				str.cat2( "[ ", ebp::destStr );
				inc( esi );
				
			case( LEtkn )
			
				str.cat2( " <= ", ebp::destStr );
				inc( esi );
				
			case( LEFTftkn )
			
				str.cat2( "left", ebp::destStr );
				inc( esi );
				
			case( LENftkn )
			
				str.cat2( "len", ebp::destStr );
				inc( esi );
				
			case( LETtkn )
			
				str.cat2( "let ", ebp::destStr );
				mov( [esi + 1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				add( 5, esi );
				
				// If there's a "[" token then process array indices:

				while( (type byte [esi]) = LBRACKtkn ) do
				
					str.cat2( "[ ", ebp::destStr );
					inc( esi );
					while( (type byte [esi]) <> RBRACKtkn ) do

						
						DetokenizeItem( movzx( (type byte [esi]), eax ) );
						
					endwhile;
					str.cat2( " ]", ebp::destStr );
					inc( esi );

				endwhile;
				str.cat2( " = ", ebp::destStr );

				
			case( GOTOXYtkn )
			
				str.cat2( "gotoxy ", ebp::destStr );
				inc( esi );
				
			case( LOGftkn )
			
				str.cat2( "log", ebp::destStr );
				inc( esi );
				
			case( LPARENtkn )
			
				str.cat2( "( ", ebp::destStr );
				inc( esi );
				
			case( LTtkn )
			
				str.cat2( " < ", ebp::destStr );
				inc( esi );
				
			case( MIDftkn )
			
				str.cat2( "mid", ebp::destStr );
				inc( esi );
				
			case( MINUStkn )
			
				str.cat2( " - ", ebp::destStr );
				inc( esi );
				
			case( MODtkn )
			
				str.cat2( " % ", ebp::destStr );
				inc( esi );
				
			case( MULtkn )
			
				str.cat2( " * ", ebp::destStr );
				inc( esi );
				
			case( NEtkn )
			
				str.cat2( " <> ", ebp::destStr );
				inc( esi );
				
			case( NEXTtkn )
			
				str.cat2( "next ", ebp::destStr );
				inc( esi );

				
			case( NOTtkn )
			
				str.cat2( " NOT ", ebp::destStr );
				inc( esi );
				
			case( ONtkn )
			
				str.cat2( "on ", ebp::destStr );
				inc( esi );
				
				
			case( ONGOSUBtkn )
			
				str.cat2( " gosub ", ebp::destStr );
				inc( esi );
				
				
			case( ONGOTOtkn )
			
				str.cat2( " goto ", ebp::destStr );
				inc( esi );
				
			case( ORtkn )
			
				str.cat2( " OR ", ebp::destStr );
				inc( esi );
				
			case( PLUStkn )
			
				str.cat2( " + ", ebp::destStr );
				inc( esi );
				
			case( PRINTtkn )
			
				str.cat2( "print ", ebp::destStr );
				inc( esi );

				
			case( RANDOMIZEftkn )
			
				str.cat2( "randomize", ebp::destStr );
				inc( esi );
				
				
			case( RBRACKtkn )
			
				str.cat2( " ]", ebp::destStr );
				inc( esi );
				
				
			case( READLNtkn )
			
				str.cat2( "readln ", ebp::destStr );
				mov( [esi + 1], eax );
				str.cat2( (type tableNode [eax]).id, ebp::destStr );
				add( 5, esi );
				
				

			case( REMtkn )
			
				inc( esi );	// Skip token.
				str.cat2( "rem", ebp::destStr );
				
				movzx( (type byte [esi]), ecx );	// Get string length.
				mov( ecx, eax );					// Save length for later.

				push( esi );
				inc( esi );							// Skip length byte.
				
				// Compute the concatenation point 'cause we're going to
				// have to manually concatenate the comment to the end of
				// our string:
				
				mov( ebp::destStr, edi );
				add( (type str.strRec [edi]).length, edi );
				
				// Concatenate the comment to our output string:
				
				rep.movsb();
				
				mov( 0, (type byte [edi]) );
				
				// Adjust the string according to the size of the
				// real value we just concatenated:
				
				mov( ebp::destStr, edi );
				add( eax, (type str.strRec [edi]).length );
	
				pop( esi );
				lea( esi, [esi+eax+1] );
				
				
			case( RETURNtkn )
			
				str.cat2( "return ", ebp::destStr );
				inc( esi );
				
				
			case( RIGHTftkn )
			
				str.cat2( "right", ebp::destStr );
				inc( esi );
				
			case( RNDftkn )
			
				str.cat2( "rnd", ebp::destStr );
				inc( esi );
				
			case( ROUNDftkn )
			
				str.cat2( "round", ebp::destStr );
				inc( esi );
				
			case( RPARENtkn )
			
				str.cat2( " )", ebp::destStr );
				inc( esi );
				
			case( SEMICOLONtkn )
			
				str.cat2( "; ", ebp::destStr );
				inc( esi );
				
			case( SINftkn )
			
				str.cat2( "sin", ebp::destStr );
				inc( esi );
				
			case( SQRTftkn )
			
				str.cat2( "sqrt", ebp::destStr );
				inc( esi );
				
			case( STRtkn )
			
				inc( esi );
				movzx( (type byte [esi]), ecx );	// Get String length
				inc( esi );
				str.catc( ebp::destStr, '"'  );
				while( ecx > 0 ) do
				
					mov( [esi], al );
					str.catc( ebp::destStr, al );
					if( al = '"' ) then
					
						str.catc( ebp::destStr, al );
						
					endif;
					dec( ecx );
					inc( esi );
					
				endwhile;
				str.catc( ebp::destStr, '"'  );
				


			case( STRftkn )
			
				str.cat2( "str", ebp::destStr );
				inc( esi );
				
			case( STEPtkn )
			
				str.cat2( " step ", ebp::destStr );
				inc( esi );
				
			case( STOPtkn )
			
				str.cat2( "stop ", ebp::destStr );
				inc( esi );
				
				
			case( TANftkn )
			
				str.cat2( "tan", ebp::destStr );
				inc( esi );
				
			case( THENtkn )
			
				str.cat2( " then ", ebp::destStr );
				inc( esi );
				
				
			case( TOtkn )
			
				str.cat2( " to ", ebp::destStr );
				inc( esi );
				
				
			case( VALftkn )
			
				str.cat2( "val", ebp::destStr );
				inc( esi );
				
			case( WAITtkn )
			
				str.cat2( "wait ", ebp::destStr );
				inc( esi );
				
			default
			
				stdout.put( "Unexpected token = 0x", (type byte [esi]), nl );
				raise( BadPgmDataException );
			
		endswitch;
		ret();
	
	end DetokenizeItem;
	
	
begin Detokenize;

	pushad();
	
	mov( linePtr, esi );
	add( 4, esi );			// Skip the overhead bytes.
	
	forever
	
		movzx( (type byte [esi]), eax );	// Get the next token.
		breakif( al = StmtEndtkn );
		DetokenizeItem( eax );
		
	endfor;
	popad();

end Detokenize;






/**********************************************************/
/*                                                        */
/* ListProc-                                              */
/*                                                        */
/* Lists all the lines between the specified starting and */
/* ending line numbers:                                   */
/*                                                        */
/**********************************************************/



procedure ListProc( start:uns16; stop:uns16; handle:dword ); @nodisplay;
static
	LineStr:	str.strvar( 1024 );
	
begin ListProc;

	pushad();

	
	// Locate the first line specified by the LIST command:
	
	FindLine( TxtStart, start );
	
	// From that line to the end of the listing, or to the
	// last line specified, print the lines in the program:
	
	while( edx < TxtEnd ) do
	
	
		// Bail if the current line number is greater than
		// the "stop" line number parameter:
		
		mov( (type StmtRec [edx]).lineNum, ax );
		breakif( ax > stop );

		// Print the line number, the necessary number of spaces,
		// and the text associated with this line:
		
		fileio.put( handle, (type uns16 ax ):5);
		
		// Always output at least one space, but also output
		// the number of spaces that originally appeared between
		// the line number and the start of the statement:
		
		movzx( (type StmtRec [edx]).leading, eax );
		fileio.putcSize( handle, ' ', eax, ' ' );
		
		// Detokenize the statement and produce a string to output:
		
		str.cpy( "", LineStr );
		Detokenize( edx, LineStr );
		
		// Okay, output the text associated with this statement.
		
		fileio.puts( handle, LineStr );
		fileio.newln( handle );
		
		// Adjust EDX so it points at the next line in the program:
		
		movzx( (type StmtRec [edx]).size, eax );
		add( eax, edx );

	endwhile;
	
	strfree( LineStr );
	popad();

end ListProc;


/*********************************************************************/
/*                                                                   */
/* ParseLine-                                                        */
/*                                                                   */
/* This procedure is passed two strings:  LineNumberStr and LineStr. */
/* They contain the two components of a line that modifies the       */
/* source program, e.g.,                                             */
/*                                                                   */
/* xxxxx   sssss ssss ssss sss sss ssss                              */
/*                                                                   */
/* xxxxx = a string of decimal digits representing the line number.  */
/*                                                                   */
/* ss..sss = the remainder of the text on the line (possibly empty). */
/*                                                                   */
/* This procedure deletes the specified line if LineStr is the empty */
/* string;  it replaces the specified line with the new text if a    */
/* line with the specified line number already exists;  this         */
/* procedure inserts the line into the program if a line with that   */
/* number does not already exist.                                    */
/*                                                                   */
/*********************************************************************/

namespace pat;

	// A pattern matching function that matches the end of
	// a BASIC statement.  This will skip all spaces until
	// it finds a ":" or the end of the string (where EDI points).
	// This function does not support backtracking as it must only
	// be called as the last pattern function in a sequence.
	
	procedure endStmt; @nodisplay; @noframe;
	begin endStmt;

		// Okay, match a single char.
		
		push( esi );		// Preserve ESI's value for success/failure.
		dec( esi );
		SkipSpcs:
			inc( esi );
			cmp( esi, edi );
			je	Succeed;
			cmp( (type char [esi]), ' ' );
			je SkipSpcs;
			
		// If we stopped on a ":" then we succeed,
		// else we fail.
		
		cmp( (type char [esi]), ':' );
		je Succeed;

			// If we get down here, we didn't match.  
			// So transfer control to the previous 
			// routine that supported backtracking.
			
			pop( esi );			// Must restore ESI on failure.
			_fail_( FailTo );		

		
		// Since this routine doesn't have to handle backtracking,
		// a simple return indicates success.

		Succeed:
			pop( ebx );			// Return original ESI value in EBX
			ret();
			
	end endStmt;
	
	
	
	
end pat;


procedure ParseLine( LineNumberStr:string; LineStr: string ); @nodisplay;
static
	identifier:		string;
	index:			dword;
	nextIndex:		dword;
	parseIndex:		dword;
	listIndex1:		dword;
	listIndex2:		dword;
	StartOfID:		dword;
	StartOfNum:		dword;
	saveEBX:		dword;
	CurLineNum:		uns16;
	LeadingSpaces:	uns8;
	GoodExpr:		boolean;
	LineBuffer:		byte[256];
	
readonly
	idSet:cset := {'a'..'z', 'A'..'Z', '0'..'9', '_'};
	
	
	//////////////////////////////////////////////////////
	//
	// PutToken- Emits a token to the output stream.

	procedure PutToken( TokenValue:byte in al ); @nodisplay; @noframe;
	begin PutToken;
	
		push( ebx );
		
		mov( index, ebx );
		mov( al, LineBuffer[ ebx ] );
		inc( index );
						 
		pop( ebx );
		ret( 0 );
		
	end PutToken;
	
	
	
	//////////////////////////////////////////////////////
	//
	// Expression- Parses an arithmetic expression.
	// Note: we don't actually evaluate expressions here,
	// so we don't have to worry about operator precedence.
	
	procedure Expression
	( 
		start:dword in esi; 
		endstr:dword in edi
	);	@nodisplay; @noframe;
	
	
		// SkipSpcs-
		//
		//	This function skips over leading spaces that ESI points at.
		
		procedure SkipSpcs; @nodisplay; @noframe;
		begin SkipSpcs;
		
			dec( esi );
			repeat
			
				inc( esi );
			
			until( (type char [esi]) <> ' ' );
			ret();
				
		end SkipSpcs;
		
		//////////////////////////////////////////////////////
		//
		// matchNeg-
		//
		//	This function matches a leading minus sign.
		//  It returns true in AL if it finds a '-',
		//	false otherwise.  It also emits the MINUStkn
		//	token to the output stream if it finds a '-' character.
		
		procedure matchNeg; @nodisplay; @noframe; @returns( "al" );
		begin matchNeg;
		
			SkipSpcs();
			mov( false, al );
			if( (type char [esi]) = '-' ) then
			
				push( ebx );
				mov( index, ebx );
				mov( MINUStkn, LineBuffer[ ebx ] );
				inc( index );
				pop( ebx );
				inc( esi );
				mov( true, al );
				
			endif;
			ret();
			
		end matchNeg;
		
		
		//////////////////////////////////////////////////////
		//
		// matchNot-
		//
		//	This function matches a leading NOT operator.
		//  It returns true in AL if it finds a NOT,
		//	false otherwise.  It also emits the NOTtkn
		//	token to the output stream if it finds a NOT operator.
		
		procedure matchNot; @nodisplay; @noframe; @returns( "al" );
		begin matchNot;
		
			SkipSpcs();
			mov( esi, ebx );
			mov( false, ah );
			chars.toUpper( [esi] );
			if( al = 'N' ) then
			
				chars.toUpper( [esi+1] );
				if( al = 'O' ) then
				
					chars.toUpper( [esi+2] );
					if( al = 'T' ) then
					
						mov( [esi+3], al );
						if
						( 
							al not in {'a'..'z', 'A'..'Z', '0'..'9', '_' } 
						) then
						
							push( ebx );
							mov( index, ebx );
							mov( NOTtkn, LineBuffer[ ebx ] );
							inc( index );
							pop( ebx );
							mov( true, ah );
							add( 3, esi );
							
						endif;
						
					endif;
					
				endif;
				
			endif;
			mov( ah, al );
			ret();
			
		end matchNot;
		
		
		//////////////////////////////////////////////////////
		//
		// GetParenExpr-
		//
		//	Matches and processes an expression surrounded by
		//	parentheses.  The parameters specify the minimum number
		//	of allowable expressions and the maximum number.  If this
		//	is greater than one, the expressions must be comma separated.
		
		procedure GetParenExpr
		( 
			MinExprs:uns32 in ECX;
			MaxExprs:uns32 in EDX
		); @nodisplay; @noframe;

		const
			NumExprs:text := "ebx";
			
		begin GetParenExpr;
		
			SkipSpcs();
			if( (type char [esi]) <> '(' ) then
			
				stdout.put( "Syntax error in function call" nl );
				raise( ExprSyntaxException );
				
			endif;
			PutToken( LPARENtkn );
			inc( esi );
			
			mov( 0, NumExprs );			
			forever
			
				push( ebx );
				push( ecx );
				push( edx );
				Expression( esi, edi );
				pop( edx );
				pop( ecx );
				pop( ebx );

				
				SkipSpcs();
				inc( NumExprs );
				breakif( NumExprs >= MaxExprs );
				if( (type char [esi]) <> ',' ) then
				
					breakif( eax >= MinExprs ); 
					stdout.put
					( 
						"Syntax error (expected ',') or insufficient "
						"number of parameters"
						nl
					);
					raise( ExprSyntaxException );
					
				endif;
				PutToken( COMMAtkn );
				inc( esi );
				
			endfor;
			
			SkipSpcs();
			if( (type char [esi]) <> ')' ) then
			
				stdout.put
				( 
					"Expected a closing parenthesis " 
					"(too many parameters?)"
					nl 
				);
				raise( ExprSyntaxException );
				
			endif;
			PutToken( RPARENtkn );
			inc( esi );
			ret();
		
		end GetParenExpr;
		
		
		
		
		//////////////////////////////////////////////////////
		//
		// GetBracketExpr-
		//
		//	Matches and processes an expression surrounded by
		//	brackets.
		
		procedure GetBracketExpr; @nodisplay; @noframe;

		const
			NumExprs:text := "ebx";
			
		begin GetBracketExpr;
		
			if( (type char [esi]) <> '[' ) then
			
				stdout.put( "Syntax error in array index" nl );
				raise( ExprSyntaxException );
				
			endif;
			PutToken( LBRACKtkn );
			inc( esi );
			
			push( ebx );
			push( ecx );
			push( edx );
			Expression( esi, edi );
			pop( edx );
			pop( ecx );
			pop( ebx );
			
			SkipSpcs();
			if( (type char [esi]) <> ']' ) then
			
				stdout.put
				( 
					"Expected a closing bracket" 
					nl 
				);
				raise( ExprSyntaxException );
				
			endif;
			PutToken( RBRACKtkn );
			inc( esi );
			ret();
		
		end GetBracketExpr;
		
		
		//////////////////////////////////////////////////////
		//
		// matchID-
		//
		//	Matches an identifier and returns true/false in
		//	AL depending on the comparison.  Identifiers always
		//	begin with an alpha char and following chars may
		//	be alphanumeric or underscore.
		
		procedure matchID; @nodisplay; @noframe; @returns( "al" );
		begin matchID;			
			
			SkipSpcs();
			mov( esi, ebx );
			mov( [esi], al );
			if( al in {'a'..'z', 'A'..'Z'} ) then
			
				repeat
				
					mov( [esi], al );
					breakif( al not in idSet );
					inc( esi );
					
				until( esi >= edi );
				
				// Copy EBX..ESI to identifier:
				
				pat.extract( identifier );
				
				// See if it's a built-in function here.
				
				if( str.ieq( identifier, "asc" )) then
				
					PutToken( ASCftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "acos" )) then
				
					PutToken( ACOSftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "asin" )) then
				
					PutToken( ASINftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "atan" )) then
				
					PutToken( ATANftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "chr" )) then
				
					PutToken( CHRftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "cos" )) then
				
					PutToken( COSftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "dim" )) then
				
					PutToken( DIMtkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "exp" )) then
				
					PutToken( EXPftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "int" )) then
				
					PutToken( INTftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "left" )) then
				
					PutToken( LEFTftkn );
					GetParenExpr( 2, 2 );
					
				elseif( str.ieq( identifier, "len" )) then
				
					PutToken( LENftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "log" )) then
				
					PutToken( LOGftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "mid" )) then
				
					PutToken( MIDftkn );
					GetParenExpr( 3, 3 );
					
				elseif( str.ieq( identifier, "randomize" )) then
				
					PutToken( RANDOMIZEftkn );
					
				elseif( str.ieq( identifier, "rnd" )) then
				
					PutToken( RNDftkn );
					
				elseif( str.ieq( identifier, "right" )) then
				
					PutToken( RIGHTftkn );
					GetParenExpr( 2, 2 );
					
				elseif( str.ieq( identifier, "round" )) then
				
					PutToken( ROUNDftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "sin" )) then
				
					PutToken( SINftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "sqrt" )) then
				
					PutToken( SQRTftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "str" )) then
				
					PutToken( STRftkn );
					GetParenExpr( 1, 3 );
					
				elseif( str.ieq( identifier, "tan" )) then
				
					PutToken( TANftkn );
					GetParenExpr( 1, 1 );
					
				elseif( str.ieq( identifier, "val" )) then
				
					PutToken( VALftkn );
					GetParenExpr( 1, 1 );
					
				else				
				
					// Okay, we've got a valid ID.  Emit the
					// token for it.

					push( esi );	// Must save because of method invocation.
					push( edi );
					
					mov( index, edx );
					mov( IDtkn, LineBuffer[ edx ] );
					Vars.getNode( identifier );
					mov( eax, (type dword LineBuffer[ edx+1 ]));
					add( 5, index );
					
					pop( edi );
					pop( esi );
					
					SkipSpcs();
					while( (type char [esi]) = '[' ) do
					
						GetBracketExpr();
						
					endwhile;
					
					mov( true, al );
					
				endif;
				
			else
			
				mov( false, al );
				mov( ebx, esi );	// Must restore ESI on failure.
				
			endif;
			ret();
			
		end matchID;
		
		
		
		//////////////////////////////////////////////////////
		//
		// matchIntConst-
		//
		//	Matches an integer constant and returns true/false in
		//	AL depending on the comparison.  Integer constants always
		//	contain decimal digits.
		//
		//	Comparison stops successfully on the first non-digit.
		//	You must call matchFltConst prior to calling matchIntConst
		//	if you need to differentiate between integer and floating
		//	point constants.
		
		
		procedure matchIntConst; @nodisplay; @noframe; @returns( "al" );
		begin matchIntConst;
		
			SkipSpcs();
			mov( esi, ebx );
			mov( [esi], al );
			if( al in {'0'..'9'} ) then
			
				repeat
				
					mov( [esi], al );
					breakif( al not in idSet );
					inc( esi );
					
				until( esi = edi );
				
				// Copy EBX..ESI to identifier:
				
				pat.extract( identifier );
				
				// Convert to an integer value:
				
				try
				
					conv.strToi32( identifier, 0 );
					
				  exception( ex.ValueOutOfRange )
				  
				  	stdout.put( "Integer constant too large" nl );
					raise( ExprSyntaxException );
					
				endtry;
				mov( index, ebx );
				mov( INTtkn, LineBuffer[ ebx ] );
				mov( eax, (type dword LineBuffer[ ebx+1 ]));
				add( 5, index );
				
				mov( 1, al );
				
			else
			
				mov( 0, al );
				mov( ebx, esi );	// Must restore ESI on failure.
				
			endif;
			ret();
			
		end matchIntConst;
		
		
		//////////////////////////////////////////////////////
		//
		// matchFltConst-
		//
		//	Matches a real constant and returns true/false in
		//	AL depending on the comparison.  Real constants always
		//	contain decimal digits, an optional decimal point,
		//	and an optional exponent. However, real constants must
		//	contain either a decimal point, and exponent, or both.
		
		
		procedure matchFltConst; @nodisplay; @noframe; @returns( "al" );
		begin matchFltConst;
		
			// Save the starting position.
			// If we fail we must return this in ESI.
			// If we succeed, we must return this in EBX.
			
			SkipSpcs();
			push( esi );

			
			// The following value on the stack is a boolean
			// variable to determine if we've matched an FP
			// value.
			
			pushd( false );		// Assume failure.
			
			// The number has to begin with a digit:
			
			mov( [esi], al );
			if( al in '0'..'9' ) then
			
				// Get the digits before the decimal point:
				
				repeat
				
					inc( esi );
					breakif( esi >= edi );
					mov( [esi], al );
					
				until( al not in '0'..'9' );
				
				// Get the optional decimal point and any digits
				// after the decimal point:
				
				if( al = '.' ) then
				
					// If we've seen a decimal point, it's a floating
					// point value, so set the flag to true.
					
					mov( true, (type boolean [esp]));
					
					// Grab any digits after the decimal point.
					// Note that the first INC skips the decpt.
					
					repeat
					
						inc( esi );
						breakif( esi >= edi );
						mov( [esi], al );
						
					until( al not in '0'..'9' );
					
				endif;
				
				// Get the optional exponent:

				mov( [esi], al );
				chars.toUpper( al );
				if( al = 'E' ) then
				
					mov( true, (type boolean [esp]));	// Note it's float.
					mov( [esi+1], al );
					if( al = '+' ) then
					
						inc( esi );
						
					elseif( al = '-' ) then
					 
						inc( esi );
						
					endif;
					
					// Get the exponent digits:
					// Note that the first INC skips the 'E' or the
					// sign character.
					//
					// If we had an "e" but we don't have at least
					// one valid decimal digit, then we've got an
					// error.
					
					inc( esi );
					mov( [esi], al );
					if( al not in '0'..'9' ) then
					
						stdout.put( "Illegal real constant" nl );
						raise( ExprSyntaxException );
						
					endif;
					
					repeat
					
						inc( esi );
						breakif( esi >= edi );
						mov( [esi], al );
						
					until( al not in '0'..'9' );
					
				endif;
				
			endif;
			
			// Check boolean flag to see if we have
			// a legal floating point value (as opposed to
			// just an integer):
			
			
			pop( eax );
			pop( ebx );		// Retrieve start of sequence pointer.
			push( ebx );	// Save for later restore.
			if( al ) then
			
			
				pat.extract( identifier );
				try
				
					conv.strToFlt( identifier, 0 );
					
				  anyexception
				  
				  	stdout.put( "Error in floating point value" nl );
					raise( ExprSyntaxException );
					
				endtry;
				
				// Okay, we've got a legal floating point constant.
				// Emit the token for it.  Note: the token for
				// a float constant takes the following form:
				//
				// <token> <8-byte binary rep> <strlen><string rep>
				//
				// Rather long, but we need the binary representation
				// for fast execution and we need the string representation
				// for listings (so we always display what the user entered).
				//
				// Emit the FLTtkn byte:
				
				mov( index, ebx );
				mov( FLTtkn, LineBuffer[ ebx ] );
				
				// Now store away the binary representation:
				
				fstp( (type real64 LineBuffer[ ebx+1 ]));
				add( 9, ebx );
				
				// Finally, copy away the string representation:
				
				mov( identifier, eax );  // String representation is here.
				mov( (type str.strRec [eax]).length, ecx );
				mov( cl, LineBuffer[ ebx ] );
				inc( ebx );
				
				push( esi );
				push( edi );
				
				cld();
				lea( edi, LineBuffer[ ebx ] );
				mov( identifier, esi );
				add( ecx, ebx );
				rep.movsb();
				
				mov( ebx, index );
				pop( edi );
				pop( esi );			

				mov( true, al );	// Return success!
				
			else
			
				mov( false, al );	// Return failure.
				mov( ebx, esi );	// Must restore ESI on failure.
				
			endif;				
			pop( ebx );
			ret();
			
		end matchFltConst;
		
		

		//////////////////////////////////////////////////////
		//
		// matchTerm-
		//
		// Match IDs, constants, function calls, and 
		// parenthetical expressions.
		//
		// Returns true/false in AL depending on the match operation.
		
		procedure matchTerm; @nodisplay; @noframe; @returns( "al" );
		begin matchTerm;
		
			push( esi );		// Put this in EBX if we succeed.
			
			// Sneak in check for unary '-' and "NOT" here:

			repeat
			
				if( matchNeg() ) then
				
					matchNot();
					mov( true, al );
					
				else
				
					matchNot();
					
				endif;
				
			until( !al );

			SkipSpcs();

			// Check for parenthetical expressions.
			
			if( (type char [esi]) = '(' ) then
			
				PutToken( LPARENtkn );
				inc( esi );
				Expression( esi, edi );

				
				SkipSpcs();
				if( (type char [esi]) <> ')' ) then
				
					stdout.put( "Expected a closing parenthesis" nl );
					raise( ExprSyntaxException );
					
				endif;
				PutToken( RPARENtkn );
				inc( esi );


			// Check for string constants:
			
			elseif( (type char [esi]) = '"' ) then
			
				PutToken( STRtkn );
				inc( esi );
				
				mov( index, edx );	// Output string here.
				mov( edx, ebx );		// Ptr to length byte;
				inc( edx );				// make room for length byte.
				forever
				
					if( esi = edi ) then
					
						stdout.put( "Unterminated string constant" nl );
						raise( ExprSyntaxException );
					
					endif;
					mov( [esi], al );
					if( al = '"' ) then
					
						inc( esi );
						breakif( esi = edi );
						breakif( (type char [esi]) <> '"' );
						
					endif;
					mov( al, LineBuffer[ edx ] );
					inc( edx );
					inc( esi );
					
				endfor;
				if( (type char [esi-1]) <> '"' ) then
				
					stdout.put( "Syntax error in string constant" nl );
					raise( ExprSyntaxException );
					
				endif;
				
				// We've output the string constant to the line buffer,
				// now compute and store the length of the string.
				
				mov( edx, index );
				sub( ebx, edx );
				dec( edx );
				if( edx >= 256 ) then
				
					stdout.put
					( 
						"Error: String literals must be less "
						"than 256 characters long"
						nl
					);
					raise( ExprSyntaxException );
					
				endif;
				mov( dl, LineBuffer[ ebx ] );	
				

			// Check for identifiers, floating point constants, and
			// integer constants.
			
			elseif( matchID() ) then
			
				// All the real work is done inside matchID...
				
			
			// Note: must check for floating point constant before
			// we check for an integer constant.
			
			elseif( matchFltConst() ) then
			
				// All the real work is done inside matchFltConst...
			
			elseif( matchIntConst() ) then
			
				// All the real work is done inside matchIntConst...
				
			else
			
				stdout.put( "Expected an ID or a constant" nl );
				raise( ExprSyntaxException );

			endif;
			pop( ebx );		
			mov( true, al );
			ret();
			
		end matchTerm;
		
		
		
	begin Expression;
	
		// Okay, match an arithmetic expression.
		
		push( esi );		// Preserve ESI's value for success/failure.

		// Expr ::= (id | constant) (op Expr)*;
		//
		// Must have at least one ID or constant.
		// Note that matchTerm only returns if it succeeds.
		
		matchTerm();
		if( esi < edi ) then
		
			repeat
			
				SkipSpcs();
				mov( true, GoodExpr );
				pat.match( esi, edi )
				
					// Note: we must match this pattern before "<"
					
					pat.matchStr( "<=" );
					PutToken( LEtkn );
					
				  pat.alternate
				  
					// Note: we must match this pattern before "<"
					
				  	pat.matchStr( "<>" );
					PutToken( NEtkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '<' );
					PutToken( LTtkn );
					
				
				  pat.alternate
				  
					// Note: we must match this pattern before ">"
					
					pat.matchStr( ">=" );
					PutToken( GEtkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '>' );
					PutToken( GTtkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '=' );
					PutToken( EQtkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '+' );
					PutToken( PLUStkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '-' );
					PutToken( MINUStkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '*' );
					PutToken( MULtkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '/' );
					PutToken( DIVtkn );
					
				  pat.alternate
				  
				  	pat.oneChar( '%' );
					PutToken( MODtkn );
					
				  pat.alternate
				  
				  	pat.matchiWord( "AND" );
					PutToken( ANDtkn );
					
				  pat.alternate
				  
				  	pat.matchiWord( "OR" );
					PutToken( ORtkn );
					
				  pat.if_failure
				  
				  	// No operator means the expression is
					// done and we've got to let the following
					// productions check for the correctness of
					// what follows.
					
					mov( false, GoodExpr );
					
				pat.endmatch;
				
				// After the operator, we need another ID or constant.
				
				if( GoodExpr ) then	
				
					// matchTerm only returns if if succeeds.
					
					matchTerm();
					breakif( esi >= edi );
					
				endif;
			
			until( !GoodExpr );
			
		endif;
	
		// Since this routine doesn't have to handle backtracking,
		// a simple return indicates success.
		//
		// If there was some sort of syntax error, we've long since
		// bailed using the exception handling mechanism.  If we
		// get to this point, we can assume success.

		Succeed:
			pop( ebx );			// Return original ESI value in EBX
			ret();
	
	end Expression;
	
	
	// ParseID- matches an identifier.
	
	procedure ParseID
	( 
		start:dword in esi; 
		last:dword in edi 
	);	@nodisplay;

	var
		esiSave: 	dword;
		StartOfID:	dword;
		indexSave:	dword;
		edxSave:	dword;
		
	begin ParseID;
	
		mov( edx, edxSave );
		mov( esi, esiSave );
		mov( index, indexSave );
		pat.match( esi, edi )
		
			pat.zeroOrMoreWS();
		  	mov( esi, StartOfID );
			pat.oneCset( {'a'..'z', 'A'..'Z'} );
			pat.zeroOrMoreCset( idSet );
			mov( StartOfID, ebx );
			pat.extract( identifier );
				
			push( esi );	// Save these because we use them for
			push( edi );	// object access and other purposes.
			push( ebx );
			
			// Labels must be fewer than MaxLabelLength characters long:
			
			mov( identifier, eax );
			mov( (type str.strRec [eax]).length, ecx );
			if( ecx > MaxLabelLength ) then
			
				// If the label is too long, raise an exception.
				
				stdout.put
				( 
					"Label is too long (",
					(type uns32 ecx),
					"chars, max ", 
					MaxLabelLength, 
					" chars)" 
					nl 
				);
				raise( LabelSyntaxException );
				
			endif;
			
			// Look up the identifier in the ID table:
			
			Vars.getNode( eax );

			push( eax );			// Save table pointer for later.
			
			// If the values field is NULL, then create a
			// default value for this object (Undefined Variable).
			
			if( (type tableNode [eax]).Value = NULL ) then
			
				mov( eax, ebx );	// Save pointer to table entry.
				
				malloc( @size(Variant));
				mov( eax, (type tableNode [ebx]).Value );
				mov( Undefined_c, (type Variant [eax]).DataType );
				mov( 0, (type Variant [eax]).i );
				
			endif;

			
			// Emit the pointer to the table entry for this symbol:
			
			mov( index, ebx );
			pop( eax );		// Retrive pointer to table entry.
			mov( eax, (type dword LineBuffer[ ebx ]) );
			add( 4, index );
			
			// Restore important pointers so we can continue
			// the pattern match.
			
			pop( ebx );
			pop( edi );
			pop( esi );
			
		  pat.if_failure
		  
		  	// If we failed, restore ESI and index and the return.
			
		  	mov( esiSave, esi );
			mov( indexSave, index );
			mov( edxSave, edx );
		  	pat._fail_( pat.FailTo )
			
		pat.endmatch;
		
		// If we've matched the ID, return success to the caller.
			
		mov( esiSave, ebx );	// Must return start of string in EBX.
		mov( edxSave, edx );	// Should preserve EDX across pattern calls.	
	
	end ParseID;
	
	
	
	
	
	/*
	** ParseStmt-
	**
	**	Parses a single statement on a line:
	*/
	
	procedure ParseStmt
	( 
		startLine:dword in ESI;
		endLine:dword in EDI 
	); 
		@noframe; 
		@nodisplay;
		
	begin ParseStmt;

		// Statements that the following code parses:
		//
		//	BEEP
		//	CLS
		//	COLOR expr, expr
		//	DEBUG
		//	EDIT #
		//	FOR var = expr TO expr {STEP expr}
		//	GET var
		//	GOSUB label
		//	GOTO label
		//	IF( expr ) THEN stmt {stmts}
		//	INPUT var
		//	{LET} var = expr	
		//	LIST { # {,#}}
		//	GOTOXY expr, expr
		//	NEXT {var}
		//	ON expr GOTO label_list
		//	ON expr GOSUB label_list
		//	PRINT expr_list
		//	READLN var
		//	REM
		//	RETURN
		//	STOP
		//	WAIT expr

	
		pat.match( startLine, endLine )
			
			// BEEP keyword:
			
			pat.zeroOrMoreWS();
			pat.matchiWord( "beep" );
			pat.endStmt();
			
			mov( index, ebx );
			mov( BEEPtkn, LineBuffer[ ebx ] );
			inc( index );

		  pat.alternate
		  
		  	// CLS keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "cls" );
			pat.endStmt();
			
			mov( index, ebx );
			mov( CLStkn, LineBuffer[ ebx ] );
			inc( index );
			
		  pat.alternate
		  
		  	// COLOR keyword:

		  	pat.zeroOrMoreWS();
			pat.matchiWord( "color" );
			PutToken( COLORtkn );			
			Expression( esi, edi );
			pat.oneChar( ',' );
			PutToken( COMMAtkn );
			Expression( esi, edi );
			pat.endStmt();		

		  pat.alternate

		  	// DEBUG keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "debug" );
			pat.endStmt();
			
			mov( index, ebx );
			mov( DEBUGtkn, LineBuffer[ ebx ] );
			inc( index );		

			
		  pat.alternate
		  
		  	// ELSE keyword:

		  	pat.zeroOrMoreWS();
			pat.matchiWord( "else" );
			PutToken( ELSEtkn );
			pat.zeroOrMoreWS();

			mov( index, edx );
			if( edx <> 1 ) then
			
				stdout.put
				( 
					"ELSE must appear at the start of the line"
					nl
				);
				raise( BasicError );
				
			endif;
			
			// Make room for the pointer to the ENDIF clause:
			
			mov( 0, (type dword LineBuffer[edx]));
			add( 4, index );
			
			// Note:
			
				// Since a statement may immediately follow the ELSE,
				// there is no "pat.endStmt" call here.
			
			

					
		  pat.alternate
		  
		  	// ENDIf keyword:

		  	pat.zeroOrMoreWS();
			pat.matchiWord( "endif" );
			PutToken( ENDIFtkn );
			pat.endStmt();
			if( index <> 1 ) then
			
				stdout.put
				( 
					"ENDIF must appear at the start of the line"
					nl
				);
				raise( BasicError );
				
			endif;
				
				
			
		  pat.alternate

		  	// FOR keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "for" );
			PutToken( FORtkn );
			
			// Make room for the address that points at the corresponding
			// "NEXT <ID>" clause for this FOR statement:
			
			mov( index, edx );
			if( edx <> 1 ) then
			
				stdout.put
				( 
					"FOR statement must appear at the start of the line"
					nl
				);
				raise( BasicError );
				
			endif;
			mov( 0, (type dword LineBuffer[edx]));
			add( 4, index );
			
			// Get the identifier following the FOR:
			
			ParseID( esi, edi );

			// An equals sign must following the identifier.
			// We won't emit a token for "=" because we can always
			// assume its presence.

			pat.zeroOrMoreWS();
			pat.oneChar( '=' );
			
			// Parse the arithmetic expression following the
			// "for ID ="
			
			Expression( esi, edi );
			pat.zeroOrMoreWS();
			pat.matchiWord( "to" );
			
			// Handle the "TO expr" component here:
			
			PutToken( TOtkn );
			Expression( esi, edi );
			
			// Check for the optional "STEP expr" component here:
			
			pat.match( esi, edi );
			
				pat.endStmt();
				
			  pat.if_failure
			  
				pat.match( esi, edi )
				
					pat.zeroOrMoreWS();
					pat.matchiWord( "step" );
					PutToken( STEPtkn );
					Expression( esi, edi );
					pat.endStmt();
					
				  pat.if_failure
				  
				   	stdout.put
					( 
						"Syntax: FOR <var>=<expr> TO <expr> {STEP <expr>}" 
						nl 
					);
					raise( BasicError );
					
				pat.endmatch;
				
			pat.endmatch;
			pat.endStmt();
			
			


					
		  pat.alternate

		  	// GET keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "get" );
			PutToken( GETtkn );

			// Get the identifier following the GET:
			
			ParseID( esi, edi );
			pat.endStmt();
			


					
		  pat.alternate

		  	// GOSUB keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "gosub" );
			PutToken( GOSUBtkn );

			// Get the identifier following the GOSUB:
			
			ParseID( esi, edi );
			pat.endStmt();
			
			


					
		  pat.alternate

		  	// GOTO keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "goto" );
			PutToken( GOTOtkn );

			// Get the identifier following the GOTO:
			
			ParseID( esi, edi );
			pat.endStmt();
			
			

		  pat.alternate
		  
		  	// IF keyword:

		  	pat.zeroOrMoreWS();
			pat.matchiWord( "if" );
			PutToken( IFtkn );
			pat.zeroOrMoreWS();
			mov( index, edx );
			if( edx <> 1 ) then
			
				stdout.put( "IF must be first statement on line" nl );
				raise( BasicError );
				
			endif;
			
			// Make room for a pointer to the ELSE or ENDIF clause.
			
			mov( 0, (type dword LineBuffer[edx]));
			add( 4, index );
			
			pat.oneChar( '(' );
			PutToken( LPARENtkn );			
			Expression( esi, edi );
			pat.zeroOrMoreWS();
			pat.oneChar( ')' );
			PutToken( RPARENtkn );
			pat.zeroOrMoreWS();
			pat.matchiWord( "then" );
			PutToken( THENtkn );
			
			// Note:
			
				// Since a statement may immediately follow the THEN,
				// there is no "pat.endStmt" call here.
			
					


					
		  pat.alternate

		  	// INPUT keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "input" );
			PutToken( INPUTtkn );

			// Get the identifier following the INPUT:
			
			ParseID( esi, edi );
			
			// Handle an optional array index here:

			push( index );
			
			forever
			
				pat.zeroOrMoreWS();
				breakif( (type char [esi]) <> '[' );
			
				pat.match( esi, edi )
				
					pat.oneChar( '[' );
					PutToken( LBRACKtkn );
					pat.zeroOrMoreWS();
					Expression( esi, edi );
					pat.zeroOrMoreWS();
					pat.oneChar( ']' );
					PutToken( RBRACKtkn );
					mov( true, al );
				
				  pat.if_failure
				  
				  	mov( false, al );
					
				pat.endmatch;
			
				// If we failed to match the dimension list, then we
				// need to restore the Index into the token output list
				// to clean up any emissions by the code above.
				
				if( !al ) then
				
					pop( index );
					
				endif;
				
			endfor;
			pat.endStmt();
			
			
			
			

		  pat.alternate

		  	// GOTOXY keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "gotoxy" );
			PutToken( GOTOXYtkn );
			Expression( esi, edi );
			pat.zeroOrMoreWS();
			pat.oneChar( ',' );
			PutToken( COMMAtkn );
			Expression( esi, edi );			
			pat.endStmt();
			
			
		  pat.alternate

		  	// NEXT <id> statement:

			mov( index, nextIndex );		// Save for next alternate.
			
			pat.zeroOrMoreWS();
			pat.matchiWord( "next" );
			PutToken( NEXTtkn );

			// Get the identifier following the NEXT:

			PutToken( IDtkn );
			ParseID( esi, edi );
			pat.endStmt();
			if( nextIndex <> 0 ) then
			
				stdout.put
				( 
					"Error: NEXT <ID> must be first statement on line "
					nl
				);
				raise( BasicError );
				
			endif;
			
			
		  pat.alternate

		  	// NEXT statement (no ID):

			mov( nextIndex, index );		// Restore if messed up above.
			pat.zeroOrMoreWS();
			pat.matchiWord( "next" );
			PutToken( NEXTtkn );
			pat.endStmt();
			

					
					
			

					
		  pat.alternate

		  	// ON..GOTO/GOSUB keywords:

			pat.zeroOrMoreWS();
			pat.matchiWord( "on" );
			PutToken( ONtkn );
			
			Expression( esi, edi );
			
			// Match either GOTO or GOSUB here:

			pat.match( esi, edi );

			  	// GOTO keyword:

				pat.zeroOrMoreWS();
				pat.matchiWord( "goto" );
				PutToken( ONGOTOtkn );

			  pat.alternate

			  	// GOSUB keyword:

				pat.zeroOrMoreWS();
				pat.matchiWord( "gosub" );
				PutToken( ONGOSUBtkn );
				
			  pat.if_failure
			  
			  	stdout.put( "Expected GOSUB or GOTO in ON statement" nl );
				raise( BasicError );
				
			pat.endmatch;

			  			
			// Process the label list following the GOSUB/GOTO keyword:			
			
			repeat
			
				PutToken( IDtkn );
				ParseID( esi, edi );
				
				// At this point we could have the end of the
				// statement or we could have a ',' 
				
				pat.match( esi, edi )
				
					pat.endStmt();
					mov( true, al );
					
				  pat.alternate
				  
				  	pat.zeroOrMoreWS();
					pat.oneChar( ',' );
					PutToken( COMMAtkn );
					mov( false, al );
					
				  pat.if_failure
				  
				  	stdout.put
					( 
						"Syntax error in ON..GOTO/GOSUB label list"
						nl
					);
					raise( BasicError );
					
				pat.endmatch;
				
			until( al );
			
			
			
			

					
		  pat.alternate

		  	// PRINT keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "print" );
			PutToken( PRINTtkn );

			// Process the expression list following the PRINT keyword:
			// Since all expressions are optional, we must begin by
			// seeing if there is at least one expression.
			
			pat.match( esi, edi )
			
				pat.endStmt();
				mov( false, al );
				
			  pat.if_failure
			  
			  	mov( true, al );
				
			pat.endmatch;
			
			// AL = true if we're not at the end of a statment and we
			// must process an expression.
			
			while( al ) do
			
				Expression( esi, edi );
				
				// At this point we could have the end of the
				// statement or we could have a ';' or a ',' 
				
				pat.match( esi, edi )
				
					pat.endStmt();
					mov( false, al );
					
				  pat.alternate
				  
				  	pat.zeroOrMoreWS();
					pat.oneChar( ';' );
					PutToken( SEMICOLONtkn );
					
					// If the semicolon appears at the end of a statement,
					// that's okay too.
					
					pat.match( esi, edi )
					
						pat.endStmt();
						mov( false, al );
						
					  pat.if_failure
					  
					  	mov( true, al );
						
					pat.endmatch;
					
				  pat.alternate
				  
				  	pat.zeroOrMoreWS();
					pat.oneChar( ',' );
					PutToken( COMMAtkn );
					
					// If the comma appears at the end of a statement,
					// that's okay too.
					
					pat.match( esi, edi )
					
						pat.endStmt();
						mov( false, al );
						
					  pat.if_failure
					  
					  	mov( true, al );
						
					pat.endmatch;
					
				  pat.if_failure
				  
				  	stdout.put
					( 
						"Syntax error in print statement argument list"
						nl
					);
					raise( BasicError );
					
				pat.endmatch;
				
			endwhile;

			
			


					
		  pat.alternate

		  	// READLN keyword:

			pat.zeroOrMoreWS();
			pat.matchiWord( "readln" );
			PutToken( READLNtkn );

			// Get the identifier following the READLN:
			
			ParseID( esi, edi );
			pat.endStmt();
			
			


					
		  pat.alternate

		  	// REM keyword:

			pat.zeroOrMoreWS();
			pat.matchiStr( "rem" );		// Must be matchiStr, not matchiWord!
			PutToken( REMtkn );

			// All the text to the end of the line
			// constitutes the remark which we must store:
			
			mov( edi, ecx );
			sub( esi, ecx );
			if( ecx >= 256 ) then
			
				stdout.put( "REMark is too long" nl );
				raise( BasicError );
			
			endif;

			mov( index, edx );
			mov( cl, LineBuffer[ edx ] );
			
			// Move index past our string and length byte.
			
			stc();
			adc( ecx, index );
			
			// Copy the string data to the line buffer:
			
			push( edi );
			lea( edi, LineBuffer[ edx+1 ] );
			rep.movsb();
			pop( edi );
			mov( edi, esi );
			


		  pat.alternate
		  
		  	// RETURN keyword

			pat.zeroOrMoreWS();
			pat.matchiWord( "return" );
			pat.endStmt();
			
			mov( index, ebx );
			mov( RETURNtkn, LineBuffer[ ebx ] );
			inc( index );		

		  pat.alternate

			// STOP keyword
			
			pat.zeroOrMoreWS();
			pat.matchiWord( "stop" );
			pat.endStmt();
			
			mov( index, ebx );
			mov( STOPtkn, LineBuffer[ ebx ] );
			inc( index );


			
		  pat.alternate
		  
		  	// WAIT keyword:

		  	pat.zeroOrMoreWS();
			pat.matchiWord( "wait" );
			PutToken( WAITtkn );			
			Expression( esi, edi );
			pat.endStmt();
			
			

			
					
			/*
			** Handle the assignment statement here.
			** Warning! This code must follow all the
			** patterns for reserved words and it must
			** precede the pattern for statement labels.
			*/
			
		  pat.alternate
		  
		  	// LET keyword / Assignment statement:
			//
			//
			// Put index in a safe place in case it gets messed up
			// via backtracking.
			
			mov( index, eax );
			mov( eax, parseIndex );
		  
			pat.zeroOrMoreWS();
		  	pat.match( esi, edi )
			
				pat.matchiWord( "let" );
			  
			  pat.if_failure
			
				// Fall through if no prepended LET.
				
			pat.endmatch;
			
			pat.zeroOrMoreWS();
		  	mov( esi, StartOfID );
			pat.oneCset( {'a'..'z', 'A'..'Z'} );
			pat.zeroOrMoreCset( idSet );
			mov( StartOfID, ebx );
			pat.extract( identifier );
			
			// Deal with the LET token and the ID here:
			
				push( esi );	// Save these because we use them for
				push( edi );	// object access and other purposes.
				push( ebx );
				
				// Labels must be fewer than MaxLabelLength characters long:
				
				mov( identifier, eax );
				mov( (type str.strRec [eax]).length, ecx );
				if( ecx > MaxLabelLength ) then
				
					// If the label is too long, raise an exception.
					
					stdout.put
					( 
						"Label is too long (",
						(type uns32 ecx),
						"chars, max ", 
						MaxLabelLength, 
						" chars)" 
						nl 
					);
					
					
					raise( LabelSyntaxException );
					
				endif;
				
				// Look up the identifier in the ID table:
				
				Vars.getNode( eax );

				push( eax );			// Save table pointer for later.
				
				// If the values field is NULL, then create a
				// default value for this object (Undefined Variable).
				
				if( (type tableNode [eax]).Value = NULL ) then
				
					mov( eax, edx );	// Save pointer to table entry.
					
					malloc( @size(Variant));
					mov( eax, (type tableNode [edx]).Value );
					mov( Undefined_c, (type Variant [eax]).DataType );
					mov( 0, (type Variant [eax]).i );
					
				endif;

				// Emit a LET token as the first token of this line.
				
				mov( index, ebx );
				mov( LETtkn, LineBuffer[ ebx ] );
				
				// Emit the pointer to the table entry immediately
				// after the LET token
				
				pop( eax );		// Retrive pointer to table entry.
				mov( eax, (type dword LineBuffer[ ebx+1]) );
				add( 5, index );
				
				// Restore important pointers so we can continue
				// the pattern match.
				
				pop( ebx );
				pop( edi );
				pop( esi );
			
			
			// Handle an optional array index here:

			forever
			
				pat.zeroOrMoreWS();
				breakif( (type char [esi]) <> '[' );
			
				pat.match( esi, edi )
				
					pat.oneChar( '[' );
					PutToken( LBRACKtkn );
					pat.zeroOrMoreWS();
					Expression( esi, edi );
					pat.zeroOrMoreWS();
					pat.oneChar( ']' );
					PutToken( RBRACKtkn );
					mov( true, al );
				
				  pat.if_failure
				  
				  	mov( false, al );
					
				pat.endmatch;
			
				// If we failed to match the dimension list, then we
				// need to restore the Index into the token output list
				// to clean up any emissions by the code above.
				
				if( !al ) then
				
					stdout.put
					( 
						"Illegal array index" 
						nl 
					);
				
				
					raise( BasicError );
					
				endif;
				
			endfor;
			
			// An equals sign must following the identifier or array indices.
			// We won't emit a token for "=" because we can always
			// assume its presence.

			pat.zeroOrMoreWS();
			pat.oneChar( '=' );

				
				  
			
			// Parse the arithmetic expression following the
			// "{let} ID ="
			
			Expression( esi, edi );
			pat.endStmt();
		  	
			
			
			/*
			** Handle labels here.
			**
			**	Warning! This code must follow all the
			**	patterns for the reserved words or the parser
			**	will get confused and possibly treat a reserved
			**	word as a label.
			*/
			
		  pat.alternate
					
			pat.zeroOrMoreWS();
		  	mov( esi, StartOfID );			// Save ptr to start of ID
			pat.oneCset( {'a'..'z', 'A'..'Z'} );
			pat.oneOrMoreCset( idSet );
			mov( StartOfID, ebx );
			pat.extract( identifier );
			pat.oneChar( ':' );
			
			// The LET code may have messed up INDEX.  Correct that here.
			
			mov( parseIndex, index );
			
			// Only allow labels at the start of a statement.
			
			if( index <> 0 ) then
			
				// If index <> 0, then this isn't the first lexeme
				// on the line.  Raise an exception to denote this.
				
				stdout.put( "Label must be first item in statement" nl );
				raise( LabelSyntaxException );
			
			endif;
						
			// Labels must be fewer than MaxLabelLength characters long:
			
			mov( identifier, eax );
			mov( (type str.strRec [eax]).length, ecx );
			if( ecx > MaxLabelLength ) then
			
				// If the label is too long, raise an exception.
				
				stdout.put
				( 
					"Label is too long (",
					(type uns32 ecx),
					"chars, max ", 
					MaxLabelLength, 
					" chars)" 
					nl 
				);
				
				
				raise( LabelSyntaxException );
				
			endif;
			
			
			push( ebx );
			
			// Okay, we've got a valid label.
			// Emit the label and appropriate tokens to the output buffer.
			
			mov( index, ebx );
			mov( Labeltkn, LineBuffer[ ebx ] );	// Label token

			// Make sure the symbol is in the symbol table.
			// The store a pointer to the table entry as the
			// last four bytes of the token.			

			push( esi );	// Must save because of method invocation.
			push( edi );
			
			Vars.getNode( identifier );
			
			// Save pointer to table entry as part of token value:
			
			mov( eax, (type dword LineBuffer[ ebx+1 ]));
			
			// Update the table entry to specify that we've got
			// a statement label.
			
			mov( (type tableNode [eax]).Value, eax );
			mov( Label_c, (type Variant [eax]).DataType );
			add( 5, index );
			
			pop( edi );
			pop( esi );
			pop( ebx );	
			
		  

		  pat.alternate

			// Line separator.
			// This pattern must follow the pattern
			// for a statement label.

			pat.zeroOrMoreWS();
			pat.oneChar( ':' );
			
			mov( index, ebx );
			mov( StmtSeptkn, LineBuffer[ ebx ] );
			inc( index );		


		  pat.if_failure
		  
		  	// If we get to this point, the line contains a syntax
			// error.  Raise the appropriate exception and return
			// to the main processing loop.
			
			raise( SyntaxErrorException );
			
		pat.endmatch;
		ret();
	
	end ParseStmt;
	
	
	
begin ParseLine;

	pushad();
	mov( 0, index );
	mov( stralloc( 256 ), identifier );

	// Convert the line number string to an unsigned integer and
	// verify that the line number is a 16-bit value.
	
	mov( GetLineNum( LineNumberStr ), CurLineNum );
	
	// Count the number of leading spaces in the line
	// and strip them from the text.  We'll maintain this
	// value in the "leading" field of the statement record.
	
	mov( LineStr, eax );
	while( (type char [eax]) = ' ' ) do
	
		inc( eax );
		
	endwhile;
	sub( LineStr, eax );
	mov( al, LeadingSpaces );
	str.trim( LineStr );
	
	
	
	// Okay, now parse the line to ensure that it is
	// syntactically correct.  Also, tokenize the line
	// to speed up interpretation and (usually) reduce
	// the size of the line.  Of course, first we have
	// to make sure that there was a line (i.e., ensure
	// that LineStr is not empty).
	
	mov( str.length( LineStr ), ebx );
	push( ebx ); 						// Save for later.
	
	if( ebx <> 0 ) then
		
		mov( LineStr, esi );
		mov( (type str.strRec [esi]).length, edi );
		add( esi, edi );
		
		while( esi <> edi ) do
		
			ParseStmt( esi, edi );
			
		endwhile;
		
	endif;
		
	
	
	// Okay, the line parsed correctly (or we would have bailed
	// with a syntax error.  Now check to see if there is already
	// a line with this line's line number.  We've got to delete
	// that line if it is present.
	
	
	
	if( FindLine( TxtStart, CurLineNum ) ) then
		
		
		// Line exists, delete it:
		//
		//	Deletion algorithm:
		//
		//	(1) Dest = adrs of current line.
		//	(2)	Src  = adrs of next line.
		//	(3) len  = size of pgm from next line to end of pgm.
		//	(4) Move src block over the top of the dest block.
		
		mov( edx, edi );	// Dest = adrs of current line.
		
		// Compute adrs of next line and put in Src (ESI).
		
		movzx( (type StmtRec [edx]).size, eax );
		lea( esi, [edx+eax] );
		
		// Compute length from Src to end of pgm.
			
		mov( TxtEnd, ecx );	// Compute block length.
		sub( esi, ecx );
		
		// Copy the src block over the top of the dest block.
		
		cld();
		rep.movsb();
		mov( edi, TxtEnd );
		
	endif;
	
	pop( ebx );	// Restore line length.
	
	
	// Line does not exist (either it never existed or
	// else we deleted it), add this line to the program
	// if there really is a line to add.  If the LineStr
	// is empty, then do nothing because all the caller
	// wanted to do was delete the line.
	//
	// Next, check LineStr to see if it was empty (EBX contains
	// the original string length):

	if( ebx <> 0 ) then

		// Now load EBX with the length of the tokenized
		// buffer (LineBuffer):
		
		mov( index, ebx );
		
		// Our total line length must be less than 256 bytes.
		// Check that here.
		
		lea( ecx, [ebx+5] );
		if( ecx >= 256 ) then
		
			raise( StmtTooLongException );
			
		endif;
		
		// Okay, we've got a real line we're supposed to
		// insert.  Begin by opening up sufficient space for
		// our new line in the text space (special case- if
		// we're appending a line to the end of the program
		// then we don't have to make any room for the line).
			
		if( edx <> TxtEnd ) then 	// We have to make room for the line
		
			mov( TxtEnd, ecx );		// Compute size of the rest of the
			sub( edx, ecx );		//  program (the stuff to move).
			
			// Start moving from the end of the program:
			
			mov( TxtEnd, esi );
			dec( esi );
			
			// Destination is n bytes beyond the current
			// end of program where n is the size of the
			// current input line plus 5 (4 bytes for binary
			// line number, line size, and leading spaces, and one 
			// byte for a zero terminating byte).
			
			lea( edi, [esi+ebx+6] );	// Strlen + 2 + 1 + 1 + 1.
			mov( edi, TxtEnd );
			dec( edi );					// Because of +6 disp above.
		
			// Open up room for the new line:
			
			std();
			rep.movsb();
			cld();
			
		else // Special case- just append the text to the end of the pgm.
		
			lea( eax, [edx+ebx+5] );	// Line length + overhead bytes.
			mov( eax, TxtEnd );			// New end of pgm ptr.					
			
		endif;
		
		// Save away the line size, number of leading spaces,
		// line number the line's text, and a zero terminating byte:

		mov( bl, (type StmtRec [edx]).size );
		add( 5, (type StmtRec [edx]).size ); // Adjust for overhead			
		mov( CurLineNum, (type StmtRec [edx]).lineNum );
		mov( LeadingSpaces, al );
		mov( al, (type StmtRec [edx]).leading );
		
		// Copy the text into the program space:
		
		lea( edi, [edx+4] );
		lea( esi, LineBuffer );
		mov( ebx, ecx );
		rep.movsb();
		
		// Append the zero terminating byte:
		
		mov( 0, al );
		stosb();
		
	endif;
	
	strfree( identifier );
	popad();

end ParseLine;


/*******************************************************/
/*                                                     */
/* DumpProc-                                           */
/*                                                     */
/* This procedure displays all the source lines between*/
/* line number "start" and line number "stop" in a     */
/* hexadecimal format.                                 */
/*                                                     */
/* This procedure is mainly used for debugging the     */
/* BASIC interpreter.                                  */
/*                                                     */
/*******************************************************/

procedure DumpProc( start:uns16; stop:uns16 ); @nodisplay;

	procedure PutValue
	( 
		id:string; 
		theValue:dword; 
		index:int32;
		offset:int32 
	); 	@nodisplay;
	begin PutValue;
	
		push( eax );
		push( ebx );
		if( offset <> 0 ) then
		
			stdout.putcSize( ' ', offset, ' ' );
			
		endif;
		stdout.put( id );
		if( index >= 0 ) then
		
			stdout.put( "[", index, "]" );
			
		endif;
		stdout.put( " = " );
		mov( theValue, ebx );
		if( ebx = NULL ) then
		
			mov( Undefined_c, eax );
			
		else
		
			movzx( (type Variant [ebx]).DataType, eax );
			
		endif;
		switch( eax )
		
			case( Undefined_c )
			
				stdout.put( "Undefined identifier" nl );
				
				
			case( Label_c )
			
				stdout.put
				( 
					"Statement label, address= $",
					(type Variant [ebx]).l,
					nl
				);
				
				
			case( LabelVar_c )
			
				stdout.put
				( 
					"Label Variable, address= $",
					(type Variant [ebx]).l,
					nl
				);
				
				
			case( Array_c )
			
				stdout.put( "Array" nl );
				push( ecx );
				push( ebx );
				xor( ecx, ecx );
				push( (type Variant [ebx]).a.elements ); 	//[esp] = #elements
				mov( (type Variant [ebx]).a.array, ebx );
				mov( offset, eax );
				add( 4, eax );
				while( ecx < [esp] ) do
				
					PutValue( id, ebx, ecx, eax );
					add( @size( Variant ), ebx );
					inc( ecx );
					
				endwhile;
				pop( eax );  // Remove "elements" from stack.
				pop( ebx );
				pop( ecx ); 
				
			case( Integer_c )
			
				stdout.put( (type Variant [ebx]).i, nl );
				
			case( Real_c )
			
				stdout.put( (type Variant [ebx]).r, nl );
				
			case( String_c )
			
				stdout.put( """", (type Variant [ebx]).s, """" nl );
				
			default
			
				stdout.put( "Error! Unknown data type!" nl );
		
		endswitch;
		pop( ebx );
		pop( eax );
		
	end PutValue;

begin DumpProc;

	pushad();

	stdout.put( "TxtStart:   ", TxtStart, nl );
	stdout.put( "TxtEnd:     ", TxtEnd, nl nl );
	
	
	// Locate the first line specified by the DUMP command:
	
	FindLine( TxtStart, start );
	

	// From that line to the end of the listing, or to the
	// last line specified, print the lines in the program
	// in hexadecimal format:
	
	while( edx < TxtEnd ) do
	
	
		// Bail if the current line number is greater than
		// the "stop" line number parameter:
		
		mov( (type StmtRec [edx]).lineNum, ax );
		breakif( ax > stop );

		// Print the size, leading, and line number values:
		
		movzx( (type StmtRec [edx]).size, ecx );
		stdout.put
		(
			edx,
			":", 
			(type uns8 cl),
			",", (type StmtRec [edx]).leading,
			" #",  (type uns16 ax ),
			" data:"
		);
		sub( 4, cl );
		lea( ebx, [edx+4] );
		while( ecx <> 0 ) do 
		
			stdout.put( ' ', (type byte [ebx]));
			inc( ebx );
			dec( ecx );
			
		endwhile;
		stdout.newln();
				
		// Adjust EDX so it points at the next line in the program:
		
		movzx( (type StmtRec [edx]).size, eax );
		add( eax, edx );

	endwhile;
	
	stdout.put ( nl "Last Byte:  ", edx, nl nl );

	// Dump the symbol table:
	
	foreach Vars.item() do
	
		PutValue
		( 
			(type tableNode [eax]).id, 
			(type tableNode [eax]).Value,
			-1,
			0
		);
		
	endfor;
	popad();

end DumpProc;






/**************************************************************/
/*                                                            */
/* EditProc-                                                  */
/*                                                            */
/* This procedure locates the specified line and copies its   */
/* text into the input line buffer.  The next input operation */
/* (i.e., reading the next line of text in the command loop)  */
/* will read this data and allow the user to edit it.         */
/*                                                            */
/**************************************************************/

procedure EditProc( line:uns16 ); @nodisplay; @noalignstack;
var
	theLine:string;
	
readonly
	space:string := " ";
	
	
	// ungetc-
	//
	// Okay, this is ugly!
	//
	//	cStr points at the first character of a zero terminated string.
	//	This procedure inserts each character of that string into the
	//	console's input buffer so that when the EditProc procedure
	//	returns, the system will read this string from the input.
	
	procedure ungetc( cStr:dword ); @nodisplay;
	var
		ker: 		win.INPUT_RECORD;
		NumWritten:	dword;
		
		
	begin ungetc;
	
		pushad();
		mov( cStr, esi );
		
		forever
		
			// while the current character is not #0:
			
			movzx( (type byte [esi]), eax );
			breakif( al = 0 );
		
			// Translate the ASCII code to a VK code:
			
			mov( ax, (type word ker.Event.KeyEvent.AsciiChar));
			push( eax );
			call VkKeyScan;
			
			// Build a KEY_EVENT (keyboard record) around this
			// character using the VK code in AL and the shift
			// state in AH:
			
			mov( win.KEY_EVENT, ker.EventType );
			mov( true, ker.Event.KeyEvent.bKeyDown );
			mov( 0, ker.Event.KeyEvent.wRepeatCount );
			mov( al, (type byte ker.Event.KeyEvent.wVirtualKeyCode));
			mov( 0, (type byte ker.Event.KeyEvent.wVirtualKeyCode[1]));
			mov( 0, ker.Event.KeyEvent.wVirtualScanCode );
			
			// Construct the shift bitmap based on the value in AH:
			
			xor( ebx, ebx );

			bt( 8, ax );		// Test for shift.
			rcl( 1, ebx ); 
			
			bt( 9, ax );		// Test for control.
			rcl( 1, ebx );
			rcl( 1, ebx );		// No right control
			
			bt( 10, ax );		// Test for ALT.
			rcl( 1, ebx );
			rcl( 1, ebx );		// No right ALT.
			
			mov( bx, ker.Event.KeyEvent.dwControlKeyState );
			
			
			// Send a down code event:
			
			push( esi );
			WriteConsoleInput
			(
				NumWritten,		// Returns "1" here.
				1,				// # of key events.
				ker,			// Our event record.
				hStdIn			// Console Input handle.
			);
			
			// Send an up code event:
			
			mov( false, ker.Event.KeyEvent.bKeyDown );
			WriteConsoleInput
			(
				NumWritten,		// Returns "1" here.
				1,				// # of key events.
				ker,			// Our event record.
				hStdIn			// Console Input handle.
			);

			pop( esi );
			inc( esi );
			  
		endfor;
		popad();

	end ungetc;
	
	
begin EditProc;


	pushad();
	
	// Build a local string:
	
	mov( stralloc( 500 ), theLine );
	
	// If the line the user specified exists, then convert
	// it to a string and insert it into the console input
	// buffer so the user can edit it as the next input line:
	
	if( FindLine( TxtStart, line )) then
	
		// Convert the binary line number to a string and
		// write this to the input buffer.
		// (note: this code calls u32ToStr rather than
		// u16ToStr because there was a bug in u16ToStr
		// when this was being written).
		
		movzx( (type StmtRec [edx]).lineNum, eax ); 
		conv.u32ToStr( eax, 0, ' ', theLine );
		ungetc( (type dword theLine) );
		
		// Detokenize the statement and produce a string to output:
		
		str.cpy( " ", theLine );
		ungetc( theLine );
		Detokenize( edx, theLine );
		ungetc( theLine );
		
	endif;

	strfree( theLine );
	popad();
	
end EditProc;




/*********************************/
/*                               */
/* The main program begins here. */
/*                               */
/*********************************/

static
	MainsEBP:	dword;
	fileHandle:	dword;
	filename:	str.strvar( 256 );
	inputLine:	str.strvar( 1024 );
	
begin MiniBASIC;

	mov( ebp, MainsEBP );

	// Get strings for input purposes:
	
	mov( stralloc( 256 ), Input );
	mov( stralloc( 256 ), LineNumberStr );
	mov( stralloc( 256 ), LineStr );
	
	
	// Initialize the variables:
	
	mov( table.create( 1000 ), Vars );
	
	
	// Initialize the console display:
	
	try
	
		AllocCons();				// Set up std in/out handles.
		WinEdit();					// Set up the initial win32cons.
		
	  anyexception
	  
	  	stdout.put( "Could not set up console" nl );
		exit MiniBASIC;
		
	endtry;
	
	
	// Start the interpreter:
	
	mov( esp, Sstack );			// Save stack pointer to restore later.

	// Do the equivalent of the "NEW" command:
	
	cld();						// Always assume D=0.
	mov( &PgmSpace, edi );
	mov( edi, TxtStart );		// Start of BASIC program area.
	mov( edi, TxtEnd   );		// End of BASIC program area.	
	
	// Display welcome message );
	
	stdout.put( nl, BasicTitle );

	// Command loop- continually reads a line of text from the
	// user and processes the command on that line:
	
	mov( false, debugFlag );	// Turn off debugging.
	forever						// "Ready Loop"
	
		try
		
			InitP();
			if( csbi.dwCursorPosition.X <> 0 ) then
			
				stdout.newln();
				
			endif;

			push( ColorsCurrent );
			call win32cons.setOutputAttr;
			stdout.put( nl "Ready" nl nl );
			
			// Emit the prompt character using the prompt color:
			
			xor( eax, eax );
			mov( PromptColor, al );
			or( ColorsCurrent, eax );
			win32cons.setOutputAttr( ax );
			
			stdout.put( PromptChar );
			
			push( ColorsCurrent );
			call win32cons.setOutputAttr;
			
			
			// Init line input pointers:

			stdin.gets( Input );
			str.trim( Input );
			
			pat.match( Input )
			
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.arb();
				pat.extract( LineStr );
				pat.EOS();
				
				// We've got a line that starts with a number
				// Go process that line.
				
				ParseLine( LineNumberStr, LineStr );
				



				/*
				** DUMP commands:
				**
				**	These commands really exist for debugging
				**	purpose.  They display the program's text
				**	in raw hexadecimal form so someone working
				**	on this interpreter can see what their
				**	code is doing with the tokenized source.
				*/
				
			  pat.alternate
			  
				// Handle the "DUMP #,#" command here.
				
				pat.matchiStr( "DUMP" );
				pat.oneOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				mov( GetLineNum( LineNumberStr ), CurLineNum );
				
				pat.zeroOrMoreWS();
				pat.oneChar( ',' );
				pat.zeroOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.EOS();
				
				GetLineNum( LineNumberStr );
        				DumpProc( CurLineNum, ax );
				
			  pat.alternate
			  
			  	// Handle "DUMP #" command here.
				
				pat.matchiStr( "DUMP" );
				pat.oneOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.EOS();
				
				GetLineNum( LineNumberStr );
				DumpProc( ax, ax );
				
				
			  pat.alternate
			  
				// Handle the "DUMP" command here.

				pat.matchiStr( "DUMP" );
				pat.EOS();
				DumpProc(1,65535);



					

				/*
				** List Commands:
				**
				*/				
				
			  pat.alternate
			  
				// Handle the "LIST #,#" command here.
				
				pat.matchiStr( "LIST" );
				pat.oneOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				mov( GetLineNum( LineNumberStr ), CurLineNum );
				
				pat.zeroOrMoreWS();
				pat.oneChar( ',' );
				pat.zeroOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.EOS();
				
				GetLineNum( LineNumberStr );
				ListProc( CurLineNum, ax, hStdOut );
					
				
				
				
			  pat.alternate
			  
				// Handle the "LIST #," command here.
				
				pat.matchiStr( "LIST" );
				pat.oneOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.zeroOrMoreWS();
				pat.oneChar( ',' );
				pat.EOS();
				
				GetLineNum( LineNumberStr );
				ListProc( ax, 65535, hStdOut );
					
				
				
				
				
			  pat.alternate
			  
			  	// Handle "LIST #" command here.
				
				pat.matchiStr( "LIST" );
				pat.oneOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.EOS();
				
				GetLineNum( LineNumberStr );
				ListProc( ax, ax, hStdOut );
				
				
			  pat.alternate
			  
				pat.matchiStr( "LIST" );
				pat.EOS();
				
				// Handle the LIST command here.
				
				ListProc( 1, 65535, hStdOut);
				
				
				
				
			  
			  pat.alternate
			  
				// Handle the "EDIT #" command here.

				pat.matchiStr( "EDIT" );
				pat.oneOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.EOS();
				
				GetLineNum( LineNumberStr );
				EditProc( ax );
				
				
			  
			  pat.alternate
			  
			  	// Handle "RUN #" command here.
				
				pat.matchiStr( "RUN" );
				pat.oneOrMoreWS();
				pat.oneOrMoreCset( {'0'..'9'} );
				pat.extract( LineNumberStr );
				pat.EOS();
				
				GetLineNum( LineNumberStr );
				RunProc( ax );
				
				
			  
			  pat.alternate
			  
				// Handle the "RUN" command here.

				pat.matchiStr( "RUN" );
				pat.EOS();
				
				RunProc( 0 );
				
			  
			  pat.alternate
			  
				pat.matchiStr( "NEW" );
				pat.EOS();
				
				// Handle the NEW command here.
				//
				// Clear program text area, initialize the stacks,
				// and display the sign-on message.
				
				cld();
				mov( Sstack, esp );
				mov( MainsEBP, ebp );
				mov( &PgmSpace, edi );
				mov( edi, TxtStart );		// Start of BASIC program area.
				mov( edi, TxtEnd   );		// End of BASIC program area.	
				InitP();					// Reset stacks, etc.
				
				// Clear out all existing variables and
				// create a new variable table.

				Vars.destroy( &FreeVars );
				mov( table.create( 1000 ), Vars );
				
				stdout.put( nl, BasicTitle );
				
				// Since we've messed with the stack, we can't leave
				// this pattern matching section in the normal fashion.
				// Use "Continue" to bail out to the enclosing forever
				// loop;
				
				continue;				
			  
			  pat.alternate
			  
				// Handle the "DEBUG" command here.

				pat.matchiStr( "DEBUG" );
				pat.EOS();
				
				xor( true, debugFlag );
				stdout.put( "Debug " );
				if( debugFlag ) then
				
					stdout.put( "on." nl );
					
				else
				
					stdout.put( "off." nl );
					
				endif;
				

			  
			  pat.alternate
			  
				pat.matchiStr( "LOAD" );
				pat.oneOrMoreWS();
				pat.arb();
				pat.extract( filename );
				pat.EOS();
				
				str.trim( filename );
				
				// Do the equivalent of the NEW command here.
				//
				// Clear program text area.
				
				mov( &PgmSpace, edi );
				mov( edi, TxtStart );		// Start of BASIC program area.
				mov( edi, TxtEnd   );		// End of BASIC program area.	
				
				// Clear out all existing variables and
				// create a new variable table.

				Vars.destroy( &FreeVars );
				mov( table.create( 1000 ), Vars );
				
				// Handle the "LOAD" command here.
				
			  	fileio.open( filename, fileio.r );
				if( eax = win.INVALID_HANDLE_VALUE ) then
				
					stdout.put( "Could not open file: '", filename, "'" nl );
					raise( BasicError );
				
				endif;
				
				mov( eax, fileHandle );
				while( !fileio.eof( fileHandle )) do
				
					fileio.gets( fileHandle, inputLine );
					pat.match( inputLine )

						pat.zeroOrMoreWS();
						pat.oneOrMoreCset( {'0'..'9'} );
						pat.extract( LineNumberStr );
						pat.arb();
						pat.extract( LineStr );
						
						// We've got a line that starts with a number
						// Go process that line.
						
						try
						
							ParseLine( LineNumberStr, LineStr );
							
						  anyexception
						  
						  	stdout.put
							( 
								"Error during LOAD:" nl nl,
								inputLine,
								nl nl
							);
							
						  	cmp( eax, BasicError );
							je HandleException;
							
							if( eax = StmtTooLongException ) then
							
						  		stdout.put
								( 
									"Input line too long to process" nl 
								);
								jmp HandleException;
								
							endif;
							
							if( eax = SyntaxErrorException ) then
							
						  		stdout.put
								( 
									"Syntax error in statement" nl 
								);
								jmp HandleException;
								
							endif;
							
							if( eax = LabelSyntaxException ) then
							
						  		stdout.put
								( 
									"Illegal statement label "
									"(too long or bad chars)" nl 
								);
								jmp HandleException;
								
							endif;
							
							if( eax = ExprSyntaxException ) then
							
						  		stdout.put
								( 
									"Expression syntax error" nl 
								);
								jmp HandleException;
								
							endif;
							
							// If we fall through to this point,
							// we've got a problem - it's not an
							// exception that ParseStmt normally
							// generates.  Do the HLA exception
							// handler and then continue.							
							
							ex.printExceptionError
							(
								eax, ebx, ecx, edx, edi
							);
							
						  HandleException:
							
						endtry;
						
					  pat.if_failure
					  
					  	// If the input line doesn't begin with
						// a line number followed by some text,
						// print the following message:
						
					  	stdout.put
						( 
							"Illegal statement in file:" nl,
							inputLine,
							nl
						);
						
					pat.endmatch;
					
				
				endwhile;
			  	fileio.close( fileHandle );
				
				// Reset the x86 stack pointers and then
				// restart the surrounding FOR loop (we can't
				// just fall through because this messes up
				// the data that the pat.match and try..endtry
				// statements have put on the stack).
				 
				cld();
				mov( Sstack, esp );
				mov( MainsEBP, ebp );
				continue;
				
			  
			  
			  
			  pat.alternate
			  
				// Handle the "SAVE" command here.

				pat.matchiStr( "SAVE" );
				pat.oneOrMoreWS();
				pat.arb();
				pat.extract( filename );
				pat.EOS();
				
				str.trim( filename );
				
			  	fileio.openNew( filename );
				if( eax = win.INVALID_HANDLE_VALUE ) then
				
					stdout.put( "Could not create file: '", filename, "'" nl );
					raise( BasicError );
				
				endif;
				mov( eax, fileHandle );
				ListProc( 1, 65535, fileHandle );
				fileio.close( fileHandle );
				
			  
			  pat.alternate
			  
				pat.matchiStr( "QUIT" );
				pat.EOS();
				
				// Handle the QUIT command here.
				
				exit MiniBASIC;
				
			  pat.if_failure
			  
			  	stdout.put( "Illegal command!" nl );
				
			pat.endmatch;
				
		  exception( BasicError );
		  
		  	// Don't really need to do anything here other than to
			// clean up junk on the stack (below) and begin processing
			// user commands.
			
		  exception( LineNumberException )
		  
		  	// The user has entered an illegal line number.
			// Display an appropriate message and loop back around
			// for the next command.
			
		  	stdout.put( "Line number must be in the range 1..65535" nl );
			
		  exception( NoSuchLineException )
		  
		  	stdout.put( "Line number specified does not exist in program" nl );
			
		  exception( StmtTooLongException )
		  
		  	stdout.put( "Input line too long to process" nl );
			
		  exception( SyntaxErrorException )
		  
		  	stdout.put( "Syntax error in statement" nl );
			
		  exception( LabelSyntaxException )
		  
		  	stdout.put( "Illegal statement label (too long or bad chars)" nl );
			
		  exception( ExprSyntaxException )
		  
		  	stdout.put("Expression syntax error" nl );
			
		  exception( RtnWOGosubException )
		  
		  	// Run-time code already printed the appropriate
			// error message.  All we've got to do is flow
			// back into the command loop.
			
		  exception( PgmStopException )
		  
		  	// Don't need to do anything special here.
			// The run time code has already printed an
			// appropriate message.  We just need to loop
			// back into the command loop.
			
			
		  exception( BadPgmDataException )
		  
		  	stdout.put( "Corrupted program file!" nl );
			
		  anyexception
		  
		  	// We've got a general HLA error.  Call the HLA
			// PrintException function to display the appropriate
			// error message and then loop back around for the
			// next command.
			
			ex.printExceptionError( eax, ebx, ecx, edx, edi );
			
		endtry;
	
		mov( Sstack, esp );		// Clean up junk on stack.
		mov( MainsEBP, ebp );
		
	endfor;
		
end MiniBASIC; 
 
 
