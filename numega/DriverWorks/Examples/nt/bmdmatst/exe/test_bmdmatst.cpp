// Test_BMDmaTst.cpp
//
// Generated by DriverWizard version 2.02
//
// This console application demonstrates how to open a handle
// to a device in your driver, and communicate with the driver
// using Read, Write, and DeviceIoControl calls, as appropriate.
//
// This test program attempts to open the device with link name
// $ $linkname$ $, which corresponds to Unit 0 of the 
// BMDmaTstDevice device class in the driver.

//
// You can build this application using the command line compiler with
// the following command:
//
//		cl Test_BMDmaTst.cpp
//


#include <stdlib.h>
#include <stdio.h>
#include <windows.h>



typedef void VOIDFUNC();

// Prototypes
void Usage(void);

void CloseIfOpen(void);
void doRead(int i);
void doWrite(int i);

// Global data



// Handle to device opened in driver.
//
HANDLE	hDevice = INVALID_HANDLE_VALUE;

// Name used to open device
//
char *sLinkName = "\\\\.\\BMDmaTstDevice0";

////////////////////////////////////////////////////////////////////////
// OpenByName
//
//		Open a handle to the requested device
//
HANDLE OpenByName(void)
{
	// Create a handle to the driver
	return CreateFile(sLinkName,
					  GENERIC_READ | GENERIC_WRITE,
					  FILE_SHARE_READ,
					  NULL,
					  OPEN_EXISTING,
					  0,
					  NULL);
}



////////////////////////////////////////////////////////////////////////
// Exit
//
//		Print a message and exit   
//
   void Exit(int res)
{
	printf("Exiting...\n\n");
	CloseIfOpen();
	exit(res);
}


////////////////////////////////////////////////////////////////////////
// Main entry point
//
//
int __cdecl main(int argc, char *argv[])
{
	int		nArgIndex;				// Walk through command line arguments
	int		val;

	printf("Test application Test_BMDmaTst starting...\n");

	hDevice = OpenByName();
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("ERROR opening device: (%0x) returned from CreateFile\n", GetLastError());
		Exit(1);
	}
	else
	{
		printf("Device found, handle open.\n");
	}


	// Parse the command line

	if (argc < 2) Usage();

	nArgIndex = 1;
	while (nArgIndex < argc)
	{
		// Parse ahead to determine numeric value of argument

		if (nArgIndex+1 >= argc) Usage();
		if (!isdigit(argv[nArgIndex+1][0])) Usage();
		val = atoi(argv[nArgIndex+1]);

		switch (argv[nArgIndex][0])
		{

			case 'r':
			case 'R':
				doRead(val);
				break;

			case 'w':
			case 'W':
				doWrite(val);
				break;

			case 'i':
			case 'I':
			   printf("No IO Control Codes defined\n");
			   Exit(1);

			case '?':
			case 'h':
			default:
				Usage();
		}
		nArgIndex += 2;
	}

	return 0;
}


////////////////////////////////////////////////////////////////////////
// CloseIfOpen
//
//		Close the device if we previously opened a handle to it.
//
void CloseIfOpen(void)
{
	if (hDevice != INVALID_HANDLE_VALUE)
	{
		// Close the handle to the driver
		if (!CloseHandle(hDevice))
		{
			printf("ERROR: CloseHandle returns %0x.\n", GetLastError());
		}
		hDevice = INVALID_HANDLE_VALUE;
	}
}


////////////////////////////////////////////////////////////////////////
// doRead
//
//		Read 'n' bytes of data from the device
//
// Note: This simple test app reads data from the device and displays the
//			data as characters.  This behavior can be modified as appropriate
//			for your device.
//
void doRead(int n)
{
	char	*buf;
	ULONG	nRead;
	int		i;
	int		j;

	buf = (char *) malloc(n);
	if (buf == NULL)
	{
		printf("Failed to allocate buffer for read");
		Exit(1);
	}

	// Read data from driver
	printf("Reading from device - ");
	ReadFile(hDevice, buf, n, &nRead, NULL);
	printf("%d bytes read from device (%d requested).\n", nRead, n);

	// Print what was read
	i = 0;
	while(i < n)
	{
		j = min((i+26),n);
		for(; i < j; i++)
		{
			printf("%c, ", buf[i]);
		}
		printf("\n");
	}
	
	free(buf);
}


////////////////////////////////////////////////////////////////////////
// doWrite
//
//		Write 'n' bytes of data to the device
//
// Note: This simple test app writes sequential characters to the
// 			device.  This behavior can be modified as appropriate
//			for your device.
//
void doWrite(int n)
{
	char	*buf;
	ULONG	nWritten;
	int		i;
	int		j;

	buf = (char *) malloc(n);
	if (buf == NULL)
	{
		printf("Failed to allocate buffer for write");
		Exit(1);
	}

	// start with the mod26 letter of the number of bytes to write
	j = (n % 26);
	// load buffer with dummy data (abcdefg...)
	for (i=0; i<n; i++, j=(j + 1)%26)
	{
		buf[i] = 'a' + j;
	}
	
	// Write data to driver
	printf("Writing to device - ");
	WriteFile(hDevice, buf, n, &nWritten, NULL);
	printf("%d bytes written to device (%d attempted).\n", nWritten, n);

	// Print what was written
	i = 0;
	while(i < n)
	{
		j = min((i+26),n);
		for(; i < j; i++)
		{
			printf("%c, ", buf[i]);
		}
		printf("\n");
	}

	free(buf);
}


////////////////////////////////////////////////////////////////////////
// Usage
//
//		Print a usage message describing arguments to this program
//
void Usage(void)
{
	printf("Usage: Test_BMDmaTst [r n] [w n] [i n]\n");
	printf("       r initiates a read of specified number of bytes\n");
	printf("       w initiates a write of specified number of bytes\n");
	printf("       i initiates an IO Control Code message with specified index value\n");
    printf("         (no IO Control Codes are defined)\n");
	printf("Example:\n");
	printf("    Test_BMDmaTst r 32 w 32\n");
	printf("        read 32 bytes, then write 32 bytes\n");

	Exit(1);
}


