// BMDmaTst.cpp
//
// Generated by DriverWizard version 2.02
// Requires Compuware's DriverWorks classes

#define VDW_MAIN
#include <vdw.h>
#include "function.h"
#include "BMDmaTst.h"
#include "BMDmaTstDevice.h"


#pragma hdrstop("BMDmaTst.pch")

// Generated by DriverWizard version 2.02

// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in debug builds.  Use KTrace if
//			you want trace messages to always appear.	

	// Create the global driver trace object
	KTrace t("BMDmaTst");

/////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(BMDmaTst, NULL)

/////////////////////////////////////////////////////////////////////
// Driver Entry
// 
//	This routine is called when the driver is loaded.
//	Usually, this is where any devices associated with
//	the driver are created.
//
//  The driver often reads the registry at DriverEntry in
//	order to setup various configurable parameters.
//		
//	DriverWorks makes it easy to use the registry to also
//	control what devices are present and should be created.
//
NTSTATUS BMDmaTst::DriverEntry(PUNICODE_STRING RegistryPath)
{
	NTSTATUS status;			// Status of device creation

	t << "In DriverEntry\n";

	// Set default pool tag for all 'new' allocations to "New ".
	// Under the checked build, use the DDK POOLMON utility
	// to view the memory pool
	SetPoolTag(' weN');

	// Open the "Parameters" key under the driver
	KRegistryKey Params(RegistryPath, L"Parameters");
	if ( NT_SUCCESS(Params.LastError()) )
	{
#if DBG
		ULONG bBreakOnEntry = FALSE;
			// Read "BreakOnEntry" value from registry
		Params.QueryValue(L"BreakOnEntry", &bBreakOnEntry);
			// If requested, break into debugger
		if (bBreakOnEntry) DbgBreakPoint();

#endif
		// Load driver data members from the registry
		LoadRegistryParameters(Params);
	}

// TODO:	If you want multiple instances of this device,
//			edit the following code to create (using 'new') additional
//			instances of the class "BMDmaTstDevice".
//			For example, a serial driver with 6 ports would create 6
//			6 instances of the class, one for each port.
//
//			You can create a fixed number of devices by looping here,
//			or create an instance of KConfigurationQuery to scan the
//			registry to determine how many devices to create.   

// Create BMDmaTstDevice using placement new()

	KUnitizedName uName(L"BMDmaTstDevice", 0);
	BMDmaTstDevice* pBMDmaTstDevice = new (
						uName, FILE_DEVICE_UNKNOWN, uName, 0, DO_DIRECT_IO)
							BMDmaTstDevice;

	if (pBMDmaTstDevice == NULL)
	{
		t << "Error constructing device BMDmaTstDevice" << EOL;
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	status = pBMDmaTstDevice->ConstructorStatus();
	if (!NT_SUCCESS(status))
	{
		// Error returned from a constructor
		t << "Error creating device BMDmaTstDevice, status " << (ULONG) status << EOL;
		delete pBMDmaTstDevice;
		return status;
	}
	// If no errors returned during device construction, return success code.
	return STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////////
// Load Registry Parameters
//
// Load driver data members from the registry.
// The parameters are found as values under the "Parameters" key,	
// HKLM\SYSTEM\CurrentControlSet\Services\BMDmaTst\Parameters\...
// 
// Input
//   Params		Open registry key pointing to "Parameters"
//
// Return
//	 none		(Data members are loaded)
//			
void BMDmaTst::LoadRegistryParameters(KRegistryKey &Params)
{

	m_bBreakOnEntry = FALSE;
	Params.QueryValue(L"BreakOnEntry", &m_bBreakOnEntry);
	t << "m_bBreakOnEntry loaded from registry, resulting value: [" << m_bBreakOnEntry << "]\n";

}



#pragma code_seg()

//	Unload is responsible for releasing any system objects that
//	the driver has allocated. 
//
//	In general, this function must comprehensively ensure that
//	the driver is not unloaded while holding system objects,
//	including memory, or while there are pending events that
//	would cause the system to call the driver. This is best done
//	by deconstructing top level objects, which in turn release
//	objects for which they are responsible.
//
//	This function is called at PASSIVE_LEVEL.
//
VOID BMDmaTst::Unload(VOID)
{
	t << "Unload called\n";
   // If you don't need to perform any functions
   // except to call the base class KDriver::Unload(),
   // then this entire routine may be safely deleted.

    // Call base class to delete all devices.
	KDriver::Unload();
}
