// IPFilterHookDevice.cpp
// Implementation of IPFilterHookDevice device class
//
// Generated by DriverWizard version DriverStudio 2.0.1 (Build 36)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>

#include "IPFilterHook.h"
#include "IPFilterHookDevice.h"
#include "..\IPFilterHookioctl.h"

#pragma warning(disable:4065) // Allow switch statement with no cases

extern	KTrace	t;			// Global driver trace object	

// IP Packet Hook Filter
#include "mykipfilter.h"
myKIPFilter theHook;

////////////////////////////////////////////////////////////////////////
// IPFilterHookDevice::~IPFilterHookDevice
//
//	Routine Description:
//		This is the destructor for the IPFilterHookDevice
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		Disconnect and release resources here.
//
//		Although the use of SAFE_DESTRUCTORS in the class definition cures
//		improper emission of the destructor into the INIT section most of the
//		time, certain rare cases can still cause improper behavior.  To avoid
//		these cases, the destructor	must preceed the INIT section, causing it
//		to be referenced first by the default compiler section.
//

IPFilterHookDevice::~IPFilterHookDevice()
{
	delete m_RegPath;
}

#pragma code_seg("INIT")

////////////////////////////////////////////////////////////////////////////////
//  IPFilterHookDevice::IPFilterHookDevice
//
//	Routine Description:
//		The device constructor is typically responsible for allocating
//		any physical resources that are associated with the device.
//
//	Parameters:
//		Unit - Unit number. This is a number to append to the device's
//			base device name to distinguish multiple units of this
//			device type.
//
//	Return Value:
//		None
//
//	Comments:
//		The device constructor often reads the registry to setup
//		various configurable parameters.

IPFilterHookDevice::IPFilterHookDevice(ULONG Unit) :
	KDevice()
{
	if ( ! NT_SUCCESS(m_ConstructorStatus) )
	{
		t << "Failed to create device IPFilterHookDevice unit number " << Unit << " status " << (ULONG) m_ConstructorStatus << EOL;
		return;
	}
	m_Unit = Unit;

	m_RegPath = CreateRegistryPath(L"IPFilterHookDevice", Unit);
	if (m_RegPath == NULL)
	{
		// Error, cannot allocate memory for registry path
		t << "Failed to create registry path\n";
		m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;
		return;
	}

}
#pragma code_seg()

////////////////////////////////////////////////////////////////////////
//  IPFilterHookDevice::DeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_DEVICE_CONTROL
//
//	Parameters:
//		I - Current IRP
// 
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		This routine is the first handler for Device Control requests.

NTSTATUS IPFilterHookDevice::DeviceControl(KIrp I) 
{
	NTSTATUS status;

	t << "Entering IPFilterHookDevice::Device Control, " << I;
	switch (I.IoctlCode())
	{
		case IPFILTERHOOK_IOCTL_SetHook:
		    status = IPFILTERHOOK_IOCTL_SetHook_Handler(I);
			break;

		case IPFILTERHOOK_IOCTL_ClearHook:
		    status = IPFILTERHOOK_IOCTL_ClearHook_Handler(I);
			break;

		default:
			// Unrecognized IOCTL request
			status = STATUS_INVALID_PARAMETER;
			break;
	}

	// If the IRP's IOCTL handler deferred processing using some driver
	// specific scheme, the status variable is set to STATUS_PENDING.
	// In this case we simply return that status, and the IRP will be
	// completed later.  Otherwise, complete the IRP using the status
	// returned by the IOCTL handler.
	if (status == STATUS_PENDING)
	{
		return status;
	}
	else
	{
		return I.Complete(status);
	}
}

////////////////////////////////////////////////////////////////////////
//  IPFilterHookDevice::IPFILTERHOOK_IOCTL_SetHook_Handler
//
//	Routine Description:
//		Handler for IO Control Code IPFILTERHOOK_IOCTL_SetHook
//
//	Parameters:
//		I - IRP containing IOCTL request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the IPFILTERHOOK_IOCTL_SetHook function.
//		This routine runs at passive level.
//

NTSTATUS IPFilterHookDevice::IPFILTERHOOK_IOCTL_SetHook_Handler(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering IPFilterHookDevice::IPFILTERHOOK_IOCTL_SetHook_Handler, " << I << EOL;
	I.Information() = 0;
	theHook.Initialize();
	return status;
}

////////////////////////////////////////////////////////////////////////
//  IPFilterHookDevice::IPFILTERHOOK_IOCTL_ClearHook_Handler
//
//	Routine Description:
//		Handler for IO Control Code IPFILTERHOOK_IOCTL_ClearHook
//
//	Parameters:
//		I - IRP containing IOCTL request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the IPFILTERHOOK_IOCTL_ClearHook function.
//		This routine runs at passive level.
//

NTSTATUS IPFilterHookDevice::IPFILTERHOOK_IOCTL_ClearHook_Handler(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering IPFilterHookDevice::IPFILTERHOOK_IOCTL_ClearHook_Handler, " << I << EOL;
	I.Information() = 0;
	theHook.Invalidate();
	return status;
}


////////////////////////////////////////////////////////////////////////
//  IPFilterHookDevice::Create
//
//	Routine Description:
//		Handler for IRP_MJ_CREATE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS IPFilterHookDevice::Create(KIrp I)
{
	t << "Entering Create, " << I;
	I.Information() = 0;
	return I.Complete(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  IPFilterHookDevice::Close
//
//	Routine Description:
//		Handler for IRP_MJ_CLOSE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS IPFilterHookDevice::Close(KIrp I)
{
	t << "Entering Close, " << I;
	I.Information() = 0;
	return I.Complete(STATUS_SUCCESS);
}





