// IPFilterHook.cpp
//
// Generated by DriverWizard version DriverStudio 2.0.1 (Build 36)
// Requires Compuware's DriverWorks classes
//

#define VDW_MAIN
#include <vdw.h>
#include "function.h"
#include "IPFilterHook.h"
#include "IPFilterHookDevice.h"
#include <KIpFilterHook.cpp>

#pragma hdrstop("IPFilterHook.pch")

// Set a default 32-bit tag value to be stored with each heap block
// allocated by operator new. Use BoundsChecker to view the memory pool.
// This value can be overridden using the global function SetPoolTag().
POOLTAG DefaultPoolTag('iFPI');

// Create the global driver trace object
// TODO:	Use KDebugOnlyTrace if you want trace messages
//			to appear only in debug builds.  Use KTrace if
//			you want trace messages to always appear.	
KTrace t("IPFilterHook");

/////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(IPFilterHook, NULL)

/////////////////////////////////////////////////////////////////////
//  IPFilterHook::DriverEntry
// 
//	Routine Description:
//		This routine is called when the driver is loaded.
//
//	Parameters:
//		RegistryPath - String used to find driver parameters in the
//			registry.  To locate IPFilterHook look for:
//			HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\IPFilterHook
//
//	Return Value:
//		NTSTATUS - Return STATUS_SUCCESS if no errors are encountered.
//			Any other indicates to the system that an error has occured.
//
//	Comments:
//		Usually, this is where any devices associated with
//		the driver are created.
//
//		The driver often reads the registry at DriverEntry in
//		order to setup various configurable parameters.
//		
//		DriverWorks makes it easy to use the registry to also
//		control what devices are present and should be created.
//

NTSTATUS IPFilterHook::DriverEntry(PUNICODE_STRING RegistryPath)
{
	NTSTATUS status;			// Status of device creation

	t << "In DriverEntry\n";

	// Open the "Parameters" key under the driver
	KRegistryKey Params(RegistryPath, L"Parameters");
	if ( NT_SUCCESS(Params.LastError()) )
	{
		// Load driver data members from the registry
		LoadRegistryParameters(Params);
	}

	int Unit;

// TODO:	If you want multiple instances of this device,
//			edit the following code to create (using 'new') additional
//			instances of the class "IPFilterHookDevice".
//			For example, a serial driver with 6 ports would create 6
//			6 instances of the class, one for each port.
//
//			You can create a fixed number of devices by looping here,
//			or create an instance of KConfigurationQuery to scan the
//			registry to determine how many device to create.   
	Unit = 0;

	// Create IPFilterHookDevice. Note that we used a form of "placement" new,
	// that is a member operator of KDevice.  This form will use storage
	// allocated by the system in the device object's device to store our
	// class instance.
	IPFilterHookDevice* pIPFilterHookDevice;
	pIPFilterHookDevice = new (
			static_cast<PCWSTR>(KUnitizedName(L"IPFilterHookDevice", Unit)),
			FILE_DEVICE_UNKNOWN,
			static_cast<PCWSTR>(KUnitizedName(L"IPFilterHookDevice", Unit)), 
			0,
			DO_BUFFERED_IO
			)
		IPFilterHookDevice();

	if (pIPFilterHookDevice == NULL)
	{
		t << "Error constructing device IPFilterHookDevice" << EOL;
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	status = pIPFilterHookDevice->ConstructorStatus();
	if (!NT_SUCCESS(status))
	{
		// Error returned from a constructor
		t << "Error creating device IPFilterHookDevice, status " << (ULONG) status << EOL;
		delete pIPFilterHookDevice;
		return status;
	}
	// If no errors returned during device construction, return success code.
	return STATUS_SUCCESS;
}

/////////////////////////////////////////////////////////////////////
//  IPFilterHook::LoadRegistryParameters
//
//	Routine Description:
//		Load driver data members from the registry.
// 
//	Parameters:
//		Params - Open registry key pointing to "Parameters"
//
//	Return Value:
//		None
//
//	Comments:
//		The parameters are found as values under the "Parameters" key,	
//		HKLM\SYSTEM\CurrentControlSet\Services\IPFilterHook\Parameters\...
//			

void IPFilterHook::LoadRegistryParameters(KRegistryKey &Params)
{

	m_bBreakOnEntry = FALSE;
	Params.QueryValue(L"BreakOnEntry", &m_bBreakOnEntry);
	t << "m_bBreakOnEntry loaded from registry, resulting value: [" << m_bBreakOnEntry << "]\n";

}



#pragma code_seg()

/////////////////////////////////////////////////////////////////////
//  IPFilterHook::Unload
// 
//	Routine Description:
//		This routine is called when the driver is unloaded.
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		Unload is responsible for releasing any system objects that
//		the driver has allocated. 
//
//		In general, this function must comprehensively ensure that
//		the driver is not unloaded while holding system objects,
//		including memory, or while there are pending events that
//		would cause the system to call the driver. This is best done
//		by deconstructing top level objects, which in turn release
//		objects for which they are responsible.
//
//		This function is called at PASSIVE_LEVEL.
//

VOID IPFilterHook::Unload(VOID)
{
	t << "Unload called\n";
   // If you don't need to perform any functions
   // except to call the base class KDriver::Unload(),
   // then this entire routine may be safely deleted.

    // Call base class to delete all devices.
	KDriver::Unload();
}
