// HotPciDrv.cpp - main module for HotII driver 
// Copyright (c) 1998 Virtual Computer Corporation
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 1998 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================

#define VDW_MAIN
#include <vdw.h>		// include the Driver::Works classes
#include "HotPciDrv.h"	// include the definitions for this driver
#include "HotPciDev.h"	// include the definitions for our device class
#include "HotPciLog.h"	// message identifiers (auto generated by mc)
 
KDebugOnlyTrace T("HotPci");

//////////////////////////////////////////////////////////////////////
// Begin INIT section code
//
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(HotPciDriver, NULL)

#if !_WDM_

//////////////////////////////////////////////////////////////////////
// This is the enumeration routine for non-WDM systems. 

NTSTATUS HotPciDriver::Enumerate(void)
{
	KPciSlot slot;
	USHORT VendorId;
	USHORT DeviceId;
	NTSTATUS status;
	BOOLEAN AtLeastOneBoardOk;

// Initialize
	status = STATUS_NO_SUCH_DEVICE;
	slot.Initialize();
	AtLeastOneBoardOk = FALSE;

// Enumerate the PCI cards in this machine
	while ( KPciConfiguration::Enumerate(slot, &VendorId, &DeviceId) )
	{ 

// Determine if the current device is a HotII board
		if ( (VendorId == HOTPCI_VENDOR_ID) && (DeviceId == HOTPCI_DEVICE_ID) )
		{

// If a HotII is found, create an instance of the device class
			KUnitizedName unitName(HOTPCI_NAME_STEM, m_UnitCount);
			HotPciDevice* pHotII = new (unitName, FILE_DEVICE_HOTII, unitName) HotPciDevice(slot, m_UnitCount);

// Now test the success of the device construction
			if ( pHotII != NULL )
			{
				status = pHotII->ConstructorStatus();
				if ( NT_SUCCESS(status) )
					AtLeastOneBoardOk = TRUE;
			}				
			else
				status = STATUS_INSUFFICIENT_RESOURCES;

// If a board was found but not successfully initialized, add an entry to the
// event log
			if ( !NT_SUCCESS(status) )
			{
				KErrorLogEntry::SimpleError(
					status,
					HOTII_FAILED_TO_INITIALIZE,
					1,
					NULL
					);

				if (pHotII != NULL) 
					delete pHotII;
			}

			m_UnitCount++;
		}
	}

// If at least one board was found and successfully initialized, return success.
// Otherwise, return the last error code
	if (AtLeastOneBoardOk)
		status = STATUS_SUCCESS;

	return status;
}

#endif // ! _WDM_

/////////////////////////////////////////////////////////////////////////
// DriverEntry - the system calls this function to initialize the driver
//
NTSTATUS HotPciDriver::DriverEntry(PUNICODE_STRING RegistryPath)
{

	m_UnitCount = 0;

#if !_WDM_

	NTSTATUS status = Enumerate();

// Log an event if no board is present
	
	if (status == STATUS_NO_SUCH_DEVICE)
	{
		KErrorLogEntry::SimpleError(
			status,
		 	HOTII_DEVICE_NOT_FOUND,
			2,
			NULL
			);
	}

	return status;

#else

	return STATUS_SUCCESS;

#endif // ! _WDM_
}

#pragma code_seg()
//
// End INIT Section code
//////////////////////////////////////////////////////////////////////


#if _WDM_

/////////////////////////////////////////////////////////////////////////
// AddDevice - the system calls this when the device is detected
//
NTSTATUS HotPciDriver::AddDevice(PDEVICE_OBJECT Pdo)
{
	T << "Add Device\n";

	KUnitizedName unitName(HOTPCI_NAME_STEM, m_UnitCount);
	HotPciDevice* pDev = new (unitName, FILE_DEVICE_HOTII, unitName) HotPciDevice(Pdo, m_UnitCount);

	if (pDev != NULL)
	{
		NTSTATUS status = pDev->ConstructorStatus();
		if ( !NT_SUCCESS(status) )
			delete pDev;
		else
			m_UnitCount++;

		return status;
	}
	else
		return STATUS_INSUFFICIENT_RESOURCES;
}

#endif // _WDM_
