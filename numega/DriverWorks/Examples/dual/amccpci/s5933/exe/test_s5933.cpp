// Test_S5933.cpp
//
// Generated by DriverWizard version 2.02
//
// This console application demonstrates how to open a handle
// to a device in your driver, and communicate with the driver
// using Read, Write, and DeviceIoControl calls, as appropriate.
//
// This test program attempts to open the device with link name
// S5933Device, which corresponds to Unit 0 of the 
// S5933Device device class in the driver.

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <mmsystem.h>

#include <winioctl.h>
#include "..\S5933ioctl.h"
#include <ks59xxrd.h>

typedef void VOIDFUNC();

// Prototypes
void Usage(void);
void ShowIoctlValues(void);
void Test_S5933_IOCTL_800_CHIP_RESET(void);
void Test_S5933_IOCTL_801_POST_MSG(int mbox, ULONG value);
void Test_S5933_IOCTL_802_RETRIEVE_MSG(int mbox);
void Test_S5933_IOCTL_803_WRITE_PASSTHRU(ULONG data);
void Test_S5933_IOCTL_804_WRITE_NVRAM(USHORT offset, USHORT count, UCHAR data, ULONG inc);
void Test_S5933_IOCTL_805_READ_NVRAM(USHORT offset, USHORT count);
void Test_S5933_IOCTL_806_DUMP_REGISTERS(void);

void CloseIfOpen(void);
void doRead(int i);
void doWrite(int i);

// Global data


#define N_IOCODES	7

// Names of IOCTL codes
//
char *IOnames[N_IOCODES+1] =
{
	"S5933_IOCTL_800_CHIP_RESET",
	"S5933_IOCTL_801_POST_MSG",
	"S5933_IOCTL_802_RETRIEVE_MSG",
	"S5933_IOCTL_803_WRITE_PASSTHRU",
	"S5933_IOCTL_804_WRITE_NVRAM",
	"S5933_IOCTL_805_READ_NVRAM",
	"S5933_IOCTL_806_DUMP_REGISTERS",
	""
};

// IOCTL codes
//
int IOcodes[N_IOCODES+1] =
{
	S5933_IOCTL_800_CHIP_RESET,
	S5933_IOCTL_801_POST_MSG,
	S5933_IOCTL_802_RETRIEVE_MSG,
	S5933_IOCTL_803_WRITE_PASSTHRU,
	S5933_IOCTL_804_WRITE_NVRAM,
	S5933_IOCTL_805_READ_NVRAM,
	S5933_IOCTL_806_DUMP_REGISTERS,
	0
};


// Handle to device opened in driver.
//
HANDLE	hDevice = INVALID_HANDLE_VALUE;

// Name used to open device (NT4 version of driver only)
//
char *sLinkName = "\\\\.\\S5933Device0";

////////////////////////////////////////////////////////////////////////
// OpenByName
//
//		Open a handle to the requested device
//
HANDLE OpenByName(void)
{
	// Create a handle to the driver
	return CreateFile(sLinkName,
					  GENERIC_READ | GENERIC_WRITE,
					  FILE_SHARE_READ,
					  NULL,
					  OPEN_EXISTING,
					  0,
					  NULL);
}



////////////////////////////////////////////////////////////////////////
// Exit
//
//		Print a message and exit   
//
   void Exit(int res)
{
	printf("Exiting...\n\n");
	CloseIfOpen();
	exit(res);
}


////////////////////////////////////////////////////////////////////////
// Main entry point
//
//
int __cdecl main(int argc, char *argv[])
{
	int		nArgIndex;				// Walk through command line arguments
	int		nArgIncrement = 0;
	int		val;
	int		mbox;
	ULONG	value;
	ULONG	data;
	ULONG	inc;
	USHORT	shortoffset;
	USHORT	shortcount;

	printf("Test application Test_S5933 starting...\n");

	hDevice = OpenByName();
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		printf("ERROR opening device: (%0x) returned from CreateFile\n", GetLastError());
		Exit(1);
	}
	else
	{
		printf("Device found, handle open.\n");
	}

	// Parse the command line

	if (argc < 2) Usage();

	nArgIndex = 1;
	while (nArgIndex < argc)
	{
		// Parse ahead to determine numeric value of argument

		if (nArgIndex+1 >= argc) Usage();
		if (!isdigit(argv[nArgIndex+1][0])) Usage();
		val = atoi(argv[nArgIndex+1]);

		switch (argv[nArgIndex][0])
		{

		case 'r':
		case 'R':
			if (nArgIndex+1 >= argc) Usage();
			if (!isdigit(argv[nArgIndex+1][0])) Usage();
			val = atoi(argv[nArgIndex+1]);
			doRead(val);
			nArgIncrement = 2;
			break;

		case 'w':
		case 'W':
			if (nArgIndex+1 >= argc) Usage();
			if (!isdigit(argv[nArgIndex+1][0])) Usage();
			val = atoi(argv[nArgIndex+1]);
			doWrite(val);
			nArgIncrement = 2;
			break;

		case 'i':
		case 'I':
			if (nArgIndex+1 >= argc) Usage();
			if (!isdigit(argv[nArgIndex+1][0])) Usage();
			val = atoi(argv[nArgIndex+1]);

			if (val >= N_IOCODES)
			{
				printf("IO control code index must be less than %d\n", N_IOCODES);
				ShowIoctlValues();
				Exit(1);
			}

			switch (IOcodes[val])
			{
			case S5933_IOCTL_800_CHIP_RESET:
				Test_S5933_IOCTL_800_CHIP_RESET();
				nArgIncrement = 2;
				break;

			case S5933_IOCTL_801_POST_MSG:
				if (nArgIndex+3 >= argc) Usage();
				mbox = atoi(argv[nArgIndex+2]);
				if (mbox < 1 || mbox > 4) Usage();
				value = strtoul(argv[nArgIndex+3], NULL, 0);

				Test_S5933_IOCTL_801_POST_MSG(mbox, value);
				nArgIncrement = 4;
				break;

			case S5933_IOCTL_802_RETRIEVE_MSG:
				if (nArgIndex+2 >= argc) Usage();
				mbox = atoi(argv[nArgIndex+2]);
				Test_S5933_IOCTL_802_RETRIEVE_MSG(mbox);
				nArgIncrement = 3;
				break;

			case S5933_IOCTL_803_WRITE_PASSTHRU:
				if (nArgIndex+2 >= argc) Usage();
				data = strtoul(argv[nArgIndex+2], NULL, 0);
				Test_S5933_IOCTL_803_WRITE_PASSTHRU(data);
				nArgIncrement = 3;
				break;

			case S5933_IOCTL_804_WRITE_NVRAM:
				if (nArgIndex+4 >= argc) Usage();
				shortoffset = static_cast<USHORT>(strtoul(argv[nArgIndex+2], NULL, 0));
				shortcount = static_cast<USHORT>(strtoul(argv[nArgIndex+3], NULL, 0));
				data = strtoul(argv[nArgIndex+4], NULL, 0);
				if (nArgIndex+5 >= argc || isalpha(argv[nArgIndex+5][0]))
				{
					inc = 0;
					nArgIncrement = 5;
				}
				else
				{
					inc = strtoul(argv[nArgIndex+5], NULL, 0);
					nArgIncrement = 6;
				}
				Test_S5933_IOCTL_804_WRITE_NVRAM(shortoffset, shortcount, 
					static_cast<UCHAR>(data), inc);
				break;

			case S5933_IOCTL_805_READ_NVRAM:
				if (nArgIndex+2 >= argc || isalpha(argv[nArgIndex+2][0]))
				{
					shortoffset = 0;
					shortcount = 0xffff;
					nArgIncrement = 2;
				}
				else
				{
					if (nArgIndex+3 >= argc) Usage();
					shortoffset = static_cast<USHORT>(strtoul(argv[nArgIndex+2], NULL, 0));
					shortcount = static_cast<USHORT>(strtoul(argv[nArgIndex+3], NULL, 0));
					nArgIncrement = 4;
				}

				Test_S5933_IOCTL_805_READ_NVRAM(shortoffset, shortcount);
				break;

			case S5933_IOCTL_806_DUMP_REGISTERS:
				Test_S5933_IOCTL_806_DUMP_REGISTERS();
				nArgIncrement = 2;
				break;

			default:
				printf("IO control code not valid\n");
				Exit(1);
			}
			break;

		case '?':
		case 'h':
		default:
			Usage();
		}
		nArgIndex += nArgIncrement;
	}

	return 0;
}


////////////////////////////////////////////////////////////////////////
// CloseIfOpen
//
//		Close the device if we previously opened a handle to it.
//
void CloseIfOpen(void)
{
	if (hDevice != INVALID_HANDLE_VALUE)
	{
		// Close the handle to the driver
		if (!CloseHandle(hDevice))
		{
			printf("ERROR: CloseHandle returns %0x.\n", GetLastError());
		}
		hDevice = INVALID_HANDLE_VALUE;
	}
}


////////////////////////////////////////////////////////////////////////
// doRead
//
//		Read 'n' bytes of data from the device
//
// Note: This simple test app reads data from the device and displays the
//			data as characters.  This behavior can be modified as appropriate
//			for your device.
//
void doRead(int n)
{
	char	*buf;
	ULONG	nRead;
	int		i;
	int		j;

	buf = (char *) malloc(n);
	if (buf == NULL)
	{
		printf("Failed to allocate buffer for read");
		Exit(1);
	}

	// Read data from driver
	printf("Reading from device - ");
    if (!ReadFile(hDevice, buf, n, &nRead, NULL))
	{
		printf("ERROR: ReadFile returns %0x.", GetLastError());
		Exit(1);
    }
	printf("%d bytes read from device (%d requested).\n", nRead, n);

	// Print what was read
	i = 0;
	while(i < n)
	{
		j = min((i+26),n);
		for(; i < j; i++)
		{
			printf("%c, ", buf[i]);
		}
		printf("\n");
	}
	
	free(buf);
}


////////////////////////////////////////////////////////////////////////
// doWrite
//
//		Write 'n' bytes of data to the device
//
// Note: This simple test app writes sequential characters to the
// 			device.  This behavior can be modified as appropriate
//			for your device.
//
void doWrite(int n)
{
	char	*buf;
	ULONG	nWritten;
	int		i;
	int		j;

	buf = (char *) malloc(n);
	if (buf == NULL)
	{
		printf("Failed to allocate buffer for write");
		Exit(1);
	}

	// start with the mod26 letter of the number of bytes to write
	j = (n % 26);
	// load buffer with dummy data (abcdefg...)
	for (i=0; i<n; i++, j=(j + 1)%26)
	{
		buf[i] = 'a' + j;
	}
	
	// Write data to driver
	printf("Writing to device - ");
    if (!WriteFile(hDevice, buf, n, &nWritten, NULL))
	{
		printf("ERROR: WriteFile returns %0x.", GetLastError());
		Exit(1);
    }
	printf("%d bytes written to device (%d attempted).\n", nWritten, n);

	// Print what was written
	i = 0;
	while(i < n)
	{
		j = min((i+26),n);
		for(; i < j; i++)
		{
			printf("%c, ", buf[i]);
		}
		printf("\n");
	}

	free(buf);
}


////////////////////////////////////////////////////////////////////////
// Usage
//
//		Print a usage message describing arguments to this program
//
void Usage(void)
{
	printf("Usage: Test_S5933 [r n] [w n] [i n ...]\n");
	printf("       r initiates a read of specified number of bytes\n");
	printf("       w initiates a write of specified number of bytes\n");
	printf("       i initiates an IO Control Code message with specified index value\n");
	ShowIoctlValues();
	printf("Example:\n");
	printf("    Test_S5933 r 32 w 32\n");
	printf("        open by name, read 32 bytes, then write 32 bytes\n");

	Exit(1);
}

////////////////////////////////////////////////////////////////////////
// Test_S5933_IOCTL_800_CHIP_RESET
//
void Test_S5933_IOCTL_800_CHIP_RESET(void)
{
	ULONG	nOutput;						// Count written to bufOutput
// Note that Input and Output are named from the point of view
// of the DEVICE:
//		bufInput  supplies data to the device
//		bufOutput is written by the device to return data to this application

	// Call device IO Control interface (S5933_IOCTL_800_CHIP_RESET) in driver
	printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 S5933_IOCTL_800_CHIP_RESET,
						 NULL,
						 0,
						 NULL,
						 0,
                         &nOutput,
						 NULL)
	   )
	{
		printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
		Exit(1);
	}
}

////////////////////////////////////////////////////////////////////////
// Test_S5933_IOCTL_801_POST_MSG
//
void Test_S5933_IOCTL_801_POST_MSG(int mbox, ULONG value)
{
	ULONG	nOutput;						// Count written to bufOutput
    KS5933_MAILBOX_MESSAGE message;

    message.MessageMailBox = mbox;
    message.MessageValue = value;

	// Call device IO Control interface (S5933_IOCTL_801_POST_MSG) in driver
	printf("Issuing Ioctl to device - \n");
    if (!DeviceIoControl(hDevice, 
                         S5933_IOCTL_801_POST_MSG,
                         &message,
                         sizeof(message),
                         NULL,
                         0,
                         &nOutput,
                         NULL))
	{
		printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
		Exit(1);
    }
}

////////////////////////////////////////////////////////////////////////
// Test_S5933_IOCTL_802_RETRIEVE_MSG
//
void Test_S5933_IOCTL_802_RETRIEVE_MSG(int mbox)
{
	ULONG	nOutput;						// Count written to bufOutput
    KS5933_MAILBOX_MESSAGE message;

    message.MessageMailBox = mbox;
    message.MessageValue = 0;

	// Call device IO Control interface (S5933_IOCTL_801_POST_MSG) in driver
	printf("Issuing Ioctl to device - \n");
    if (!DeviceIoControl(hDevice, 
                         S5933_IOCTL_802_RETRIEVE_MSG,
                         &message,
                         sizeof(message),
                         &message,
                         sizeof(message),
                         &nOutput,
                         NULL))
	{
		printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
		Exit(1);
    }
	printf(" Message received from mailbox %d with value 0x%08X\n\n",
		message.MessageMailBox, message.MessageValue);
}

////////////////////////////////////////////////////////////////////////
// Test_S5933_IOCTL_803_WRITE_PASSTHRU
//
void Test_S5933_IOCTL_803_WRITE_PASSTHRU(ULONG data)
{
	ULONG	nOutput;						// Count written to bufOutput
    KS5933_PASSTHRU pthru;

    pthru.Data = data;

	// Call device IO Control interface (S5933_IOCTL_803_WRITE_PASSTHRU) in driver
	printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 S5933_IOCTL_803_WRITE_PASSTHRU,
						 &pthru,
						 sizeof(pthru),
						 NULL,
						 0,
						 &nOutput,
						 NULL)
	   )
	{
		printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
		Exit(1);
	}
}

////////////////////////////////////////////////////////////////////////
// Test_S5933_IOCTL_804_WRITE_NVRAM
//
void Test_S5933_IOCTL_804_WRITE_NVRAM(USHORT offset, USHORT count, UCHAR data, ULONG inc)
{

	ULONG	nOutput;
	PKS5933_NVRAM pNvram;
	ULONG	i;

	pNvram = (PKS5933_NVRAM)calloc((sizeof(KS5933_NVRAM) - 1 + count), 1);
	if (pNvram == NULL) 
	{
		printf("Alloc failed\n");
		Exit(1);
	}
	pNvram->Offset = offset;
	pNvram->Count = count;
	for (i=0; i<count; i++)
	{
		pNvram->Data[i] = data;
		data += (UCHAR)inc;
	}

	// Set the timer resolution to 1ms.  If we don't do this, the default
	// timer tick (usually 10ms) will be used when delaying thread execution
	// during polling to determine when each byte access to the S5933's
	// NVRAM is finished.
	MMRESULT Err = timeBeginPeriod(1);
	if (Err == TIMERR_NOCANDO)
	{
		printf("Can't set timer to 1ms.\n");
		Exit(1);
	}

	// Call device IO Control interface (S5933_IOCTL_805_READ_NVRAM) in driver
	printf("Issuing Ioctl to device - \n");
	if (!DeviceIoControl(hDevice,
						 S5933_IOCTL_804_WRITE_NVRAM,
						 pNvram,
						 (sizeof(KS5933_NVRAM) - 1 + count),
						 pNvram,
						 (sizeof(KS5933_NVRAM) - 1 + count),
						 &nOutput,
						 NULL)
	   )
	{
		printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
		Exit(1);
	}

	// Set the timer tick resolution back.
	timeEndPeriod(1);

	free(pNvram);
}

////////////////////////////////////////////////////////////////////////
// Test_S5933_IOCTL_805_READ_NVRAM
//
void Test_S5933_IOCTL_805_READ_NVRAM(USHORT offset, USHORT count)
{

	ULONG	nOutput;
    KS5933_NVRAM nvram;
	PKS5933_NVRAM pNvram;
	UCHAR	blocks;
	ULONG	size;
	ULONG	i;
	ULONG	j;
	ULONG	k;

    nvram.Offset = 2;
    nvram.Count = 1;
    *nvram.Data = 0;

	// Call device IO Control interface (S5933_IOCTL_805_READ_NVRAM) in driver
	printf("Issuing Ioctl to device - \n");
	if (!DeviceIoControl(hDevice,
						 S5933_IOCTL_805_READ_NVRAM,
						 &nvram,
						 sizeof(nvram),
						 &nvram,
						 sizeof(nvram),
						 &nOutput,
						 NULL)
	   )
	{
		printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
		Exit(1);
	}

	blocks = *nvram.Data;
	size = blocks * 512;
	printf("Number of blocks found %d\n", blocks);
	printf("Size of Nvram memory %d bytes\n", size);

	if (size > 0)
	{
		if (count == 0xffff)
		{
			offset = 0;
			count = static_cast<USHORT>(size);
		}

		pNvram = (PKS5933_NVRAM)calloc((sizeof(KS5933_NVRAM) - 1 + count), 1);

		if (pNvram == NULL) 
		{
			printf("Alloc failed\n");
			Exit(1);
		}

		pNvram->Offset = offset;
		pNvram->Count = count;

		// Set the timer resolution to 1ms.  If we don't do this, the default
		// timer tick (usually 10ms) will be used when delaying thread execution
		// during polling to determine when each byte access to the S5933's
		// NVRAM is finished.
		MMRESULT Err = timeBeginPeriod(1);
		if (Err == TIMERR_NOCANDO)
		{
			printf("Can't set timer to 1ms.\n");
			Exit(1);
		}

		// Call device IO Control interface (S5933_IOCTL_805_READ_NVRAM) in driver
		printf("Issuing Ioctl to device - \n");
		if (!DeviceIoControl(hDevice,
							 S5933_IOCTL_805_READ_NVRAM,
							 pNvram,
							 (sizeof(KS5933_NVRAM) - 1 + count),
							 pNvram,
							 (sizeof(KS5933_NVRAM) - 1 + count),
							 &nOutput,
							 NULL)
		   )
		{
			printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
			Exit(1);
		}

		// Set the timer tick resolution back.
		timeEndPeriod(1);

		i = 0;
		while(i < count)
		{
			printf("Offset %04X    ", i + offset);
			for(j=min((i+16),count); i < j;)
			{
				for(k=min((i+4), count); i < k; i++)
				{
					printf("%02X", (pNvram->Data)[i]);
				}
				printf(" ");
			}
			printf("\n");
		}

		free(pNvram);
	}
	else
		printf("No Nvram\n");
}

////////////////////////////////////////////////////////////////////////
// Test_S5933_IOCTL_806_DUMP_REGISTERS
//
void Test_S5933_IOCTL_806_DUMP_REGISTERS(void)
{

	AMCCS5933_PCI_BUS_OPERATION_REGISTERS regs;	// Output from device
	ULONG	nOutput;						// Count written to bufOutput

	// Call device IO Control interface (S5933_IOCTL_806_DUMP_REGISTERS) in driver
	printf("Issuing Ioctl to device - ");
	if (!DeviceIoControl(hDevice,
						 S5933_IOCTL_806_DUMP_REGISTERS,
						 NULL,
						 0,
						 &regs,
						 sizeof(regs),
						 &nOutput,
						 NULL)
	   )
	{
		printf("ERROR: DeviceIoControl returns %0x.", GetLastError());
		Exit(1);
	}

	printf("AMCC S5933 PCI Registers:\n");
	printf("	OutgoingMailbox1:		0x%08X\n", regs.OutgoingMailbox1);
	printf("	OutgoingMailbox2:		0x%08X\n", regs.OutgoingMailbox2);
	printf("	OutgoingMailbox3:		0x%08X\n", regs.OutgoingMailbox3);
	printf("	OutgoingMailbox4:		0x%08X\n", regs.OutgoingMailbox4);
	printf("	IncomingMailbox1:		0x%08X\n", regs.IncomingMailbox1);
	printf("	IncomingMailbox2:		0x%08X\n", regs.IncomingMailbox2);
	printf("	IncomingMailbox3:		0x%08X\n", regs.IncomingMailbox3);
	printf("	IncomingMailbox4:		0x%08X\n", regs.IncomingMailbox4);
	printf("	FIFORegisterPort:		Not Read\n"); 
	printf("	MasterWriteAddress:		0x%08X\n", regs.MasterWriteAddress);
	printf("	MasterWriteTransferCount:	0x%08X\n", regs.MasterWriteTransferCount);
	printf("	MasterReadAddress:		0x%08X\n", regs.MasterReadAddress);
	printf("	MasterReadTransferCount:	0x%08X\n", regs.MasterReadTransferCount);
	printf("	MailboxEmptyFullStatus:		0x%08X\n", regs.MailboxEmptyFullStatus);
	printf("	InterruptControlStatus:		0x%08X\n", regs.InterruptControlStatus);
	printf("	BusMasterControlStatus:		0x%08X\n", regs.BusMasterControlStatus);
    printf("\n");
}


////////////////////////////////////////////////////////////////////////
// ShowIoctlValues
//
//		Print list of IO Control Code values for usage display
//
void ShowIoctlValues(void)
{
	int i;

	for (i=0; i<N_IOCODES; i++)
	{
		if (i==0)
			printf( "         IO control code index\n");
		printf( "           %d is code %s [%x]\n", i, IOnames[i], IOcodes[i]);
		if (IOcodes[i] == S5933_IOCTL_801_POST_MSG)
		{
			printf( "               and has two arguments: mailbox[1-4] and message\n");
			printf( "               Example: i %d 1 0x12345678\n", i);
		}
		else if (IOcodes[i] == S5933_IOCTL_802_RETRIEVE_MSG)
		{
			printf( "               and has one argument: mailbox[1-4]\n");
			printf( "               Example: i %d 1\n", i);
		}
		else if (IOcodes[i] == S5933_IOCTL_803_WRITE_PASSTHRU)
		{
			printf( "               and has one argument: data\n");
			printf( "               Example: i %d 0x87654321\n", i);
			printf( "               Note: With the ISA card attached, all writes are immediately\n");
			printf( "                 terminated and simply access the single DWORD register in\n");
			printf( "                 the S5933, not actual memory.\n");
		}
		else if (IOcodes[i] == S5933_IOCTL_804_WRITE_NVRAM)
		{
			printf( "               and has three or four arguments:\n");
			printf( "               offset, count, data and optionally increment\n");
			printf( "               Examples: i %d 0x700 0x20 0xA5\n", i);
			printf( "               Examples: i %d 0x700 0x20 0xA5 1 (increments by 1)\n", i);
		}
		else if (IOcodes[i] == S5933_IOCTL_805_READ_NVRAM)
		{
			printf( "               and has either zero or two arguments: offset and count\n");
			printf( "               Examples: i %d (dumps all Nvram) or i %d 0x0 0x80\n", i, i);
		}
		else
		{
			printf( "               and has no arguments\n");
			printf( "               Example: i %d\n", i);
		}
	}
}
