// VCom1394Bus.h
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 562)
// Requires Compuware's DriverWorks classes
//

#ifndef __VCOM1394DEVICE_H__
#define __VCOM1394DEVICE_H__

// VCOM1394 device register definitions
typedef struct _VCOM1394_NODE_REGISTERS
{
    ULONG       Key[3];                                     // 0x00 - Read only register with special key 
    ULONG       MachineName[33];                            // 0X03 - Read only register with local machine name
    ULONG       NumberOfPorts;                              // 0X24 - Read/Write register with remote port name
    VCOM_PORT   PortInfo[MAXIMUM_NUMBER_OF_PORTS];          // 0x25 - Start of port info list
} VCOM1394_NODE_REGISTERS, *PVCOM1394_NODE_REGISTERS;

class VCom1394Bus;


class VCom1394BusLowerDevice : public K1394LowerDevice
{
public:

    NTSTATUS SubmitIrbDirect(PIRB pIrb)
    {
		KIrp I = KIrp::Allocate(StackRequirement());

		if( I.IsNull() )
        {
			    return STATUS_INSUFFICIENT_RESOURCES;
	    }

	    //Fill in the context
	    KEvent Event(NotificationEvent, FALSE);

	    //Submit it to the lower device
	    SubmitIrbDirect(I, pIrb, SyncCompleteSubmitIrb, &Event);
    		
	    //Wait for it to complete
	    Event.Wait(KernelMode, FALSE, NULL);
    	
	    //Get the return status
	    NTSTATUS status = I.Status();

		KIrp::Deallocate(I);

	    return status;
    }

    NTSTATUS SubmitIrbDirect(
		PIRP					pIrp,
		PIRB					pIrb,
		PIO_COMPLETION_ROUTINE	CompletionRoutine,
		PVOID					Context)
    {
	    KIrp I(pIrp);

	    //Fill in the IRP
	    I.MajorFunction(NEXT) = IRP_MJ_INTERNAL_DEVICE_CONTROL;
	    I.IoctlCode(NEXT) = IOCTL_1394_CLASS;
	    I.Irb(NEXT) = pIrb;
	    I.SetCompletionRoutine(CompletionRoutine, Context, TRUE, TRUE, TRUE);

	    return CallDirect(I);
    }


    NTSTATUS CallDirect(KIrp I)
    {
	    BOUNDS_CHECKER(CALL_LOWER_DEVICE, (this, I.m_Irp));

	    return IoCallDriver(m_pSpecialDeviceObject, I.m_Irp);
        //return IoCallDriver(m_pDeviceObject, I.m_Irp);
    }

    NTSTATUS Initialize(KDevice* AttachingDevice,
			            PDEVICE_OBJECT PhysicalDeviceObject)
    {
	    NTSTATUS status = K1394LowerDevice::Initialize(AttachingDevice, PhysicalDeviceObject);

        // if not on XP change the device we send objects down too
        if(IoIsWdmVersionAvailable(1, 0x20)) 
        {
            m_pSpecialDeviceObject = m_pDeviceObject;
        } 
        else
        {
            PNODE_DEVICE_EXTENSION pDeviceExtension = (PNODE_DEVICE_EXTENSION) DeviceObject()->DeviceExtension;

            m_pSpecialDeviceObject = pDeviceExtension->PortDeviceObject;
        }

        return status;
    };

protected:
    PDEVICE_OBJECT  m_pSpecialDeviceObject;
};


class BusAsyncClient : public VCom1394BusAsyncClient
{
public:
    BusAsyncClient() { KeInitializeSpinLock(&m_PortInfoLock); }

	virtual VOID OnRead(
		PVOID		pRequestPacket, 
		PMDL		pResponseMdl,
		PVOID      *ppResponsePacket,
		PULONG		pResponseLength,
		PKEVENT    *ppResponseEvent);

        KSPIN_LOCK  m_PortInfoLock;
};

class VCom1394Bus : public KPnpDevice
{
    // Constructors
public:
    SAFE_DESTRUCTORS;
    VCom1394Bus(PDEVICE_OBJECT Pdo, ULONG Unit);
    ~VCom1394Bus();

    static VOID PacketCleanupThread(PVOID pContext);

    // Member Functions
public:
    DEVMEMBER_DISPATCHERS
    virtual NTSTATUS OnStartDevice(KIrp I);
    virtual NTSTATUS OnStopDevice(KIrp I);
    virtual NTSTATUS OnRemoveDevice(KIrp I);
    virtual NTSTATUS OnSurpriseRemoval(KIrp I);
    virtual NTSTATUS OnQueryDeviceState(KIrp I);
    virtual NTSTATUS OnQueryDeviceRelations(KIrp I);
    virtual NTSTATUS DefaultPnp(KIrp I);
    virtual NTSTATUS DefaultPower(KIrp I);
    virtual NTSTATUS OnDevicePowerUp(KIrp I);
    virtual NTSTATUS OnDeviceSleep(KIrp I);

	MEMBER_COMPLETEIRP(VCom1394Bus, QueryDeviceStateComplete);

    NTSTATUS VCom1394IoctlSetPortsHandler(KIrp I);

    NTSTATUS VCom1394IoctlGetPortsHandler(KIrp I);

    NTSTATUS SetupNodeRegisters();
    BOOLEAN UpdateNodeRegisters(BOOLEAN     bAddPort, 
                                PVCOM_PORT  pPortInfo);

    static VOID MyDpcFunc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

    PVCOM1394_RESPONSE AllocateResponseContext()
    {
        return (PVCOM1394_RESPONSE)m_ResponsePacketLookaside.alloc();
    }

    VOID QueueResponseContext(PVCOM1394_RESPONSE pContext)
    {
        ExInterlockedInsertHeadList(&m_ResponsePacketList,
                                    &pContext->ListEntry,
                                    &m_ResponsePacketListLock);
    }

    PWSTR GetMachineName()
    {
        return m_MachineName;
    }

#ifdef _COMMENT_ONLY

        // The following member functions are actually defined by
        // a DEVMEMBER_xxx or MEMBER_xxx macro (such as DEVMEMBER_DISPATCHERS).
        // The macro __COMMENT_ONLY never gets defined.  These comment-only
        // definitions simply allow easy navigation to the functions within
        // the Developer Studio using the class browser.

    virtual NTSTATUS Create(KIrp I);                // COMMENT_ONLY
    virtual NTSTATUS Close(KIrp I);                 // COMMENT_ONLY
    virtual NTSTATUS DeviceControl(KIrp I);         // COMMENT_ONLY
    virtual NTSTATUS SystemControl(KIrp I);         // COMMENT_ONLY
#endif

    // Member Data
    VCom1394BusLowerDevice          m_Lower;

protected:
        // Unit number for this device (0-9)
    ULONG                           m_Unit;
    KBus                            m_VComBus;
    BOOLEAN                         m_bIsVirtual;
    BusAsyncClient                  m_IdRegisterClient;
    K1394AddressRange               m_IdRegisterRange;
    ADDRESS_OFFSET                  m_IdRegisterOffset;
    PMDL                            m_pIdRegistersMdl;
    BusAsyncClient                  m_PortInfoClient;
    K1394AddressRange               m_PortInfoRange;
    ADDRESS_OFFSET                  m_PortInfoOffset;
    PMDL                            m_pPortInfoMdl;
    PWSTR                           m_MachineName;
    HANDLE                          m_hPacketCleanupThread;
    KEVENT                          m_PacketCleanupTerminationEvent;
    PETHREAD                        m_PacketCleanupThreadObject;
    LIST_ENTRY                      m_ResponsePacketList;
    KSPIN_LOCK                      m_ResponsePacketListLock;
    KHeap<VCOM1394_RESPONSE>        m_ResponsePacketLookaside;
    VCOM1394_NODE_REGISTERS         m_NodeRegisters;

    friend class BusAsyncClient;
};

#endif
