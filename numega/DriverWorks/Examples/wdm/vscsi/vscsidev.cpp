// vscsidev.cpp
// Implementation of VScsiDevice device class
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>
#include "vscsintf.h"

#include "vscsi.h"
#include "vbus.h"
#include "vdisk.h"
#include "vscsidev.h"

#include <scsi.h>

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::VScsiDevice
//
//	Routine Description:
//		This is the constructor for the Functional Device Object, or FDO.
//		It is derived from KPnpDevice, which builds in automatic
//	    dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP to
//		virtual member functions.
//
//	Parameters:
//		[in] Pdo 
//			Physical Device Object - this is a pointer to a system
//			device object that represents the physical device.
//
//	Return Value:
//		None   
//
//	Comments:
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the FDO to the
//		PDO and creates an interface to the upper edge of the system class driver.
//
VScsiDevice::VScsiDevice(PDEVICE_OBJECT Pdo) :
	KPnpDevice(Pdo, &VSCSI_DEVICE_CLASS_GUID),
	m_socket(NULL),
	m_BusLock((ULONG)0)
{
	t << "VScsiDevice::VScsiDevice\n";

    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		// Initialize the lower device
		m_Lower.Initialize(this, Pdo);

		// Inform the base class of the lower edge device object
		SetLowerDevice(&m_Lower);

		// Initialize the PnP Policy settings to the "standard" policy
		SetPnpPolicy();

		m_Policies.m_QueryStopPolicy.m_FailIfOutstandingIo = FALSE;
		m_Policies.m_QueryRemovePolicy.m_WaitForOutstandingIo = FALSE;

		// Initialize the Power Policy settings to the "standard" policy
		SetPowerPolicy(TRUE);

		m_PowerPolicies.m_QueryPowerPolicy.m_FailIfOutstandingIo = FALSE;
		m_PowerPolicies.m_QueryPowerPolicy.m_WaitForOutstandingIo = FALSE;
		m_PowerPolicies.m_DeviceSleepPolicy.m_FailIfOutstandingIo = FALSE;
		m_PowerPolicies.m_DeviceSleepPolicy.m_WaitForOutstandingIo = FALSE;

		// we will send IRP_MN_WAIT_WAKE only in response to IRP_MN_WAIT_WAKE
		// from children device stack
		m_PowerPolicies.m_WaitWakePolicy.m_SendDeviceSleep = FALSE;
		m_PowerPolicies.m_WaitWakePolicy.m_SendSystemSleep = FALSE;
		
		// inform the bus about its parent
		m_Bus.SetParent(this);
	}
}


////////////////////////////////////////////////////////////////////////
//  VScsiDevice::~VScsiDevice
//
//	Routine Description:
//		This is the destructor for the Functional Device Object, or FDO.
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VScsiDevice::~VScsiDevice()
{
	t << "VScsiDevice::~VScsiDevice\n";

}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::DefaultPnp
//
//	Routine Description:
//		Default handler for IRP_MJ_PNP
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_PNP. IRPs that correspond to
//		any virtual members of KpnpDevice that handle minor functions of
//		IRP_MJ_PNP and that are not overridden get passed to this routine.
//
NTSTATUS VScsiDevice::DefaultPnp(KIrp I) 
{
	t << "VScsiDevice::DefaultPnp " << I;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::DefaultPower
//
//	Routine Description:
//		Default handler for IRP_MJ_POWER 
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_POWER.
//
NTSTATUS VScsiDevice::DefaultPower(KIrp I) 
{
	t << "VScsiDevice::DefaultPower " << I;

	I.IndicatePowerIrpProcessed();
	I.CopyParametersDown();
	return m_Lower.PnpPowerCall(this, I);
}

////////////////////////////////////////////////////////////////////////////////
//  VScsiDevice::SystemControl
//
//	Routine Description:
//		Default handler for IRP_MJ_SYSTEM_CONTROL
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		This routine just passes the IRP through to the next device since this driver
//		is not a WMI provider.
//
NTSTATUS VScsiDevice::SystemControl(KIrp I) 
{
	t << "VScsiDevice::SystemControl\n";

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnStartDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		Initialize the physical device. Typically, the driver initializes
//		physical resources here.  Call I.AllocatedResources() for a list
//		of the raw resources that the system has assigned to the device,
//		or I.TranslatedResources() for the translated resource list.
//
NTSTATUS VScsiDevice::OnStartDevice(KIrp I)
{
	t << "VScsiDevice::OnStartDevice\n";

	NTSTATUS status = STATUS_SUCCESS;

	I.Information() = 0;

	IncrementOutstandingRequestCount();		
	m_poll.Set(SCAN_INTERVAL, Poll, this);

	return status;
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnStopDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		The system calls this when the device is stopped.
//		The driver should release any hardware resources
//		in this routine.
//
//		The base class passes the irp to the lower device.
//
NTSTATUS VScsiDevice::OnStopDevice(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "VScsiDevice::OnStopDevice\n";

	if ( m_poll.Cancel() )
		DecrementOutstandingRequestCount();

	if ( m_socket )
	{
		m_socket->SetEvents(FALSE);
		m_socket->Wait();
	}

	DecrementOutstandingRequestCount();
	WaitStop();
	IncrementOutstandingRequestCount();		

	return status;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnRemoveDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//
NTSTATUS VScsiDevice::OnRemoveDevice(KIrp I)
{
	t << "VScsiDevice::OnRemoveDevice\n";

	if ( m_poll.Cancel() )
		DecrementOutstandingRequestCount();

	if ( m_socket )
	{
		m_socket->SetEvents(FALSE);
		m_socket->Wait();
		delete m_socket;
		m_socket = NULL;
	}

	// make sure that all children objects are deleted
	m_Bus.RemoveChildren();

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnSurpriseRemoval
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//

NTSTATUS VScsiDevice::OnSurpriseRemoval(KIrp I)
{
	t << "VScsiDevice::OnSurpriseRemoval\n";

	if ( m_poll.Cancel() )
		DecrementOutstandingRequestCount();

	if ( m_socket )
	{
		m_socket->SetEvents(FALSE);
		m_socket->Wait();
	}

	// allow children objects to be deleted in IRP_MN_REMOVE_DEVICE handler
	m_Bus.RemoveParent();

	return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnQueryDeviceRelations
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//
NTSTATUS VScsiDevice::OnQueryDeviceRelations(KIrp I)
{
	t << "VScsiDevice::OnQueryDeviceRelations\n";

	NTSTATUS status = m_Bus.QueryDeviceRelations(I);
	if ( NT_SUCCESS(status) )
		return m_Lower.PnpCall(this, I);
	else
		return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnDevicePowerUp
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to power on state from low power state
//
//	Parameters:
//		[in] I 
//			IRP containing POWER request
//
//	Return Value:
//		status
//
//	Comments:
//		This routine implements the OnDevicePowerUp function.
//		This function was called by the framework from the completion
//		routine of the IRP_MJ_POWER dispatch handler in KPnpDevice.
//		The bus driver has completed the IRP and this driver can now
//		access the hardware device.  
//		This routine runs at dispatch level.
//	
NTSTATUS VScsiDevice::OnDevicePowerUp(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "VScsiDevice::OnDevicePowerUp\n";

	// inform the bus object about parent power state changes
	m_Bus.SetPowerState(I.PowerStateSetting().DeviceState);

	return status;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnDeviceSleep
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to a low power state from a high power state
//
//	Parameters:
//		[in] I
//			IRP containing POWER request
//
//	Return Value:
//		status
//
//	Comments:
//		This routine implements the OnDeviceSleep function.
//		This function was called by the framework from the IRP_MJ_POWER 
//		dispatch handler in KPnpDevice prior to forwarding to the PDO.
//		The hardware has yet to be powered down and this driver can now
//		access the hardware device.  
//		This routine runs at passive level.
//	
NTSTATUS VScsiDevice::OnDeviceSleep(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "VScsiDevice::OnDeviceSleep\n";

	// inform the bus object about parent power state changes
	m_Bus.SetPowerState(I.PowerStateSetting().DeviceState);

	return status;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::DetermineNewDevicePowerState
//
//	Routine Description:
//		Calculates the lowest possible device power state
//
//	Parameters:
//		[in] SystemPowerState
//			New system power state
//
//	Return Value:
//		DEVICE_POWER_STATE - new device power state
//
//	Comments:
//		This routine finds the highest device power state among
//		its children and returns the new device power state which is at least
//		as high as that state.
//	
DEVICE_POWER_STATE VScsiDevice::DetermineNewDevicePowerState(SYSTEM_POWER_STATE SystemPowerState)
{
	DEVICE_POWER_STATE DevicePowerState = KPnpDevice::DetermineNewDevicePowerState(SystemPowerState);
	DEVICE_POWER_STATE ChildrenPowerState = m_Bus.HighestChildrenPowerState();

	if ( DevicePowerState > ChildrenPowerState )
		DevicePowerState = ChildrenPowerState;

	return DevicePowerState;
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::Create
//
//	Routine Description:
//		Handler for IRP_MJ_CREATE
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//
NTSTATUS VScsiDevice::Create(KIrp I)
{
	t << "VScsiDevice::Create\n";

	return I.PnpComplete(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::Close
//
//	Routine Description:
//		Handler for IRP_MJ_CLOSE
//
//	Parameters:
//		[in] I 
//		Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//
NTSTATUS VScsiDevice::Close(KIrp I)
{
	t << "VScsiDevice::Close\n";

	return I.PnpComplete(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::DeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_DEVICE_CONTROL
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VScsiDevice::DeviceControl(KIrp I)
{
	return I.PnpComplete(STATUS_INVALID_DEVICE_REQUEST);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::InternalDeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_INTERNAL_DEVICE_CONTROL
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VScsiDevice::InternalDeviceControl(KIrp I)
{
	return I.PnpComplete(STATUS_INVALID_DEVICE_REQUEST);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::Poll
//
//	Routine Description:
//		Scans network for available network disks
//
//	Parameters:
//		[in] Dpc 
//			DPC object
//
//		[in] DeferredContext
//			pointer to our device class
//
//		[in] SystemArgument1
//			unused
//
//		[in] SystemArgument2
//			unused
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VScsiDevice::Poll(PKDPC Dpc, PVOID DeferredContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
	VScsiDevice* pDevice = (VScsiDevice*)DeferredContext;

	if ( !pDevice->m_State.m_Removed && pDevice->m_State.m_Started )
	{
		if ( pDevice->m_State.m_Started && (((VScsiDriver*)KDriver::DriverInstance())->m_bNetworkReady) )
		{
			PIO_WORKITEM pItem = IoAllocateWorkItem(*pDevice);

			if ( pItem )
			{
				IoQueueWorkItem(pItem, (PIO_WORKITEM_ROUTINE)ScanNetwork, DelayedWorkQueue, pItem);
				return;
			}
		}

		pDevice->m_poll.Set(SCAN_INTERVAL, Poll, pDevice);
	}
	else
		pDevice->DecrementOutstandingRequestCount();
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::ScanNetwork
//
//	Routine Description:
//		Scans network for available network disks
//
//	Parameters:
//		[in] pDeviceObject 
//			pointer to device object
//
//		[in] pItem
//			pointer to work item
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VScsiDevice::ScanNetwork(PDEVICE_OBJECT pDeviceObject, PIO_WORKITEM pItem)
{
	IoFreeWorkItem(pItem);

	VScsiDevice* pDevice = (VScsiDevice*)KDevicePTR(pDeviceObject);

	if ( !pDevice->m_socket )
	{
		pDevice->m_socket = new ScanSocket(pDevice);
		if ( pDevice->m_socket && pDevice->m_socket->IsCreated() ) 
			pDevice->m_socket->SetEvents(TRUE);
	}

	KEnumIPInterface IPInterface;

	for (ULONG i = 0; i < IPInterface.Count(); i++)
	{
		ULONG IPAddress;
		ULONG SubnetMask;
		ULONG BroadcastAddress;
		
		//Get our IP address and subnet mask
		IPAddress = IPInterface.GetAddress();
		SubnetMask = IPInterface.GetSubnetMask();
		
		//Use them to calculate the broadcast address.
		BroadcastAddress =  IPAddress & SubnetMask;
		BroadcastAddress += ~SubnetMask;

		pDevice->m_socket->Scan(ntohl(BroadcastAddress));
	}

	pDevice->m_poll.Set(SCAN_INTERVAL, Poll, pDevice);
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::OnFoundDisk
//
//	Routine Description:
//		Found new network disk handler
//
//	Parameters:
//		[in] address 
//			ip address of a disk
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VScsiDevice::OnFoundDisk(ULONG address)
{
	if ( !m_State.m_Removed )
	{
		PADD_REMOVE_CONTEXT pContext = new ADD_REMOVE_CONTEXT;

		if ( pContext )
		{
			pContext->m_address = address;
			pContext->m_pItem = IoAllocateWorkItem(*this);

			if ( pContext->m_pItem )
			{
				IncrementOutstandingRequestCount();
				IoQueueWorkItem(pContext->m_pItem, (PIO_WORKITEM_ROUTINE)AddDisk, DelayedWorkQueue, pContext);
				return;
			}
			else
				delete pContext;
		}
	}
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::AddDisk
//
//	Routine Description:
//		Creates new VDisk device
//
//	Parameters:
//		[in] pDeviceObject
//			device object
//
//		[in] pContext
//			pointer to ADD_REMOVE_CONTEXT
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VScsiDevice::AddDisk(PDEVICE_OBJECT pDeviceObject, PADD_REMOVE_CONTEXT pContext)
{
	IoFreeWorkItem(pContext->m_pItem);

	VScsiDevice* pDevice = (VScsiDevice*)KDevicePTR(pDeviceObject);

	pDevice->m_BusLock.Wait();

	// we will create the VDisk device here.
	if ( !pDevice->m_Bus.AddressUsed(pContext->m_address) )
	{
		VDisk* pDisk = new (
			NULL,
			FILE_DEVICE_MASS_STORAGE,
			NULL,
			FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
			DO_DIRECT_IO | DO_POWER_PAGABLE
			)
		VDisk(pDevice, &pDevice->m_Bus, pContext->m_address);

		if ( pDisk )
		{
			NTSTATUS status = pDisk->ConstructorStatus();

			if ( NT_SUCCESS(status) )
			{
				pDevice->m_Bus.AddChild(pDisk);
				((PDEVICE_OBJECT)*pDisk)->Flags &= ~DO_DEVICE_INITIALIZING;
				IoInvalidateDeviceRelations(pDevice->m_Lower.PDO(), BusRelations);
			}
			else
				delete pDisk;
		}
	}

	pDevice->m_BusLock.Release();

	delete pContext;

	pDevice->DecrementOutstandingRequestCount();
}

////////////////////////////////////////////////////////////////////////
//  VScsiDevice::RemoveDisk
//
//	Routine Description:
//		Removes VDisk device
//
//	Parameters:
//		[in] pDeviceObject
//			device object
//b
//		[in] pContext
//			pointer to ADD_REMOVE_CONTEXT
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VScsiDevice::RemoveDisk(PDEVICE_OBJECT pDeviceObject, PADD_REMOVE_CONTEXT pContext)
{
	IoFreeWorkItem(pContext->m_pItem);

	VScsiDevice* pDevice = (VScsiDevice*)KDevicePTR(pDeviceObject);

	pDevice->m_Bus.RemoveChild(pContext->m_address);
	IoInvalidateDeviceRelations(pDevice->m_Lower.PDO(), BusRelations);

	delete pContext;

	pDevice->DecrementOutstandingRequestCount();
}

