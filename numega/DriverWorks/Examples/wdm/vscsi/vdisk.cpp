// vdisk.cpp
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>
#include "vscsi.h"
#include "vdisk.h"
#include "vbus.h"
#include "vscsidev.h"
#include "vscsintf.h"

#include "stdio.h"

#include <scsi.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

// from debug.cpp
VOID DumpSrb(PSCSI_REQUEST_BLOCK Srb);

////////////////////////////////////////////////////////////////////////
//  VScsiQueue::StartIo
//
//	Routine Description:
//		Start Irp processing handler
//
//	Parameters:
//		[in] I
//			current irp
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VScsiQueue::StartIo(KIrp I)
{
	VDisk* pDevice = (VDisk*)KDevicePTR(I.DeviceObject());

	pDevice->StartReadWrite(I);
}

///////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//  VDisk::VDisk
//
//	Routine Description:
//		Constructor for VDisk class
//
//	Parameters:
//		[in] pParent
//			pointer to a parent FDO
//
//		[in] pBus
//			pointer to a pdo collection
//
//		[in] Unit
//			id
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VDisk::VDisk(VScsiDevice* pParent, VBus* pBus, ULONG address) :
	KPhysicalDevice(pBus),
	m_Parent(pParent),
	m_address(address),
	m_HardwareIDs(NULL),
	m_DeviceIDs(NULL),
	m_socket(NULL)
{
	t << "VDisk::VDisk " << address << EOL;

	// Check constructor status
    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		SetPnpPolicy();

		m_Policies.m_HoldPolicy.m_HoldIfRemovePending = FALSE;
		m_Policies.m_HoldPolicy.m_HoldIfStopPending = FALSE;
		m_Policies.m_HoldPolicy.m_HoldIfStopped = FALSE;

		SetPowerPolicy();
		m_queue.Initialize(*this);

		m_HardwareIDs = new WCHAR[sizeof(HARDWARE_DISK_IDS)/sizeof(WCHAR)];
		if ( m_HardwareIDs )
			RtlCopyMemory(m_HardwareIDs, HARDWARE_DISK_IDS, sizeof (HARDWARE_DISK_IDS));
		else
			m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;

		m_DeviceIDs = new WCHAR[sizeof(DEVICE_DISK_IDS)/sizeof(WCHAR)];
		if ( m_DeviceIDs )
			RtlCopyMemory(m_DeviceIDs, DEVICE_DISK_IDS, sizeof (DEVICE_DISK_IDS));
		else
			m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;

		//Create our socket
		m_socket = new iSocket(this);

		if ( m_socket && m_socket->IsCreated() )
			m_socket->SetEvents(TRUE);
		else
			m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;

		TDI_ADDRESS_IP addr = {htons(2002), address};
		CTDI_CONNECTION_INFORMATION server(addr);

		m_socket->connect(server, 10000);
	}
}

////////////////////////////////////////////////////////////////////////
//  VDisk::~VDisk
//
//	Routine Description:
//		Destructor for VDisk class
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VDisk::~VDisk()
{
	t << "VDisk::~VDisk() " << m_address << EOL;

	if ( m_HardwareIDs )
		delete[] m_HardwareIDs;

	if ( m_DeviceIDs )
		delete[] m_DeviceIDs;

	if ( m_socket )
		delete m_socket;
	m_socket = NULL;
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnQueryDeviceText
//
//	Routine Description:
//		IRP_MN_QUERY_DEVICE_TEXT handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::OnQueryDeviceText(KIrp I)
{
	t << "VDisk::OnQueryDeviceText " << m_address << EOL;

	NTSTATUS status = STATUS_SUCCESS;

	switch ( I.CurrentStackLocation()->Parameters.QueryDeviceText.DeviceTextType )
	{
	case DeviceTextDescription:
		switch ( I.CurrentStackLocation()->Parameters.QueryDeviceText.LocaleId )
		{
        case 0x00000409: // English
        default:
            if( !I.Information() )
			{
                ULONG length = (ULONG)(wcslen(VENDORNAME) + wcslen(MODELNAME) + 8 + 2)*sizeof(WCHAR);

                PWCHAR buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, length, DefaultPoolTag);
                if ( buffer )
				{
					swprintf(buffer, L"%ws%ws%08x", VENDORNAME, MODELNAME, m_address);
					I.Information() = (ULONG_PTR)buffer;
				}
				else
				{
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

            }
            break;
		}
		break;
	case DeviceTextLocationInformation:
		break;
	default:
		status = I.Status();
		break;
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnQueryId
//
//	Routine Description:
//		IRP_MN_QUERY_DEVICE_TEXT handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::OnQueryId(KIrp I)
{
	NTSTATUS	status = STATUS_SUCCESS;

    PWCHAR		buffer;
    ULONG		length;

	t << "VDisk::OnQueryId " << m_address << EOL;

	switch ( I.QueryIdType() )
	{
	case BusQueryDeviceID:
		buffer = m_DeviceIDs;

        while ( *(buffer++) )
		{
            while ( *(buffer++) );
        }

        length = (ULONG)(buffer - m_DeviceIDs)*sizeof(WCHAR);

        buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, length, DefaultPoolTag);

        if ( buffer )
		{
			RtlCopyMemory(buffer, m_DeviceIDs, length);
			I.Information() = (ULONG_PTR)buffer;
		}
		else
		{
           status = STATUS_INSUFFICIENT_RESOURCES;
        }
		break;

    case BusQueryInstanceID:
        buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, 12*sizeof(WCHAR), DefaultPoolTag);
        if ( buffer )
		{
			swprintf(buffer, L"%08x", m_address);
			I.Information() = (ULONG_PTR)buffer;
		}
		else
		{
           status = STATUS_INSUFFICIENT_RESOURCES;
        }
        break;

    case BusQueryHardwareIDs:
        buffer = m_HardwareIDs;

        while ( *(buffer++) )
		{
            while ( *(buffer++) );
        }

        length = (ULONG)(buffer - m_HardwareIDs)*sizeof(WCHAR);
        buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, length, DefaultPoolTag);

        if ( buffer )
		{
			RtlCopyMemory(buffer, m_HardwareIDs, length);
			I.Information() = (ULONG_PTR)buffer;
		}
		else
		{
           status = STATUS_INSUFFICIENT_RESOURCES;
        }
        break;

    default:
        status = I.Status();
		break;
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnQueryBusInformation
//
//	Routine Description:
//		IRP_MN_QUERY_BUS_INFORMATION handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::OnQueryBusInformation(KIrp I)
{
	t << "VDisk::OnQueryBusInformation " << m_address << EOL;

	NTSTATUS status = STATUS_SUCCESS;

    PPNP_BUS_INFORMATION busInfo = (PPNP_BUS_INFORMATION)ExAllocatePoolWithTag(PagedPool, sizeof(PNP_BUS_INFORMATION), DefaultPoolTag);

    if ( busInfo )
	{
		busInfo->BusTypeGuid = VSCSI_BUS_GUID;

		busInfo->LegacyBusType = PNPBus;
		busInfo->BusNumber = 0;

	    I.Information() = (ULONG_PTR)busInfo;
	}
	else
	{
      status = STATUS_INSUFFICIENT_RESOURCES;
    }

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnDeviceUsageNotification
//
//	Routine Description:
//		IRP_MN_DEVICE_USAGE_NOTIFICATION handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::OnDeviceUsageNotification(KIrp I)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	t << "VDisk::OnDeviceUsageNotification " << m_address << EOL;

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnQueryResources
//
//	Routine Description:
//		IRP_MN_QUERY_RESOURCES handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::OnQueryResources(KIrp I)
{
	t << "VDisk::OnQueryResources " << m_address << EOL;

	return DefaultPnp(I);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnQueryResourceRequirements
//
//	Routine Description:
//		IRP_MN_QUERY_RESOURCES handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::OnQueryResourceRequirements(KIrp I)
{
	t << "VDisk::OnQueryResourceRequirements " << m_address << EOL;

	return DefaultPnp(I);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::Create
//
//	Routine Description:
//		Handler for IRP_MJ_CREATE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		None
//
NTSTATUS VDisk::Create(KIrp I)
{
	t << "VDisk::Create\n";

	return I.PnpComplete(STATUS_SUCCESS);;
}

////////////////////////////////////////////////////////////////////////
//  VDisk::Close
//
//	Routine Description:
//		Handler for IRP_MJ_CLOSE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		None
//
NTSTATUS VDisk::Close(KIrp I)
{
	t << "VDisk::Close\n";

	return I.PnpComplete(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::DeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_DEVICE_CONTROL
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::DeviceControl(KIrp I)
{
	t << "VDisk::DeviceControl " << m_address << EOL;

	NTSTATUS status;

	I.Information() = 0;

	switch ( I.IoctlCode() )
	{
	case IOCTL_STORAGE_QUERY_PROPERTY:
		{
			PSTORAGE_PROPERTY_QUERY pQuery = (PSTORAGE_PROPERTY_QUERY)I.IoctlBuffer();
			PSTORAGE_DESCRIPTOR_HEADER pHeader = (PSTORAGE_DESCRIPTOR_HEADER)I.IoctlBuffer();

			if ( (pQuery->PropertyId == StorageAdapterProperty) && (pQuery->QueryType == PropertyStandardQuery) )
			{
				if ( I.IoctlOutputBufferSize() >= sizeof(STORAGE_DESCRIPTOR_HEADER) )
				{
					pHeader->Version = 1;
					pHeader->Size = sizeof(STORAGE_ADAPTER_DESCRIPTOR);

					I.Information() = sizeof(STORAGE_DESCRIPTOR_HEADER);
				}

				if ( I.IoctlOutputBufferSize() >= sizeof(STORAGE_ADAPTER_DESCRIPTOR) )
				{
					PSTORAGE_ADAPTER_DESCRIPTOR pDesc = (PSTORAGE_ADAPTER_DESCRIPTOR)pHeader;

					pDesc->MaximumTransferLength = 0x10 * PAGE_SIZE;
					pDesc->MaximumPhysicalPages = 0x10;
					pDesc->AlignmentMask = 1;
					pDesc->AdapterUsesPio = TRUE;
					pDesc->AdapterScansDown = FALSE;
					pDesc->CommandQueueing = FALSE;
					pDesc->AcceleratedTransfer = FALSE;
					pDesc->BusType = BusTypeUnknown;
					pDesc->BusMajorVersion = 1;
					pDesc->BusMinorVersion = 0;

					I.Information() = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
				}
			}
			else if ( (pQuery->PropertyId == StorageDeviceProperty) && (pQuery->QueryType == PropertyStandardQuery) )
			{
				if ( I.IoctlOutputBufferSize() >= sizeof(STORAGE_DESCRIPTOR_HEADER) )
				{
					pHeader->Version = 1;
					pHeader->Size = sizeof(STORAGE_DEVICE_DESCRIPTOR);

					I.Information() = sizeof(STORAGE_DESCRIPTOR_HEADER);
				}

				if ( I.IoctlOutputBufferSize() >= sizeof(STORAGE_DEVICE_DESCRIPTOR) )
				{
					PSTORAGE_DEVICE_DESCRIPTOR pDesc = (PSTORAGE_DEVICE_DESCRIPTOR)pHeader;

					pDesc->DeviceType = DIRECT_ACCESS_DEVICE;
					pDesc->DeviceTypeModifier = 0;
					pDesc->RemovableMedia = FALSE;
					pDesc->CommandQueueing = FALSE;
					pDesc->VendorIdOffset = 0;
					pDesc->ProductIdOffset = 0;
					pDesc->ProductRevisionOffset = 0;
					pDesc->SerialNumberOffset = 0;
					pDesc->BusType = BusTypeUnknown;
					pDesc->RawPropertiesLength = 0;

					I.Information() = sizeof(STORAGE_DEVICE_DESCRIPTOR);
				}
			}
			else if ( (pQuery->PropertyId == StorageDeviceIdProperty) && (pQuery->QueryType == PropertyStandardQuery) )
			{
				if ( I.IoctlOutputBufferSize() >= sizeof(STORAGE_DESCRIPTOR_HEADER) )
				{
					pHeader->Version = 1;
					pHeader->Size = sizeof(STORAGE_DEVICE_ID_DESCRIPTOR);

					I.Information() = sizeof(STORAGE_DESCRIPTOR_HEADER);
				}
			}
		}

		status = STATUS_SUCCESS;
		break;

/*	case IOCTL_DISK_GET_DRIVE_GEOMETRY:
		if ( I.IoctlOutputBufferSize() >= sizeof(DISK_GEOMETRY) )
		{
			PDISK_GEOMETRY p = (PDISK_GEOMETRY)I.IoctlBuffer();

			p->Cylinders.QuadPart = 1;
			p->MediaType = FixedMedia;
			p->SectorsPerTrack = VSCSI_BUFFER_SIZE/512;
			p->TracksPerCylinder = 1;
			p->BytesPerSector = 512;

			status = STATUS_SUCCESS;
			I.Information() = sizeof(DISK_GEOMETRY);
		}
		else
			status = STATUS_BUFFER_TOO_SMALL;
		break;
*/

	case IOCTL_STORAGE_GET_HOTPLUG_INFO:
		if ( I.IoctlOutputBufferSize() >= sizeof(STORAGE_HOTPLUG_INFO) )
		{
			PSTORAGE_HOTPLUG_INFO p = (PSTORAGE_HOTPLUG_INFO)I.IoctlBuffer();

			p->Size = sizeof(STORAGE_HOTPLUG_INFO);
			p->MediaRemovable = FALSE;
			p->MediaHotplug = FALSE;
			p->DeviceHotplug = FALSE;


			status = STATUS_SUCCESS;
			I.Information() = sizeof(STORAGE_HOTPLUG_INFO);
		}
		else
			status = STATUS_BUFFER_TOO_SMALL;
		break;

	case IOCTL_STORAGE_SET_HOTPLUG_INFO:
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;

	case IOCTL_SCSI_GET_ADDRESS:
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;

	default:
		status = STATUS_INVALID_DEVICE_REQUEST;
		break;
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::InternalDeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_INTERNAL_DEVICE_CONTROL
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VDisk::InternalDeviceControl(KIrp I)
{
	t << "VDisk::InternalDeviceControl " << m_address << EOL;

	NTSTATUS status = STATUS_SUCCESS;

	PIO_STACK_LOCATION stack = I.CurrentStackLocation();
	PSCSI_REQUEST_BLOCK Srb = stack->Parameters.Scsi.Srb;
	PCDB pCdb = (PCDB)Srb->Cdb;

	Srb->SrbStatus = SRB_STATUS_SUCCESS;

	I.Information() = 0;

	if ( !m_socket )
	{
		status = STATUS_INVALID_DEVICE_REQUEST;
		Srb->SrbStatus = SRB_STATUS_ERROR;

		return I.PnpComplete(status);
	}

	switch ( Srb->Function )
	{
	case SRB_FUNCTION_CLAIM_DEVICE:
		Srb->DataBuffer = (PDEVICE_OBJECT)*this;
		break;

	case SRB_FUNCTION_RELEASE_DEVICE:
		break;

	case SRB_FUNCTION_EXECUTE_SCSI:
		{
			DumpSrb(Srb);

			if ( pCdb->CDB6GENERIC.OperationCode == SCSIOP_READ_CAPACITY )
			{
				PREAD_CAPACITY_DATA pData = (PREAD_CAPACITY_DATA)Srb->DataBuffer;

				ULONG LogicalBlockAddress = VSCSI_BUFFER_SIZE/512 - 1;
				ULONG BytesPerBlock = 512;

				REVERSE_BYTES(&pData->LogicalBlockAddress, &LogicalBlockAddress);
				REVERSE_BYTES(&pData->BytesPerBlock, &BytesPerBlock);
			}
			else if ( pCdb->CDB6GENERIC.OperationCode == SCSIOP_TEST_UNIT_READY )
			{
			}
			else if ( pCdb->CDB6GENERIC.OperationCode == SCSIOP_VERIFY )
			{
			}
			else if ( (pCdb->CDB6GENERIC.OperationCode == SCSIOP_READ) || (pCdb->CDB6GENERIC.OperationCode == SCSIOP_WRITE) )
			{
				ULONG LogicalBlockAddress;
				USHORT TransferCount;

				REVERSE_BYTES(&LogicalBlockAddress, &pCdb->CDB10.LogicalBlockByte0);
				REVERSE_BYTES_SHORT(&TransferCount, &pCdb->CDB10.TransferBlocksMsb);

				if ( (LogicalBlockAddress + TransferCount) <= (VSCSI_BUFFER_SIZE/512) )
				{
					return m_queue.QueueIrp(I);
				}
				else
				{
					status = STATUS_INVALID_PARAMETER;
					Srb->SrbStatus = SRB_STATUS_BAD_SRB_BLOCK_LENGTH;
				}
			}
			else if ( pCdb->CDB6GENERIC.OperationCode == SCSIOP_MODE_SENSE )
			{
				RtlZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

				if ( pCdb->MODE_SENSE.Pc != 1 )
				{
					PMODE_PARAMETER_HEADER pHeader = (PMODE_PARAMETER_HEADER)Srb->DataBuffer;

					pHeader->ModeDataLength = sizeof(MODE_PARAMETER_HEADER);
					pHeader->MediumType = 0;
					pHeader->DeviceSpecificParameter = 0;

					if ( !pCdb->MODE_SENSE.Dbd && (pCdb->MODE_SENSE.AllocationLength >= (pHeader->ModeDataLength + sizeof(MODE_PARAMETER_BLOCK))) )
					{
						PMODE_PARAMETER_BLOCK pBlock = (PMODE_PARAMETER_BLOCK)((PUCHAR)pHeader + pHeader->ModeDataLength);
						ULONG LogicalBlockAddress = VSCSI_BUFFER_SIZE/512;
						ULONG BytesPerBlock = 512;

						pHeader->BlockDescriptorLength = sizeof(MODE_PARAMETER_BLOCK);
						pHeader->ModeDataLength += sizeof(MODE_PARAMETER_BLOCK);

						pBlock->DensityCode = 0;

						pBlock->NumberOfBlocks[0] = (UCHAR)((LogicalBlockAddress >> 16) & 0xFF);
						pBlock->NumberOfBlocks[1] = (UCHAR)((LogicalBlockAddress >> 8) & 0xFF);
						pBlock->NumberOfBlocks[2] = (UCHAR)(LogicalBlockAddress & 0xFF);

						pBlock->BlockLength[0] = (UCHAR)((BytesPerBlock >> 16) & 0xFF);
						pBlock->BlockLength[1] = (UCHAR)((BytesPerBlock >> 8) & 0xFF);
						pBlock->BlockLength[2] = (UCHAR)(BytesPerBlock & 0xFF);
					}
					else
						pHeader->BlockDescriptorLength = 0;

					if ( (pCdb->MODE_SENSE.AllocationLength >= (pHeader->ModeDataLength + sizeof(MODE_PAGE_FORMAT_DEVICE))) &&
						 ((pCdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) || (pCdb->MODE_SENSE.PageCode == MODE_PAGE_FORMAT_DEVICE)) )
					{
						PMODE_FORMAT_PAGE pFormat = (PMODE_FORMAT_PAGE)((PUCHAR)pHeader + pHeader->ModeDataLength);
						pHeader->ModeDataLength += sizeof(MODE_FORMAT_PAGE);

						pFormat->PageCode = MODE_PAGE_FORMAT_DEVICE;
						pFormat->PageLength = sizeof(MODE_FORMAT_PAGE);
						pFormat->TracksPerZone[0] = 0;			// we have only one zone
						pFormat->TracksPerZone[1] = 0;
						pFormat->AlternateSectorsPerZone[0] = 0;
						pFormat->AlternateSectorsPerZone[1] = 0;
						pFormat->AlternateTracksPerZone[0] = 0;
						pFormat->AlternateTracksPerZone[1] = 0;
						pFormat->AlternateTracksPerLogicalUnit[0] = 0;
						pFormat->AlternateTracksPerLogicalUnit[1] = 0;
						pFormat->SectorsPerTrack[0] = (UCHAR)((VSCSI_BUFFER_SIZE/512 >> 8) & 0xFF);
						pFormat->SectorsPerTrack[1] = (UCHAR)((VSCSI_BUFFER_SIZE/512 >> 0) & 0xFF);
						pFormat->BytesPerPhysicalSector[0] = (UCHAR)((512 >> 8) & 0xFF);
						pFormat->BytesPerPhysicalSector[1] = (UCHAR)((512 >> 0) & 0xFF);
						pFormat->SoftSectorFormating = 1;
					}

					if ( (pCdb->MODE_SENSE.AllocationLength >= (pHeader->ModeDataLength + sizeof(MODE_DISCONNECT_PAGE))) &&
						 ((pCdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) || (pCdb->MODE_SENSE.PageCode == MODE_PAGE_DISCONNECT)) )
					{
						PMODE_DISCONNECT_PAGE pDis = (PMODE_DISCONNECT_PAGE)((PUCHAR)pHeader + pHeader->ModeDataLength);
						pHeader->ModeDataLength += sizeof(MODE_DISCONNECT_PAGE);

						pDis->PageCode = MODE_PAGE_DISCONNECT;
						pDis->PageLength = sizeof(MODE_DISCONNECT_PAGE);
						pDis->BufferFullRatio = 0xFF;
						pDis->BufferEmptyRatio = 0xFF;
						pDis->BusInactivityLimit[0] = 0;
						pDis->BusInactivityLimit[1] = 1;
						pDis->BusDisconnectTime[0] = 0;
						pDis->BusDisconnectTime[1] = 1;
						pDis->BusConnectTime[0] = 0;
						pDis->BusConnectTime[1] = 1;
						pDis->MaximumBurstSize[0] = 0;
						pDis->MaximumBurstSize[1] = 1;
						pDis->DataTransferDisconnect = 1;
					}

					Srb->DataTransferLength = pHeader->ModeDataLength;
				}
			}
		}
		break;

	default:
		status = STATUS_INVALID_DEVICE_REQUEST;
		Srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
		break;
	}

	if ( NT_SUCCESS(status) )
	{
		I.Information() = Srb->DataTransferLength;
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::StartReadWrite
//
//	Routine Description:
//		Read/Write start irp processing handler
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VDisk::StartReadWrite(KIrp I)
{
	PIO_STACK_LOCATION stack = I.CurrentStackLocation();
	PSCSI_REQUEST_BLOCK Srb = stack->Parameters.Scsi.Srb;
	PCDB pCdb = (PCDB)Srb->Cdb;

	ULONG LogicalBlockAddress;
	USHORT TransferCount;

	REVERSE_BYTES(&LogicalBlockAddress, &pCdb->CDB10.LogicalBlockByte0);
	REVERSE_BYTES_SHORT(&TransferCount, &pCdb->CDB10.TransferBlocksMsb);

	t << "Offset " << LogicalBlockAddress << " Size " << TransferCount << EOL;

	PVOID buffer = GetSystemAddressForMdl(I.Mdl());

	I.Information() = TransferCount * 512;

	if ( pCdb->CDB6GENERIC.OperationCode == SCSIOP_READ )
		m_socket->Read(LogicalBlockAddress, TransferCount, buffer);
	else
		m_socket->Write(LogicalBlockAddress, TransferCount, buffer);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnWriteComplete
//
//	Routine Description:
//		Write complete handler
//
//	Parameters:
//		[in] status
//			status of write
//
//		[in] ByteCount
//			number of bytes written
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VDisk::OnWriteComplete(NTSTATUS status, ULONG ByteCount)
{
	t << "VDisk::OnWriteComplete\n";

	KIrp I = m_queue.CurrentIrp();

	PIO_STACK_LOCATION stack = I.CurrentStackLocation();
	PSCSI_REQUEST_BLOCK Srb = stack->Parameters.Scsi.Srb;
	PCDB pCdb = (PCDB)Srb->Cdb;

	I.Status() = status;
	I.Information() = ByteCount;
	Srb->DataTransferLength = ByteCount;

	m_queue.PnpNextIrp(I);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnReadComplete
//
//	Routine Description:
//		Read complete handler
//
//	Parameters:
//		[in] status
//			status of read
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VDisk::OnReadComplete(NTSTATUS status)
{
	t << "VDisk::OnReadComplete\n";

	KIrp I = m_queue.CurrentIrp();

	I.Status() = status;

	m_queue.PnpNextIrp(I);
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnDisconnect
//
//	Routine Description:
//		disconnect event handler
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VDisk::OnDisconnect()
{
	VScsiDevice::PADD_REMOVE_CONTEXT pContext = new VScsiDevice::ADD_REMOVE_CONTEXT;

	if ( pContext )
	{
		pContext->m_address = m_address;
		pContext->m_pItem = IoAllocateWorkItem(*m_Parent);

		if ( pContext->m_pItem )
		{
			m_Parent->IncrementOutstandingRequestCount();
			IoQueueWorkItem(pContext->m_pItem, (PIO_WORKITEM_ROUTINE)VScsiDevice::RemoveDisk, DelayedWorkQueue, pContext);
			return;
		}
		else
			delete pContext;
	}
}

////////////////////////////////////////////////////////////////////////
//  VDisk::OnConnect
//
//	Routine Description:
//		Connect event handler
//
//	Parameters:
//		[in] status
//			status of connect
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID VDisk::OnConnect(NTSTATUS Status)
{
	if ( Status != STATUS_SUCCESS )
		OnDisconnect();
}