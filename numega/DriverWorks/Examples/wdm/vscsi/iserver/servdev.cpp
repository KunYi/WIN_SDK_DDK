// IserverDevice.cpp
// Implementation of ServerDevice device class
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>
#include "servintf.h"

#include "servdev.h"
#include "server.h"

GUID ServerDevice_Guid = ServerDevice_CLASS_GUID;

////////////////////////////////////////////////////////////////////////
//  ServerDevice::ServerDevice
//
//	Routine Description:
//		This is the constructor for the Functional Device Object, or FDO.
//		It is derived from KPnpDevice, which builds in automatic
//	    dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP to
//		virtual member functions.
//
//	Parameters:
//		[in] Pdo 
//			Physical Device Object - this is a pointer to a system
//			device object that represents the physical device.
//
//	Return Value:
//		None   
//
//	Comments:
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the FDO to the
//		PDO and creates an interface to the upper edge of the system class driver.
//
ServerDevice::ServerDevice(PDEVICE_OBJECT Pdo) :
	KPnpDevice(Pdo, &ServerDevice_Guid),
	m_buffer(NULL)
{
	t << "ServerDevice::ServerDevice\n";

	// Check constructor status
    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		// Initialize the lower device
		m_Lower.Initialize(this, Pdo);

		// Inform the base class of the lower edge device object
		SetLowerDevice(&m_Lower);

		// Initialize the PnP Policy settings to the "standard" policy
		SetPnpPolicy();

		// Initialize the Power Policy settings to the "standard" policy
		SetPowerPolicy();

		m_buffer = new UCHAR[VSCSI_BUFFER_SIZE];
		if ( m_buffer )
			RtlZeroMemory(m_buffer, VSCSI_BUFFER_SIZE);
		else
			m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;
	}
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::~ServerDevice
//
//	Routine Description:
//		This is the destructor for the Functional Device Object, or FDO.
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
ServerDevice::~ServerDevice()
{
	t << "ServerDevice::~ServerDevice\n";

	if ( m_buffer )
		delete[] m_buffer;
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::DefaultPnp
//
//	Routine Description:
//		Default handler for IRP_MJ_PNP
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_PNP. IRPs that correspond to
//		any virtual members of KpnpDevice that handle minor functions of
//		IRP_MJ_PNP and that are not overridden get passed to this routine.
//
NTSTATUS ServerDevice::DefaultPnp(KIrp I) 
{
	t << "ServerDevice::DefaultPnp " << I;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::DefaultPower
//
//	Routine Description:
//		Default handler for IRP_MJ_POWER 
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_POWER.
//
NTSTATUS ServerDevice::DefaultPower(KIrp I) 
{
	t << "ServerDevice::DefaultPower " << I;

	I.IndicatePowerIrpProcessed();
	I.CopyParametersDown();
	return m_Lower.PnpPowerCall(this, I);
}

////////////////////////////////////////////////////////////////////////////////
//  ServerDevice::SystemControl
//
//	Routine Description:
//		Default handler for IRP_MJ_SYSTEM_CONTROL
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the next device since this driver
//		is not a WMI provider.
//
NTSTATUS ServerDevice::SystemControl(KIrp I) 
{
	t << "ServerDevice::SystemControl\n";

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::OnStartDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		None
//
NTSTATUS ServerDevice::OnStartDevice(KIrp I)
{
	t << "ServerDevice::OnStartDevice\n";

	I.Information() = 0;

	return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::OnStopDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		None
//
NTSTATUS ServerDevice::OnStopDevice(KIrp I)
{
	t << "ServerDevice::OnStopDevice\n";

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::OnRemoveDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		[in] I 
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//
NTSTATUS ServerDevice::OnRemoveDevice(KIrp I)
{
	t << "ServerDevice::OnRemoveDevice\n";

	// cancel pnp event notifications
	Server* pDriver = (Server*)KDriver::DriverInstance();
	pDriver->RemoveTdiPnpClient(this);

	// stop responding to broadcast messages
	if ( m_broadcast )
	{
		delete m_broadcast;
		m_broadcast = NULL;
	}

	// close all the sessions
    if ( m_pListener )  
	{
		delete m_pListener; 
		m_pListener = NULL;
	}

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::InitializeTDI
//
//	Routine Description:
//		Called to create the TDI objects
//
//	Parameters:
//		None
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		None
//
NTSTATUS ServerDevice::InitializeTDI()
{
	t << "ServerDevice::InitializeTDI\n";

	NTSTATUS status = STATUS_SUCCESS;

	if( !m_pListener && !m_broadcast && KTDInterface::Initialize() )
	{
		CIPTRANSPORT_ADDRESS port(2002);
		m_pListener = new ReadWriteSocket(this, port);

		if( m_pListener && m_pListener->IsCreated() && m_pListener->IsPresent() ) 
			m_pListener->SetEvents(TRUE);
		else 
			status = STATUS_INSUFFICIENT_RESOURCES;

		m_broadcast = new BroadcastSocket(port);
		if ( m_broadcast && m_broadcast->IsCreated() )
			m_broadcast->SetEvents(TRUE);
		else
			status = STATUS_INSUFFICIENT_RESOURCES;
	}
	else
		status = STATUS_NOT_FOUND;

	return status;
}

////////////////////////////////////////////////////////////////////////
//  ServerDevice::OnReceive
//
//	Routine Description:
//		Called to create the TDI objects
//
//	Parameters:
//		None
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		None
//
VOID ServerDevice::OnReceive(ReadWriteSession* session, PVOID Buffer, ULONG Size)
{
	t << "ServerDevice::OnReceive: Size " << Size << EOL;

	// check if it is a command packet
	if ( Size == 4 )
	{
		PUCHAR p = (PUCHAR)Buffer;

		m_length = p[1];
		m_block = ((USHORT)p[2] << 8) | p[3];

		t << "Length " << m_length << " Block " << m_block << EOL;

		if ( p[0] )
		{
			// it is a write request. Data follows.
			m_count = 0;
		}
		else
		{
			if ( (m_block + m_length) <= VSCSI_BUFFER_SIZE/512 )
				session->send(m_buffer + m_block * 512, m_length * 512);
			else
				session->disconnect();
		}

	}
	else
	{
		// validate write request
		if ( (m_block*512 + m_count + Size) <= VSCSI_BUFFER_SIZE )
		{
			RtlCopyMemory(m_buffer + m_block * 512 + m_count, Buffer, Size);
			m_count += Size;
		}
		else
			session->disconnect();
	}
}



