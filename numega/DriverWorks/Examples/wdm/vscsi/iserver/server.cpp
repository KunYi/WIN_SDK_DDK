// server.cpp
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#define VDW_MAIN
#include <vdw.h>
#include "tdiSclient.h"
#include "servdev.h"
#include "server.h"

POOLTAG DefaultPoolTag('resI');
KDebugOnlyTrace t("Server");

/////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(Server, NULL)

/////////////////////////////////////////////////////////////////////
//  Server::DriverEntry
//
//	Routine Description:
//		This is the first entry point called by the system when the
//		driver is loaded.
// 
//	Parameters:
//		[in] RegistryPath 
//			String used to find driver parameters in the
//			registry.  To locate Server look for:
//			HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Server
//
//	Return Value:
//		NTSTATUS - Return STATUS_SUCCESS if no errors are encountered.
//			Any other indicates to the system that an error has occured.
//
//	Comments:
//
NTSTATUS Server::DriverEntry(PUNICODE_STRING RegistryPath)
{
	t << "In DriverEntry Compiled at " __TIME__ " on " __DATE__ "\n";

	m_Unit = 0;
	m_bNetworkReady = false;
	m_Event.Initialize(NotificationEvent);

	KTdiPnpClient::Initialize(RegistryPath, TDI_PNP_HOOK_PNP_POWER | TDI_PNP_HOOK_BINDINGS | TDI_PNP_HOOK_ADDRESSES);

	return STATUS_SUCCESS;
}

// End INIT section
/////////////////////////////////////////////////////////////////////
#pragma code_seg()

/////////////////////////////////////////////////////////////////////
//  Server::AddDevice
//
//	Routine Description:
//		Called when the system detects a device for which this
//		driver is responsible.
//
//	Parameters:
//		[in] Pdo 
//			Physical Device Object. This is a pointer to a system device
//			object that represents the physical device.
//
//	Return Value:
//		NTSTATUS - Success or failure code.
//
//	Comments:
//		This function creates the Functional Device Object, or FDO. The FDO
//		enables this driver to handle requests for the physical device. 
//
NTSTATUS Server::AddDevice(PDEVICE_OBJECT Pdo)
{
	t << "Server::AddDevice\n";

	ServerDevice* pDevice = new (
			static_cast<PCWSTR>(KUnitizedName(L"ServerDevice", m_Unit)),
			FILE_DEVICE_UNKNOWN,
			NULL,
			0,
			DO_DIRECT_IO | DO_POWER_PAGABLE
			)
		ServerDevice(Pdo);

	NTSTATUS status;

	if ( pDevice )
	{
		status = pDevice->ConstructorStatus();

		if ( NT_SUCCESS(status) )
		{
			m_Unit++;
			pDevice->ReportNewDevicePowerState(PowerDeviceD0);

			if ( m_Providers && m_bNetworkReady )
				pDevice->InitializeTDI();

			AddTdiPnpClient(pDevice);
		}
		else
		{
			t << "Error constructing device ServerDevice" << m_Unit << " status " << status << EOL;
			delete pDevice;
		}
	}
	else
	{
		t << "Error creating device ServerDevice" << m_Unit << EOL;
	    status = STATUS_INSUFFICIENT_RESOURCES;
	}

	return status;
}

/////////////////////////////////////////////////////////////////////
//  Server::OnNetworkReady
//
//	Routine Description:
//		network ready notification handler
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID Server::OnNetworkReady()
{
	t << "Server::OnNetworkReady\n";

	if ( m_bNetworkReady )
		return;

	if ( m_Providers  )
	{
		m_bNetworkReady = true;

		m_Event.Clear();

		ServerDevice* pDevice = m_List.Head();
		while ( pDevice )
		{
			pDevice->InitializeTDI();
			pDevice = m_List.Next(pDevice);
		}

		m_Event.Set();
	}
}
	
/////////////////////////////////////////////////////////////////////
//  VScsiDriver::OnProviderReady
//
//	Routine Description:
//		provider ready notification handler
//
//	Parameters:
//		[in] DeviceName
//			device name
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID Server::OnProviderReady(KNdisString& DeviceName)
{
	t << "Server::OnProviderReady\n";

	++m_Providers;
}

VOID Server::OnAddAddress(USHORT AddressType, PVOID Address, KNdisString& DeviceName)
{
	if ( AddressType == TDI_ADDRESS_TYPE_IP )
	{
		TDI_ADDRESS_IP* IPAddress = (TDI_ADDRESS_IP*)Address;

		t << "Server::OnAddAddress: IP Address: " << IPAddress->in_addr << EOL;
	}
}

VOID Server::OnRemoveAddress(USHORT AddressType, PVOID Address, KNdisString& DeviceName)
{
	if ( AddressType == TDI_ADDRESS_TYPE_IP )
	{
		TDI_ADDRESS_IP* IPAddress = (TDI_ADDRESS_IP*)Address;

		t << "Server::OnRemoveAddress: IP Address: " << IPAddress->in_addr << EOL;
	}
}

TDI_STATUS Server::OnSetPower(KNdisString& DeviceName,NDIS_DEVICE_POWER_STATE PowerState)
{
	t << "Server::OnSetPower " << PowerState << EOL;
	return 0;
}

TDI_STATUS Server::OnQueryPower(KNdisString& DeviceName,NDIS_DEVICE_POWER_STATE PowerState)
{
	t << "Server::OnQueryPower " << PowerState << EOL;
	return 0;
}

TDI_STATUS Server::OnQueryRemoveDevice(KNdisString& DeviceName)
{
	t << "Server::OnQueryRemoveDevice\n";
	return 0;
}

TDI_STATUS Server::OnCancelRemoveDevice(KNdisString& DeviceName)
{
	t << "Server::OnCancelRemoveDevice\n";
	return 0;
}

TDI_STATUS Server::OnReconfigure(KNdisString& DeviceName)
{
	t << "Server::OnReconfigure\n";
	return 0;
}
