// sockets.cpp
// Implementation of iSocket and ScanSocket classes
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>

#include "vscsi.h"
#include "vdisk.h"

////////////////////////////////////////////////////////////////////////
//  iSocket::OnDisconnect
//
//	Routine Description:
//		handler of disconnect event
//
//	Parameters:
//		[in] OptionsLength 
//			options length
//
//		[in] Options 
//			options
//
//		[in] bAbort 
//			true if abort
//
//	Return Value:
//		None
//
//	Comments:
//		This routine informs the parent device that a particular network
//		disk disappeared.
//
void iSocket::OnDisconnect(uint OptionsLength, PVOID Options, BOOLEAN bAbort)
{
	t << "iSocket::OnDisconnect\n";

	m_pDevice->OnDisconnect();
}

////////////////////////////////////////////////////////////////////////
//  iSocket::On_connectComplete
//
//	Routine Description:
//		connect completion routine
//
//	Parameters:
//		[in] pCxt 
//			our context to connect command
//
//		[in] Status 
//			status of operation
//
//		[in] ByteCount 
//			ByteCount
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void iSocket::On_connectComplete(PVOID pCxt, TDI_STATUS Status, uint ByteCount)
{
	t << "iSocket::On_connectComplete\n";

	m_pDevice->OnConnect(Status);
}

////////////////////////////////////////////////////////////////////////
//  iSocket::OnReceive
//
//	Routine Description:
//		receive data handler
//
//	Parameters:
//		[in] Indicated 
//			number of bytes indicated
//
//		[in] Data
//			received data
//
//		[in] Available
//			number of bytes available
//
//		[out] RcvBuffer 
//			buffer for the rest of data
//
//		[out] RcvBufferLen 
//			size of rcv buffer
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
uint iSocket::OnReceive(uint Indicated, uchar *Data, uint Available, uchar **RcvBuffer, uint* RcvBufferLen)
{
	t << "iSocket::OnReceive: Indicated " << Indicated << " Available " << Available << EOL;

	ULONG length;

	if ( Indicated > 1 )
	{
		length = min(Indicated, m_length - m_nBytes);

		RtlCopyMemory(m_buffer + m_nBytes, Data, length);
		m_nBytes += length;

		if ( Indicated < Available )
		{
			*RcvBuffer = m_buffer + m_nBytes;
			*RcvBufferLen = m_length - m_nBytes;
		}
		else if ( m_nBytes == m_length )
			m_pDevice->OnReadComplete(STATUS_SUCCESS);
	}
	else
		length = Indicated;

	return length;
}

////////////////////////////////////////////////////////////////////////
//  iSocket::OnReceiveComplete
//
//	Routine Description:
//		receive data handler
//
//	Parameters:
//		[in] Status
//			status of operation
//
//		[in] Indicated 
//			number of bytes indicated
//
//		[in] Data
//			received data
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void iSocket::OnReceiveComplete(TDI_STATUS Status, uint Indicated, uchar *Data)
{
	t << "iSocket::OnReceiveComplete " << Indicated << EOL;

	ULONG length = min(Indicated, m_length - m_nBytes);

	RtlCopyMemory(m_buffer + m_nBytes, Data, length);
	m_nBytes += length;

	if ( m_nBytes == m_length )
		m_pDevice->OnReadComplete(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  iSocket::On_sendComplete
//
//	Routine Description:
//		send complete handler
//
//	Parameters:
//		[in] pCxt
//			pointer to our context
//
//		[in] Status 
//			status of send
//
//		[in] ByteCount
//			number of bytes send
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void iSocket::On_sendComplete(PVOID pCxt, TDI_STATUS Status, uint ByteCount)
{
	t << "iSocket::On_sendComplete " << ByteCount << EOL;

	if ( pCxt )
	{
		PUCHAR p = (PUCHAR)pCxt;
		delete[] p;
	}
	else
		m_pDevice->OnWriteComplete(Status, ByteCount);
}

////////////////////////////////////////////////////////////////////////
//  iSocket::Write
//
//	Routine Description:
//		Sends data to the target
//
//	Parameters:
//		[in] block
//			block number
//
//		[in] length 
//			number of blocks to send
//
//		[in] buffer
//			data buffer
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void iSocket::Write(ULONG block, ULONG length, PVOID buffer)
{
	t << "iSocket::Write: Block " << block << " Length " << length << EOL;

	if ( IsConnected() )
	{
		PUCHAR p = new UCHAR[4];

		if ( p )
		{
			p[0] = VSCSI_COMMAND_WRITE;
			p[1] = (UCHAR)(length);
			p[2] = (UCHAR)(block >> 8);
			p[3] = (UCHAR)block;

			send(p, 4, p);
			send(buffer, length * 512, NULL);
		}
		else
			m_pDevice->OnWriteComplete(TDI_NO_RESOURCES, 0);
	}
	else
		m_pDevice->OnWriteComplete(TDI_INVALID_CONNECTION, 0);
}

////////////////////////////////////////////////////////////////////////
//  iSocket::Read
//
//	Routine Description:
//		Requests data from the target
//
//	Parameters:
//		[in] block
//			block number
//
//		[in] length 
//			number of blocks to read
//
//		[in] buffer
//			data buffer
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void iSocket::Read(ULONG block, ULONG length, PVOID buffer)
{
	t << "iSocket::Read: Block " << block << " Length " << length << EOL;

	if ( IsConnected() )
	{
		PUCHAR p = new UCHAR[4];
		
		if ( p )
		{
			p[0] = VSCSI_COMMAND_READ;
			p[1] = (UCHAR)length;
			p[2] = (UCHAR)(block >> 8);
			p[3] = (UCHAR)block;

			m_nBytes = 0;
			m_length = length * 512;
			m_buffer = (PUCHAR)buffer;

			send(p, 4, p);
		}
		else
			m_pDevice->OnReadComplete(TDI_NO_RESOURCES);
	}
	else
		m_pDevice->OnReadComplete(TDI_INVALID_CONNECTION);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//  ScanSocket::Scan
//
//	Routine Description:
//		Sends broadcast packet to udp port 2002
//
//	Parameters:
//		[in] address 
//			broadcast address of local network
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID ScanSocket::Scan(ULONG address)
{
	CTDI_CONNECTION_INFORMATION localnetwork(2002, address);
	
	PUCHAR p = new UCHAR[4];

	p[0] = 'V';
	p[1] = 'l';
	p[2] = 'a';
	p[3] = 'd';

	TDI_STATUS Status = sendto(localnetwork, p, 4, p);
	if ( Status != TDI_PENDING )
		delete[] p;
}

////////////////////////////////////////////////////////////////////////
//  ScanSocket::On_sendtoComplete
//
//	Routine Description:
//		Frees allocated packet
//
//	Parameters:
//		[in] pCxt 
//			our packet allocated in Scan
//
//		[in] Status
//			status of a sendto
//
//		[in] ByteCount
//			number of bytes successfully sent
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void ScanSocket::On_sendtoComplete(PVOID pCxt, TDI_STATUS Status, uint ByteCount)
{
	PUCHAR p = (PUCHAR)pCxt;
	delete[] p;
}

////////////////////////////////////////////////////////////////////////
//  ScanSocket::OnReceive
//
//	Routine Description:
//		Receives responses from found network targets.
//
//	Parameters:
//		[in] AddressLength 
//			address length
//
//		[in] pTA
//			pointer to address
//
//		[in] OptionsLength
//			option length
//
//		[in] Options
//			options
//
//		[in] Indicated
//			number of bytes indicated
//
//		[in] Data
//			packet
//
//		[in] Available
//			number of data available
//
//		[out] RcvBuffer
//			buffer to receive more data
//
//		[out] RcvBufferLen
//			length of rcv buffer
//
//	Return Value:
//		number of bytes consumed
//
//	Comments:
//		None
//
uint ScanSocket::OnReceive(
	uint AddressLength, 
	PTRANSPORT_ADDRESS pTA, 
	uint OptionsLength, 
	PVOID Options, 
	uint Indicated, 
	uchar* Data, 
	uint Available, 
	uchar** RcvBuffer, 
	uint* RcvBufferLen)
{
	char szIPaddr[20];

	inet_ntoa(PTDI_ADDRESS_IP(pTA->Address[0].Address)->in_addr, szIPaddr, sizeof(szIPaddr));

    t << "BroadcastSocket::OnReceive " << szIPaddr << EOL;

	m_pDevice->OnFoundDisk(PTDI_ADDRESS_IP(pTA->Address[0].Address)->in_addr);

	return Indicated;
}
