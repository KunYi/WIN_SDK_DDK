// Simple1394Device.cpp
// Implementation of Simple1394Device device class
//
// Generated by DriverWizard version DriverStudio 2.5.0 (Build 44)
// Requires Compuware's DriverWorks classes
//

#pragma warning(disable:4065) // Allow switch statement with no cases

#include <vdw.h>
#include "..\Simple1394Deviceinterface.h"

#include "Simple1394.h"
#include "Simple1394Device.h"

#pragma hdrstop("Simple1394.pch")

GUID Simple1394Device_Guid = Simple1394Device_CLASS_GUID;

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::Simple1394Device
//
//	Routine Description:
//		This is the constructor for the Functional Device Object, or FDO.
//		It is derived from KPnpDevice, which builds in automatic
//	    dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP to
//		virtual member functions.
//
//	Parameters:
//		Pdo - Physical Device Object - this is a pointer to a system
//			device object that represents the physical device.
//
//		Unit - Unit number. This is a number to append to the device's
//			base device name to form the Logical Device Object's name
//
//	Return Value:
//		None
//
//	Comments:
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the FDO to the
//		PDO and creates an interface to the upper edge of the system class driver.
//

Simple1394Device::Simple1394Device(PDEVICE_OBJECT Pdo) :
	KPnpDevice(Pdo, &Simple1394Device_Guid)
{
	t << "Entering Simple1394Device::Simple1394Device (constructor)\n";

	// Check constructor status
	if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		// Initialize the lower device
		m_1394Bus.Initialize(this, Pdo);

		// Inform the base class of the lower edge device object
		SetLowerDevice(&m_1394Bus);

		// Initialize the PnP Policy settings to the "standard" policy
		SetPnpPolicy();

		// Initialize the Power Policy settings to the "standard" policy
		SetPowerPolicy();

		m_DriverManagedQueue.Initialize(Pdo);
	}

	return;
}


////////////////////////////////////////////////////////////////////////
//  Simple1394Device::~Simple1394Device
//
//	Routine Description:
//		This is the destructor for the Functional Device Object, or FDO.
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//

Simple1394Device::~Simple1394Device()
{
	t << "Entering Simple1394Device::~Simple1394Device() (destructor)\n";
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::DefaultPnp
//
//	Routine Description:
//		Default handler for IRP_MJ_PNP
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is
//		the default handler for IRP_MJ_PNP. IRPs that correspond to
//		any virtual members of KpnpDevice that handle minor functions of
//		IRP_MJ_PNP and that are not overridden get passed to this routine.
//

NTSTATUS Simple1394Device::DefaultPnp(KIrp I)
{
	t << "Entering Simple1394Device::DefaultPnp" << I;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_1394Bus.PnpCall(this, I);
}


////////////////////////////////////////////////////////////////////////
//  Simple1394Device::DefaultPower
//
//	Routine Description:
//		Default handler for IRP_MJ_POWER
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is
//		the default handler for IRP_MJ_POWER.
//

NTSTATUS Simple1394Device::DefaultPower(KIrp I)
{
	t << "Entering Simple1394Device::DefaultPower" << I;

	I.IndicatePowerIrpProcessed();
	I.CopyParametersDown();
	return m_1394Bus.PnpPowerCall(this, I);
}

////////////////////////////////////////////////////////////////////////////////
//  Simple1394Device::SystemControl
//
//	Routine Description:
//		Default handler for IRP_MJ_SYSTEM_CONTROL
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the next device since this driver
//		is not a WMI provider.
//

NTSTATUS Simple1394Device::SystemControl(KIrp I)
{
	t << "Entering Simple1394Device::SystemControl\n";

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_1394Bus.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::OnStartDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		Initialize the physical device. Typically, the driver initializes
//		physical resources here.  Call I.AllocatedResources() for a list
//		of the raw resources that the system has assigned to the device,
//		or I.TranslatedResources() for the translated resource list.
//

NTSTATUS Simple1394Device::OnStartDevice(KIrp I)
{
	t << "Entering Simple1394Device::OnStartDevice\n";

	I.Information() = 0;

	NTSTATUS status;

	// Let's dump some 1394 bus information

	// First let's see if we can get the host controller's 
	// physical address mapping function
	GET_LOCAL_HOST_INFO4 PhysMapInfo;
	status = m_1394Bus.AddressMappingRoutine(&PhysMapInfo);
	if ( NT_SUCCESS(status) )
	{
		t << "PhysAddrMappingRoutine = " << PhysMapInfo.PhysAddrMappingRoutine << EOL;
		t << "Context = " << PhysMapInfo.Context << EOL;
	}
	else
	{
		t << "AddressMappingRoutine failed. Status: " << status << EOL;
	}

	// Requests the port driver to return the 64-bit unique identifier
	t << "HostUniqueId = " << m_1394Bus.HostUniqueID() << EOL;

	// Requests the port driver to return the bus' power characteristics
	ULONG Watts;
	ULONG Voltage;
	status = m_1394Bus.PowerInformation(&Watts, &Voltage);
	if ( NT_SUCCESS(status) )
	{
		t << "Watts  " << Watts << "  Voltage " << Voltage << EOL;
	}
	else
	{
		t << "PowerInformation failed. Status: " << status << EOL;
	}

	// Requests the port driver to return the host controller's capability flags
	ULONG CapabilityFlags;
	ULONG MaxAsyncReadSize;
	ULONG MaxAsyncWriteSize;
	status = m_1394Bus.HostCapabilities(&CapabilityFlags, &MaxAsyncReadSize, &MaxAsyncWriteSize);
	if ( NT_SUCCESS(status) )
	{
		if ( CapabilityFlags & HOST_INFO_PACKET_BASED )
		{
			t << "HOST_INFO_PACKET_BASED" << EOL; 
		}

		if ( CapabilityFlags & HOST_INFO_STREAM_BASED )
		{
			t << "HOST_INFO_STREAM_BASED" << EOL; 
		}

		if ( CapabilityFlags & HOST_INFO_SUPPORTS_ISOCH_STRIPPING )
		{
			t << "HOST_INFO_SUPPORTS_ISOCH_STRIPPING" << EOL; 
		}

		if ( CapabilityFlags & HOST_INFO_SUPPORTS_START_ON_CYCLE )
		{
			t << "HOST_INFO_SUPPORTS_START_ON_CYCLE" << EOL; 
		}

		if ( CapabilityFlags & HOST_INFO_SUPPORTS_RETURNING_ISO_HDR )
		{
			t << "HOST_INFO_SUPPORTS_RETURNING_ISO_HDR" << EOL; 
		}

		if ( CapabilityFlags & HOST_INFO_SUPPORTS_ISO_HDR_INSERTION )
		{
			t << "HOST_INFO_SUPPORTS_ISO_HDR_INSERTION" << EOL; 
		}

		t << "MaxAsyncReadSize = " << MaxAsyncReadSize << EOL;
		t << "MaxAsyncWriteSize = " << MaxAsyncWriteSize << EOL;
	}
	else
	{
		t << "HostCapabilities failed. Status: " << status << EOL;
	}

	// Let's get the maximum (simultaneous) transfer speed
	ULONG Speed;
	PDEVICE_OBJECT deviceObject = *this;
	status = m_1394Bus.GetSpeedBetweenDevices(1, &deviceObject, USE_LOCAL_NODE, &Speed);
	if ( NT_SUCCESS(status) )
	{
		if ( Speed == SPEED_FLAGS_100 )
		{
			t << "Speed is 100 Mb/s" << EOL;
		}
		else if ( Speed == SPEED_FLAGS_200 )
		{
			t << "Speed is 200 Mb/s" << EOL;
		}
		else if ( Speed == SPEED_FLAGS_400 )
		{
			t << "Speed is 400 Mb/s" << EOL;
		}
		else
		{
			t << "Unknown speed = " << Speed << EOL;
		}
	}
	else
	{
		t << "GetSpeedBetweenDevices failed. Status: " << status << EOL;
	}

	K1394Configuration Config(&m_1394Bus);
	if ( Config.IsAllocated() )
	{
		t << "Vendor Name: " << Config.VendorName() << EOL;
		t << "Model Name:  " << Config.ModelName() << EOL;
	}
	else
	{
		t << "K1394Configuration failed" << EOL;
	}

	status = m_GenerationCount.Initialize(&m_1394Bus);
	if ( NT_SUCCESS(status) )
	{
		t << "Generation Count: " << m_GenerationCount << EOL;

		m_1394Bus.BusReset();
	}
	else
	{
		t << "Generation Count failed. Status: " << status << EOL;
	}

	t << "Generation Count: " << m_GenerationCount << EOL;

	return status;
}


////////////////////////////////////////////////////////////////////////
//  Simple1394Device::OnStopDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is stopped.
//		The driver should release any hardware resources
//		in this routine.
//
//		The base class passes the irp to the lower device.
//

NTSTATUS Simple1394Device::OnStopDevice(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering Simple1394Device::OnStopDevice" << EOL;

	status = m_GenerationCount.Deinitialize();

	return status;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::OnRemoveDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//

NTSTATUS Simple1394Device::OnRemoveDevice(KIrp I)
{
	t << "Entering Simple1394Device::OnRemoveDevice" << EOL;

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}


////////////////////////////////////////////////////////////////////////
//  Simple1394Device::OnDevicePowerUp
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to power on state from low power state
//
//	Parameters:
//		I - IRP containing POWER request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the OnDevicePowerUp function.
//		This function was called by the framework from the completion
//		routine of the IRP_MJ_POWER dispatch handler in KPnpDevice.
//		The bus driver has completed the IRP and this driver can now
//		access the hardware device.
//		This routine runs at dispatch level.
//

NTSTATUS Simple1394Device::OnDevicePowerUp(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering Simple1394Device::OnDevicePowerUp" << EOL;

	status = m_GenerationCount.Initialize(&m_1394Bus);

	return status;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::OnDeviceSleep
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to a low power state from a high power state
//
//	Parameters:
//		I - IRP containing POWER request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the OnDeviceSleep function.
//		This function was called by the framework from the IRP_MJ_POWER
//		dispatch handler in KPnpDevice prior to forwarding to the PDO.
//		The hardware has yet to be powered down and this driver can now
//		access the hardware device.
//		This routine runs at passive level.
//

NTSTATUS Simple1394Device::OnDeviceSleep(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering Simple1394Device::OnDeviceSleep" << EOL;

	status = m_GenerationCount.Deinitialize();

	return status;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::Create
//
//	Routine Description:
//		Handler for IRP_MJ_CREATE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS Simple1394Device::Create(KIrp I)
{
	NTSTATUS status;

	t << "Entering Simple1394Device::Create, " << I << EOL;

	status = I.PnpComplete(this, STATUS_SUCCESS, IO_NO_INCREMENT);

	t << "Simple1394Device::Create Status " << (ULONG)status << EOL;

	return status;
}


////////////////////////////////////////////////////////////////////////
//  Simple1394Device::Close
//
//	Routine Description:
//		Handler for IRP_MJ_CLOSE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS Simple1394Device::Close(KIrp I)
{
	NTSTATUS status;

	t << "Entering Simple1394Device::Close, " << I;

	status = I.PnpComplete(this, STATUS_SUCCESS, IO_NO_INCREMENT);

	t << "Simple1394Device::Close Status " << (ULONG)status << EOL;

	return status;
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::Cleanup
//
//	Routine Description:
//		Handler for IRP_MJ_CLEANUP
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS Simple1394Device::CleanUp(KIrp I)
{
	t << "Entering CleanUp, " << I;

	m_DriverManagedQueue.PnpCleanUp(this, I.FileObject());
	return I.PnpComplete(this, STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::SerialRead
//
//	Routine Description:
//		Handler for serialized READ
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		None
//
//	Comments:
//		This routine is called when the IRP is removed from the
//		STARTIO queue.  This guarantees that multiple requests are
//		never processed simultaneously.
//
//		This routine is called at dispatch level.
//

void Simple1394Device::SerialRead(KIrp I)
{
	t << "Entering Simple1394Device::SerialRead, " << I;

	//Allocate our completion context and IRB
	KIrbWithContext<REQUEST_ASYNC_READ, COMPLETE_CONTEXT>* pIrb = new KIrbWithContext<REQUEST_ASYNC_READ, COMPLETE_CONTEXT>;

	//If we failled to allocate, clean up and complete the IRP
	if( pIrb )
	{
		//Fill in the context structure
		pIrb->m_Context.pQueue = &m_DriverManagedQueue;
		pIrb->m_Context.I = I;

		//Initialize the IRB for an asynchronous read request
		// Note:  This request reads from the
		// offset 0x100000000 in the device's 1394 address space.  The request
		// will succeed only if the driver has read access to that address.
		pIrb->Initialize(m_GenerationCount, 1, 0, I.Mdl());

		//Submit the Irb to the lower device.  It will complete in CompleteAsync
		m_1394Bus.SubmitIrb(pIrb, ReadWriteComplete, pIrb);
	}
	else
	{
		//Complete the IRP
		I.Information() = 0;
		I.Status() = STATUS_INSUFFICIENT_RESOURCES;
		m_DriverManagedQueue.PnpNextIrp(I);
	}

	return;
}


////////////////////////////////////////////////////////////////////////
//  Simple1394Device::Read
//
//	Routine Description:
//		Handler for IRP_MJ_READ
//
//	Parameters:
//		I			Current IRP
//
//	Return Value:
//		NTSTATUS	Result code
//
//	Comments:
//		This routine handles read requests.
//
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.
//

NTSTATUS Simple1394Device::ReadWrite(KIrp I)
{
	t << "Entering Simple1394Device::ReadWrite, " << I;

	NTSTATUS status;

	// Always ok to read 0 elements.
	if ( I.ReadSize() == 0 )
	{
		I.Information() = 0;
		status = I.PnpComplete(this, STATUS_SUCCESS);
	}
	else
	{
		// Queue the IRP for processing in the driver managed queue.
		// The actual read function is performed in SerialRead
		status = m_DriverManagedQueue.QueueIrp(I);
	}

	return status;
}

////////////////////////////////////////////////////////////////////////
//  Simple1394Device::SerialWrite
//
//	Routine Description:
//		Handler for serialized WRITE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		None
//
//	Comments:
//		This routine is called when the IRP is removed from the
//		STARTIO queue.  This guarantees that multiple requests are
//		never processed simultaneously.
//

void Simple1394Device::SerialWrite(KIrp I)
{
	t << "Entering Simple1394Device::SerialWrite, " << I;

	//Allocate our completion context and IRB
	KIrbWithContext<REQUEST_ASYNC_WRITE, COMPLETE_CONTEXT>* pIrb = new KIrbWithContext<REQUEST_ASYNC_WRITE, COMPLETE_CONTEXT>;

	if( pIrb )
	{
		//Fill in the context structure
		pIrb->m_Context.pQueue = &m_DriverManagedQueue;
		pIrb->m_Context.I = I;

		//Initialize the IRB for an asynchronous write.
		// Note:  This request writes to the
		// offset 0x100000000 in the device's 1394 address space.  The request
		// will succeed only if the driver has write access to that address.
		pIrb->Initialize(m_GenerationCount, 1, 0, I.Mdl());

		//Submit the IRB to the lower device.  The processing will complete in
		//  CompleteAsync.
		m_1394Bus.SubmitIrb(pIrb, ReadWriteComplete, pIrb);
	}
	else
	{
		//Complete the IRP
		I.Information() = 0;
		I.Status() = STATUS_INSUFFICIENT_RESOURCES;
		m_DriverManagedQueue.PnpNextIrp(I);
	}

	return;
}


////////////////////////////////////////////////////////////////////////////////
//  Simple1394Device_DriverManagedQueue::StartIo
//
//	Routine Description:
//		This routine is called when an IRP is taken off
//		the Driver Managed Queue (used for serializing I/O) and
//		presented for processing.
//
//	Parameters:
//		I - IRP removed from queue
//
//	Return Value:
//		None
//
//	Comments:
//

VOID Simple1394Device_DriverManagedQueue::StartIo(KIrp I)
{
	t  << "Entering Simple1394Device_DriverManagedQueue StartIo, " << I;

	// The KDriverManagedQueueCsq class gives us the Irp in a cancelable state
	// (cancel routine set to CSQ routine) and we don't having to worry
	// about clearing the cancel routine.

	// Find the device class so we can call the serialized
	// routines in the device class.  The handlers can be
	// moved to the DriverManagedQueue class if it is more
	// convenient.
	Simple1394Device* pDev = (Simple1394Device*)KDevicePTR(I.DeviceObject());

	// Start processing request.

	// Switch on the IRP's function:
	switch ( I.MajorFunction() )
	{
		case IRP_MJ_READ:
			pDev->SerialRead(I);
			break;

		case IRP_MJ_WRITE:
			pDev->SerialWrite(I);
			break;

		default:
			// Error - unexpected IRP received
			// NextIrp completes this IRP and starts processing
			// for the next IRP in the queue.
			ASSERT(FALSE);
			I.Status() = STATUS_INVALID_PARAMETER;
			PnpNextIrp(I);
			break;
	}
}


NTSTATUS Simple1394Device::ReadWriteComplete(PDEVICE_OBJECT DeviceObject, PIRP pIrp, PVOID Context)
{
	KIrbWithContext<REQUEST_ASYNC_WRITE, COMPLETE_CONTEXT>* pIrb = 
		reinterpret_cast<KIrbWithContext<REQUEST_ASYNC_WRITE, COMPLETE_CONTEXT>*>(Context);

	// to reduce typing
	KIrp& I = pIrb->m_Context.I;

	NTSTATUS status = I.Status() = pIrp->IoStatus.Status;

	// Write and read use the same location in the stack to store the length.
	// Note: The PDO completes this Irp and does not fill this in for us.
	I.Information() = I.WriteSize(CURRENT);

	// Start processing the next Irp, but do not complete this one since it was
	// already completed by the 1394 bus device
	pIrb->m_Context.pQueue->PnpNextIrp(I);

	delete pIrb;

	return status;

	UNREFERENCED_PARAMETER(DeviceObject);
}

