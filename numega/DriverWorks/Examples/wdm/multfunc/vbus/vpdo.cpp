// vpdo.cpp
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>
#include "vbus.h"
#include "vbusdev.h"
#include "..\vinterface.h"

#pragma hdrstop("vbus.pch")

#include "vpdo.h"
#include "stdio.h"

UCHAR g_Buffer[PAGE_SIZE];

////////////////////////////////////////////////////////////////////////
//  VPdo::VPdo
//
//	Routine Description:
//		Constructor for VPdo class
//
//	Parameters:
//		[in] pParent
//			pointer to a parent FDO
//
//		[in] pBus
//			pointer to a pdo collection
//
//		[in] Unit
//			id
//
//	Return Value:
//		None   
//
//	Comments:
//		None
//
VPdo::VPdo(VBusDevice* pParent, VBus* pBus, ULONG Unit) :
	KPhysicalDevice(pBus),
	m_Parent(pParent),
	m_Unit(Unit),
	m_HardwareIDs(NULL)
{
	t << "VPdo::VPdo " << Unit << EOL;

	// Check constructor status
    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		SetPnpPolicy();
		SetPowerPolicy();
	}
}


////////////////////////////////////////////////////////////////////////
//  VPdo::~VPdo
//
//	Routine Description:
//		Destructor for VPdo class
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VPdo::~VPdo()
{
	t << "VPdo::~VPdo() " << m_Unit << EOL;

	if ( m_HardwareIDs )
		delete[] m_HardwareIDs;
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryDeviceText
//
//	Routine Description:
//		IRP_MN_QUERY_DEVICE_TEXT handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::QueryDeviceText(const WCHAR* Model, KIrp I)
{
	t << "VPdo::OnQueryDeviceText " << m_Unit << EOL;

	NTSTATUS status = STATUS_SUCCESS;

	switch ( I.CurrentStackLocation()->Parameters.QueryDeviceText.DeviceTextType )
	{
	case DeviceTextDescription:
		switch ( I.CurrentStackLocation()->Parameters.QueryDeviceText.LocaleId ) 
		{
        case 0x00000409: // English
        default:
            if( !I.Information() ) 
			{
                ULONG length = (ULONG)(wcslen(VENDORNAME) + wcslen(Model) + 8)*sizeof(WCHAR);

                PWCHAR buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, length, DefaultPoolTag);
                if ( buffer ) 
				{
					swprintf(buffer, L"%ws%ws%02d", VENDORNAME, Model, m_Unit);
					I.Information() = (ULONG_PTR)buffer;
				}
				else
				{
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

            }
            break;           
		}
		break;
	case DeviceTextLocationInformation:
		break;
	default:
		status = I.Status();
		break;
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryId
//
//	Routine Description:
//		IRP_MN_QUERY_DEVICE_TEXT handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::OnQueryId(KIrp I)
{
	NTSTATUS	status = STATUS_SUCCESS;

    PWCHAR		buffer;
    ULONG		length;

	t << "VPdo::OnQueryId " << m_Unit << EOL;

	switch ( I.QueryIdType() )
	{
	case BusQueryDeviceID:
		buffer = m_HardwareIDs;

        while ( *(buffer++) ) 
		{
            while ( *(buffer++) );
        }

        length = (ULONG)(buffer - m_HardwareIDs)*sizeof(WCHAR);

        buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, length, DefaultPoolTag);

        if ( buffer ) 
		{
			RtlCopyMemory(buffer, m_HardwareIDs, length);
			I.Information() = (ULONG_PTR)buffer;
		}
		else
		{
           status = STATUS_INSUFFICIENT_RESOURCES;
        }
		break;

    case BusQueryInstanceID:
        buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, 6*sizeof(WCHAR), DefaultPoolTag);
        if ( buffer ) 
		{
			swprintf(buffer, L"%02d", m_Unit);
			I.Information() = (ULONG_PTR)buffer;
		}
		else
		{
           status = STATUS_INSUFFICIENT_RESOURCES;
        }
        break;

    case BusQueryHardwareIDs:
        buffer = m_HardwareIDs;

        while ( *(buffer++) ) 
		{
            while ( *(buffer++) );
        }

        length = (ULONG)(buffer - m_HardwareIDs)*sizeof(WCHAR);
        buffer = (PWCHAR)ExAllocatePoolWithTag(PagedPool, length, DefaultPoolTag);

        if ( buffer ) 
		{
			RtlCopyMemory(buffer, m_HardwareIDs, length);
			I.Information() = (ULONG_PTR)buffer;
		}
		else
		{
           status = STATUS_INSUFFICIENT_RESOURCES;
        }
        break;

    default:
        status = I.Status();
		break;
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryBusInformation
//
//	Routine Description:
//		IRP_MN_QUERY_BUS_INFORMATION handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::OnQueryBusInformation(KIrp I)
{
	t << "VPdo::OnQueryBusInformation " << m_Unit << EOL;

	NTSTATUS status = STATUS_SUCCESS;

    PPNP_BUS_INFORMATION busInfo = (PPNP_BUS_INFORMATION)ExAllocatePoolWithTag(PagedPool, sizeof(PNP_BUS_INFORMATION), DefaultPoolTag);

    if ( busInfo ) 
	{
		busInfo->BusTypeGuid = GUID_VIRTUAL_BUS_TYPE;

		busInfo->LegacyBusType = PNPBus;
		busInfo->BusNumber = 0;

	    I.Information() = (ULONG_PTR)busInfo;
	}
	else
	{
      status = STATUS_INSUFFICIENT_RESOURCES;
    }

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryBusInformation
//
//	Routine Description:
//		IRP_MN_DEVICE_USAGE_NOTIFICATION handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::OnDeviceUsageNotification(KIrp I)
{
	NTSTATUS status = STATUS_UNSUCCESSFUL;

	t << "VPdo::OnDeviceUsageNotification " << m_Unit << EOL;

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryResources
//
//	Routine Description:
//		IRP_MN_QUERY_RESOURCES handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::OnQueryResources(KIrp I)
{
	t << "VPdo::OnQueryResources " << m_Unit << EOL;

#if 0
	PAGED_CODE();

	NTSTATUS status = STATUS_SUCCESS;


	ULONG size = sizeof(CM_RESOURCE_LIST);

	PCM_RESOURCE_LIST rl = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(PagedPool, size, DefaultPoolTag);
	if ( rl )
	{
		RtlZeroMemory(rl, size);
		rl->Count = 1;

		CM_FULL_RESOURCE_DESCRIPTOR& fd = rl->List[0];

		fd.PartialResourceList.Count = 1;

		CM_PARTIAL_RESOURCE_DESCRIPTOR& pd = fd.PartialResourceList.PartialDescriptors[0];

		pd.Type = CmResourceTypeMemory;
		pd.ShareDisposition = CmResourceShareShared;
		pd.u.Port.Start.QuadPart = (ULONG64)g_Buffer;
		pd.u.Port.Length = 1;
		I.Information() = (ULONG_PTR)rl;
	}
	else
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

	return I.PnpComplete(status);
#endif

	return DefaultPnp(I);
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryResourceRequirements
//
//	Routine Description:
//		IRP_MN_QUERY_RESOURCES handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::OnQueryResourceRequirements(KIrp I)
{
	t << "VPdo::OnQueryResourceRequirements " << m_Unit << EOL;

#if 0

	PAGED_CODE();

	NTSTATUS status = STATUS_SUCCESS;

	ULONG size = sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

	PIO_RESOURCE_REQUIREMENTS_LIST rl = 
		(PIO_RESOURCE_REQUIREMENTS_LIST)ExAllocatePoolWithTag(PagedPool, size, DefaultPoolTag);

	if ( rl )
	{
		RtlZeroMemory(rl, size);

		rl->ListSize = size;

		rl->AlternativeLists = 1;
//		rl->InterfaceType = InterfaceTypeUndefined;
//		rl->BusNumber = 0;
		rl->List[0].Version = 1;
		rl->List[0].Revision = 1;
		rl->List[0].Count = 1;

		IO_RESOURCE_DESCRIPTOR& rd = rl->List[0].Descriptors[0];

		rd.Type = CmResourceTypeMemory;
		rd.ShareDisposition = CmResourceShareShared;
		rd.u.Memory.Length = 1;
		rd.u.Memory.Alignment = 1;
		rd.u.Memory.MinimumAddress.QuadPart = (ULONG64)g_Buffer;
		rd.u.Memory.MaximumAddress.QuadPart = (ULONG64)g_Buffer - sizeof(g_Buffer);

		I.Information() = (ULONG_PTR)rl;
	}
	else
	{
		status = STATUS_INSUFFICIENT_RESOURCES;
	}

	return I.PnpComplete(status);
#endif

	return DefaultPnp(I);
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryRemoveDevice
//
//	Routine Description:
//		IRP_MN_QUERY_REMOVE_DEVICE handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::OnQueryRemoveDevice(KIrp I)
{
	NTSTATUS status;

	t << "VPdo::OnQueryRemoveDevice " << m_Unit << EOL;

	if ( m_RefCount )
	{
		status = STATUS_UNSUCCESSFUL;
	}
	else
	{
		status = STATUS_SUCCESS;
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VPdo::OnQueryRemoveDevice
//
//	Routine Description:
//		IRP_MN_QUERY_REMOVE_DEVICE handler
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP IRP
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS VPdo::OnQueryCapabilities(KIrp I)
{
	t << "VPdo::OnQueryCapabilities " << m_Unit << EOL;

	NTSTATUS status = STATUS_SUCCESS;

	PDEVICE_CAPABILITIES caps = I.DeviceCapabilities();

	if ( (caps->Version == 1) && (caps->Size >= sizeof(DEVICE_CAPABILITIES)) )
	{
		status = m_Parent->GetDeviceCapabilities();
		if ( NT_SUCCESS(status) )
		{
			RtlCopyMemory(caps->DeviceState, m_Parent->DevCaps().DeviceState, sizeof(caps->DeviceState));

			caps->DeviceState[PowerSystemWorking] = PowerDeviceD0;

			if ( caps->DeviceState[PowerSystemSleeping1] != PowerDeviceD0 )
				caps->DeviceState[PowerSystemSleeping1] = PowerDeviceD1;
        
			if ( caps->DeviceState[PowerSystemSleeping2] != PowerDeviceD0 )
				caps->DeviceState[PowerSystemSleeping2] = PowerDeviceD3;

			if ( caps->DeviceState[PowerSystemSleeping3] != PowerDeviceD0 )
				caps->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;

			caps->DeviceD1 = TRUE;
			caps->DeviceD2 = FALSE;

			caps->LockSupported = FALSE;
			caps->EjectSupported = FALSE;
			caps->Removable = TRUE;
			caps->DockDevice = FALSE;
			caps->UniqueID = FALSE;
			caps->SilentInstall = FALSE;
			caps->RawDeviceOK = FALSE;
			caps->SurpriseRemovalOK = TRUE;

			caps->WakeFromD0 = FALSE;
			caps->WakeFromD1 = TRUE;
			caps->WakeFromD2 = FALSE;
			caps->WakeFromD3 = FALSE;

			caps->HardwareDisabled = FALSE;
#if ((WDM_MAJORVERSION == 1) && (WDM_MINORVERSION >= 0x20))			
			caps->NoDisplayInUI = FALSE;
#endif
			caps->Address = m_Unit;
			caps->UINumber = m_Unit;

			caps->D1Latency = 0;
			caps->D2Latency = 0;
			caps->D3Latency = 0;

			caps->DeviceWake = PowerDeviceD1;
		}
	}
	else
		status = STATUS_UNSUCCESSFUL;


	return I.PnpComplete(status);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//  VReader::VReader
//
//	Routine Description:
//		Constructor for VReader class
//
//	Parameters:
//		[in] pParent
//			pointer to a parent FDO
//
//		[in] pBus
//			pointer to a pdo collection
//
//		[in] Unit
//			id
//
//	Return Value:
//		None   
//
//	Comments:
//		None
//
VReader::VReader(VBusDevice* pParent, VBus* pBus, ULONG Unit) :
	VPdo(pParent, pBus, Unit)
{
	t << "VReader::VReader " << m_Unit << EOL;

    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		m_HardwareIDs = new WCHAR[sizeof(VBUS_HARDWARE_READER_IDS)/sizeof(WCHAR)];
		if ( m_HardwareIDs )
		{
			RtlCopyMemory(m_HardwareIDs, VBUS_HARDWARE_READER_IDS, sizeof (VBUS_HARDWARE_READER_IDS));
		}
		else
		{
			m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;
		}
	}
}

////////////////////////////////////////////////////////////////////////
//  VReader::OnQueryInterface
//
//	Routine Description:
//		handler for IRP_MN_QUERY_INTERFACE
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP Irp
//
//	Return Value:
//		status   
//
//	Comments:
//		None
//
NTSTATUS VReader::OnQueryInterface(KIrp I)
{
	t << "VReader::OnQueryInterface " << m_Unit << EOL;

	NTSTATUS status = STATUS_SUCCESS;

	PIO_STACK_LOCATION stack = I.CurrentStackLocation();

	GUID* guid = (GUID*)stack->Parameters.QueryInterface.InterfaceType;
	if ( IsEqualGUID(*guid, GUID_VBUS_READ_INTERFACE) )
	{
		if ( (stack->Parameters.QueryInterface.Size >= sizeof(_VBUS_READ_INTERFACE)) && (stack->Parameters.QueryInterface.Version == 1) )
		{
			_VBUS_READ_INTERFACE* Interface = (_VBUS_READ_INTERFACE*)stack->Parameters.QueryInterface.Interface;

			Interface->Size = sizeof(_VBUS_READ_INTERFACE);
			Interface->Version = 1;
			Interface->Context = this;
			Interface->AddRef = AddRef;
			Interface->Release = Release;
			Interface->Read = Read;

			++m_RefCount;
		}
		else
		{
			status = STATUS_INVALID_PARAMETER;
		}
	}
	else
	{
		status = I.Status();
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VReader::Read
//
//	Routine Description:
//		read interface function
//
//	Parameters:
//		[in] Offset
//			Offset in a buffer
//
//		[out] Buffer
//			data to read
//
//		[in] Size
//			size of the buffer
//
//		[out] pRead
//			number of bytes read
//
//	Return Value:
//		status   
//
//	Comments:
//		None
//
BOOLEAN VReader::Read(ULONG Offset, PVOID Buffer, ULONG Size, PULONG pRead)
{
	t << "VReader::Read\n";

	if ( Offset < sizeof(g_Buffer) )
	{
		ULONG length = Size;

		if ( length > (ULONG)(sizeof(g_Buffer) - Offset) )
			length = (ULONG)(sizeof(g_Buffer) - Offset);

		RtlCopyMemory(Buffer, g_Buffer + Offset, length);

		*pRead = length;
	}
	else
	{
		*pRead = 0;
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//  VWriter::VWriter
//
//	Routine Description:
//		Constructor for VWriter class
//
//	Parameters:
//		[in] pParent
//			pointer to a parent FDO
//
//		[in] pBus
//			pointer to a pdo collection
//
//		[in] Unit
//			id
//
//	Return Value:
//		None   
//
//	Comments:
//		None
//
VWriter::VWriter(VBusDevice* pParent, VBus* pBus, ULONG Unit) :
	VPdo(pParent, pBus, Unit)
{
	t << "VWriter::VWriter " << m_Unit << EOL;

	// Check constructor status
    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		m_HardwareIDs = new WCHAR[sizeof(VBUS_HARDWARE_WRITER_IDS)/sizeof(WCHAR)];
		if ( m_HardwareIDs )
		{
			RtlCopyMemory(m_HardwareIDs, VBUS_HARDWARE_WRITER_IDS, sizeof (VBUS_HARDWARE_WRITER_IDS));
		}
		else
		{
			m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;
		}
	}
}

////////////////////////////////////////////////////////////////////////
//  VWriter::OnQueryInterface
//
//	Routine Description:
//		handler for IRP_MN_QUERY_INTERFACE
//
//	Parameters:
//		[in] I
//			IRP_MJ_PNP Irp
//
//	Return Value:
//		status   
//
//	Comments:
//		None
//
NTSTATUS VWriter::OnQueryInterface(KIrp I)
{
	t << "VWriter::OnQueryInterface " << m_Unit << EOL;

	NTSTATUS status = STATUS_SUCCESS;

	PIO_STACK_LOCATION stack = I.CurrentStackLocation();

	GUID* guid = (GUID*)stack->Parameters.QueryInterface.InterfaceType;
	if ( IsEqualGUID(*guid, GUID_VBUS_WRITE_INTERFACE) )
	{
		if ( (stack->Parameters.QueryInterface.Size >= sizeof(_VBUS_WRITE_INTERFACE)) && (stack->Parameters.QueryInterface.Version == 1) )
		{
			_VBUS_WRITE_INTERFACE* Interface = (_VBUS_WRITE_INTERFACE*)stack->Parameters.QueryInterface.Interface;

			Interface->Size = sizeof(_VBUS_WRITE_INTERFACE);
			Interface->Version = 1;
			Interface->Context = this;
			Interface->AddRef = AddRef;
			Interface->Release = Release;
			Interface->Write = Write;

			++m_RefCount;
		}
		else
		{
			status = STATUS_INVALID_PARAMETER;
		}
	}
	else
	{
		status = I.Status();
	}

	return I.PnpComplete(status);
}

////////////////////////////////////////////////////////////////////////
//  VWriter::Write
//
//	Routine Description:
//		write interface function
//
//	Parameters:
//		[in] Offset
//			Offset in a buffer
//
//		[in] Buffer
//			data to write
//
//		[in] Size
//			size of the buffer
//
//		[out] pWritten
//			number of bytes written
//
//	Return Value:
//		status   
//
//	Comments:
//		None
//
BOOLEAN VWriter::Write(ULONG Offset, PVOID Buffer, ULONG Size, PULONG pWritten)
{
	t << "VWriter::Write\n";

	if ( Offset < sizeof(g_Buffer) )
	{
		ULONG length = Size;

		if ( length > (ULONG)(sizeof(g_Buffer) - Offset) )
			length = (ULONG)(sizeof(g_Buffer) - Offset);

		RtlCopyMemory(g_Buffer + Offset, Buffer, length);

		*pWritten = length;
	}
	else
	{
		*pWritten = 0;
	}

	return TRUE;
}
