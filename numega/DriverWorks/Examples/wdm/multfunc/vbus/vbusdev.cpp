// vbusdev.cpp
// Implementation of VBusDevice device class
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#pragma warning(disable:4065) // Allow switch statement with no cases
		  
#include <vdw.h>
#include <initguid.h>
#include "..\vinterface.h"

#include "vbus.h"
#include "vbusdev.h"
#include "..\vbusioctl.h"

#pragma hdrstop("vbus.pch")

////////////////////////////////////////////////////////////////////////
//  VBusDevice::VBusDevice
//
//	Routine Description:
//		This is the constructor for the Functional Device Object, or FDO.
//		It is derived from KPnpDevice, which builds in automatic
//	    dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP to
//		virtual member functions.
//
//	Parameters:
//		Pdo - Physical Device Object - this is a pointer to a system
//			device object that represents the physical device.
//
//		Unit - Unit number. This is a number to append to the device's
//			base device name to form the Logical Device Object's name
//
//	Return Value:
//		None   
//
//	Comments:
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the FDO to the
//		PDO and creates an interface to the upper edge of the system class driver.
//
VBusDevice::VBusDevice(PDEVICE_OBJECT Pdo) : KPnpDevice(Pdo, &VBUSDEVICE_CLASS_GUID)
{
	t << "VBusDevice::VbusDevice\n";

	// Check constructor status
    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		// Initialize the lower device
		m_Lower.Initialize(this, Pdo);

		// Inform the base class of the lower edge device object
		SetLowerDevice(&m_Lower);

		// Initialize the PnP Policy settings to the "standard" policy
		SetPnpPolicy();

		// Initialize the Power Policy settings to the "standard" policy
		SetPowerPolicy(TRUE);

		// we will send IRP_MN_WAIT_WAKE only in response to IRP_MN_WAIT_WAKE
		// from children device stack
		m_PowerPolicies.m_WaitWakePolicy.m_SendDeviceSleep = FALSE;
		m_PowerPolicies.m_WaitWakePolicy.m_SendSystemSleep = FALSE;
		
		// inform the bus about its parent
		m_Bus.SetParent(this);
	}
}


////////////////////////////////////////////////////////////////////////
//  VBusDevice::~VBusDevice
//
//	Routine Description:
//		This is the destructor for the Functional Device Object, or FDO.
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VBusDevice::~VBusDevice()
{
	t << "VBusDevice::~VBusDevice()\n";
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::DefaultPnp
//
//	Routine Description:
//		Default handler for IRP_MJ_PNP
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_PNP. IRPs that correspond to
//		any virtual members of KpnpDevice that handle minor functions of
//		IRP_MJ_PNP and that are not overridden get passed to this routine.
//

NTSTATUS VBusDevice::DefaultPnp(KIrp I) 
{
	t << "VBusDevice::DefaultPnp " << I;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}


////////////////////////////////////////////////////////////////////////
//  VBusDevice::DefaultPower
//
//	Routine Description:
//		Default handler for IRP_MJ_POWER 
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_POWER.
//

NTSTATUS VBusDevice::DefaultPower(KIrp I) 
{
	t << "VBusDevice::DefaultPower\n";

	I.IndicatePowerIrpProcessed();
	I.CopyParametersDown();
	return m_Lower.PnpPowerCall(this, I);
}

////////////////////////////////////////////////////////////////////////////////
//  VBusDevice::SystemControl
//
//	Routine Description:
//		Default handler for IRP_MJ_SYSTEM_CONTROL
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the next device since this driver
//		is not a WMI provider.
//

NTSTATUS VBusDevice::SystemControl(KIrp I) 
{
	t << "VBusDevice::SystemControl\n";

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::OnStartDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		Initialize the physical device. Typically, the driver initializes
//		physical resources here.  Call I.AllocatedResources() for a list
//		of the raw resources that the system has assigned to the device,
//		or I.TranslatedResources() for the translated resource list.
//
NTSTATUS VBusDevice::OnStartDevice(KIrp I)
{
	t << "VBusDevice::OnStartDevice\n";

	NTSTATUS status = STATUS_SUCCESS;

	I.Information() = 0;

	// we will create the VWriter device here.
	if ( !m_Bus.IdUsed(0) )
	{
		VWriter* pDevice = new (
			NULL,
			FILE_DEVICE_BUS_EXTENDER,
			NULL,
			FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
			DO_BUFFERED_IO | DO_POWER_PAGABLE
			)
		VWriter(this, &m_Bus, 0);

		if ( pDevice )
		{
			status = pDevice->ConstructorStatus();

			if ( NT_SUCCESS(status) )
			{
				m_Bus.AddChild(pDevice);
				((PDEVICE_OBJECT)*pDevice)->Flags &= ~DO_DEVICE_INITIALIZING;
				IoInvalidateDeviceRelations(m_Lower.PDO(), BusRelations);
			}
			else
			{
				delete pDevice;
			}
		}
		else
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
		}
	}

	return status;
}


////////////////////////////////////////////////////////////////////////
//  VBusDevice::OnStopDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is stopped.
//		The driver should release any hardware resources
//		in this routine.
//
//		The base class passes the irp to the lower device.
//

NTSTATUS VBusDevice::OnStopDevice(KIrp I)
{
	t << "Entering VBusDevice::OnStopDevice\n";

	NTSTATUS status = STATUS_SUCCESS;

	return status;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::OnRemoveDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//
NTSTATUS VBusDevice::OnRemoveDevice(KIrp I)
{
	t << "Entering VBusDevice::OnRemoveDevice\n";

	// make sure that all children objects are deleted
	m_Bus.RemoveChildren();

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::OnSurpriseRemoval
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//

NTSTATUS VBusDevice::OnSurpriseRemoval(KIrp I)
{
	t << "Entering VBusDevice::OnSurpriseRemoval\n";

	// allow children objects to be deleted in IRP_MN_REMOVE_DEVICE handler
	m_Bus.RemoveParent();

	return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::OnRemoveDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//

NTSTATUS VBusDevice::OnQueryDeviceRelations(KIrp I)
{
	t << "Entering VBusDevice::OnQueryDeviceRelations\n";

	NTSTATUS status = m_Bus.QueryDeviceRelations(I);
	if ( NT_SUCCESS(status) )
	{
		return m_Lower.PnpCall(this, I);
	}
	else
	{
		return I.PnpComplete(status);
	}
}


////////////////////////////////////////////////////////////////////////
//  VBusDevice::OnDevicePowerUp
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to power on state from low power state
//
//	Parameters:
//		I - IRP containing POWER request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the OnDevicePowerUp function.
//		This function was called by the framework from the completion
//		routine of the IRP_MJ_POWER dispatch handler in KPnpDevice.
//		The bus driver has completed the IRP and this driver can now
//		access the hardware device.  
//		This routine runs at dispatch level.
//	
NTSTATUS VBusDevice::OnDevicePowerUp(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VBusDevice::OnDevicePowerUp " << I;

	// inform the bus object about parent power state changes
	m_Bus.SetPowerState(I.PowerStateSetting().DeviceState);

	return status;
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::OnDeviceSleep
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to a low power state from a high power state
//
//	Parameters:
//		I - IRP containing POWER request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the OnDeviceSleep function.
//		This function was called by the framework from the IRP_MJ_POWER 
//		dispatch handler in KPnpDevice prior to forwarding to the PDO.
//		The hardware has yet to be powered down and this driver can now
//		access the hardware device.  
//		This routine runs at passive level.
//	
NTSTATUS VBusDevice::OnDeviceSleep(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VBusDevice::OnDeviceSleep " << I;

	// inform the bus object about parent power state changes
	m_Bus.SetPowerState(I.PowerStateSetting().DeviceState);

	return status;
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::DetermineNewDevicePowerState
//
//	Routine Description:
//		Calculates the lowest possible device power state
//
//	Parameters:
//		[in] SystemPowerState
//			New system power state
//
//	Return Value:
//		DEVICE_POWER_STATE - new device power state
//
//	Comments:
//		This routine finds the highest device power state among
//		its children and returns the new device power state which is at least
//		as high as that state.
//	
DEVICE_POWER_STATE VBusDevice::DetermineNewDevicePowerState(SYSTEM_POWER_STATE SystemPowerState)
{
	DEVICE_POWER_STATE DevicePowerState = KPnpDevice::DetermineNewDevicePowerState(SystemPowerState);
	DEVICE_POWER_STATE ChildrenPowerState = m_Bus.HighestChildrenPowerState();

	if ( DevicePowerState > ChildrenPowerState )
		DevicePowerState = ChildrenPowerState;

	return DevicePowerState;
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::Create
//
//	Routine Description:
//		Handler for IRP_MJ_CREATE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS VBusDevice::Create(KIrp I)
{
	t << "Entering VBusDevice::Create " << I << EOL;

	return I.PnpComplete(this, STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////
//  VBusDevice::Close
//
//	Routine Description:
//		Handler for IRP_MJ_CLOSE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS VBusDevice::Close(KIrp I)
{
	t << "Entering VBusDevice::Close " << I << EOL;

	return I.PnpComplete(this, STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::DeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_DEVICE_CONTROL
//
//	Parameters:
//		I - Current IRP
// 
//	Return Value:
//		None
//
//	Comments:
//		This routine is the first handler for Device Control requests.
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.
//

NTSTATUS VBusDevice::DeviceControl(KIrp I) 
{
	NTSTATUS status;

	t << "Entering VBusDevice::Device Control " << I << EOL;
	switch ( I.IoctlCode() )
	{
		case VBUS_IOCTL_ADD_DEVICE:
			status = VBUS_IOCTL_ADD_DEVICE_Handler(I);
			break;

		case VBUS_IOCTL_DELETE_DEVICE:
			status = VBUS_IOCTL_DELETE_DEVICE_Handler(I);
			break;

		default:
			// Unrecognized IOCTL request
			status = STATUS_INVALID_PARAMETER;
			break;
	}

	return I.PnpComplete(this, status);
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::VBUS_IOCTL_ADD_DEVICE_Handler
//
//	Routine Description:
//		Handler for IO Control Code VBUS_IOCTL_ADD_DEVICE
//
//	Parameters:
//		I - IRP containing IOCTL request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the VBUS_IOCTL_ADD_DEVICE function.
//		This routine runs at passive level.
//

NTSTATUS VBusDevice::VBUS_IOCTL_ADD_DEVICE_Handler(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VBusDevice::VBUS_IOCTL_ADD_DEVICE_Handler, " << I;
	I.Information() = 0;

	if ( I.IoctlInputBufferSize() == sizeof(ULONG) )
	{
		PULONG p = (PULONG)I.IoctlBuffer();

		if ( m_Bus.IdUsed(*p) )
			return STATUS_INVALID_PARAMETER;

		VReader* pDevice = new (
			NULL,
			FILE_DEVICE_BUS_EXTENDER,
			NULL,
			FILE_AUTOGENERATED_DEVICE_NAME | FILE_DEVICE_SECURE_OPEN,
			DO_BUFFERED_IO | DO_POWER_PAGABLE
			)
		VReader(this, &m_Bus, *p);

		if ( pDevice )
		{
			status = pDevice->ConstructorStatus();

			if ( NT_SUCCESS(status) )
			{
				m_Bus.AddChild(pDevice);
				((PDEVICE_OBJECT)*pDevice)->Flags &= ~DO_DEVICE_INITIALIZING;
				IoInvalidateDeviceRelations(m_Lower.PDO(), BusRelations);
			}
			else
			{
				delete pDevice;
			}
		}
		else
		{
			status = STATUS_INSUFFICIENT_RESOURCES;
		}
	}
	else
	{
		status = STATUS_INVALID_PARAMETER;
	}


	return status;
}

////////////////////////////////////////////////////////////////////////
//  VBusDevice::VBUS_IOCTL_DELETE_DEVICE_Handler
//
//	Routine Description:
//		Handler for IO Control Code VBUS_IOCTL_DELETE_DEVICE
//
//	Parameters:
//		I - IRP containing IOCTL request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		This routine implements the VBUS_IOCTL_DELETE_DEVICE function.
//		This routine runs at passive level.
//

NTSTATUS VBusDevice::VBUS_IOCTL_DELETE_DEVICE_Handler(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VBusDevice::VBUS_IOCTL_DELETE_DEVICE_Handler, " << I;
	I.Information() = 0;

	if ( I.IoctlInputBufferSize() == sizeof(ULONG) )
	{
		PULONG p = (PULONG)I.IoctlBuffer();

		if ( m_Bus.RemoveChild(*p) )
		{
			IoInvalidateDeviceRelations(m_Lower.PDO(), BusRelations);
		}
		else
		{
			status = STATUS_INVALID_PARAMETER;
		}
	}
	else
	{
		status = STATUS_INVALID_PARAMETER;
	}

	return status;
}

//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
//  VBus::IdUsed
//
//	Routine Description:
//		determines if id is unique
//
//	Parameters:
//		[in] id
//			id to check
//
//	Return Value:
//		true if found
//
//	Comments:
//		None
//
bool VBus::IdUsed(ULONG id)
{
	t << "VBus::IdUsed\n";

	bool bFound = false;

	m_Lock.Acquire();

	VPdo* pDevice = (VPdo*)m_Children.HeadNoLock();
	while ( pDevice )
	{
		if ( pDevice->m_Unit == id )
		{
			bFound = true;
			break;
		}
		else
			pDevice = (VPdo*)m_Children.NextNoLock(pDevice);
	}

	m_Lock.Release();

	return bFound;
}

////////////////////////////////////////////////////////////////////////
//  VBus::RemoveChild
//
//	Routine Description:
//		mark child as not present, but keep it in a collection
//
//	Parameters:
//		[in] id
//			id of a child
//
//	Return Value:
//		true if found
//
//	Comments:
//		None
//
bool VBus::RemoveChild(ULONG id)
{
	t << "VBus::RemoveChild\n";

	m_Lock.Acquire();

	if ( m_NumberOfChildren == 0 )
	{
		m_Lock.Release();
		return false;
	}

	bool bFound = false;

	VPdo* pDevice = (VPdo*)m_Children.HeadNoLock();
	while ( pDevice )
	{
		if ( pDevice->m_Unit == id )
		{
			bFound = true;
			pDevice->Removed();
			break;
		}
		else
			pDevice = (VPdo*)m_Children.NextNoLock(pDevice);
	}

	m_Lock.Release();

	return bFound;
}



