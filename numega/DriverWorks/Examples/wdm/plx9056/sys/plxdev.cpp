// plxdev.cpp
// Implementation of PlxDevice device class
//
// Generated by DriverWizard version DriverStudio 2.7.0 (Build 554)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>
#include <initguid.h>
#include "..\plxintf.h"

#include "plxdrv.h"
#include "plxdev.h"

////////////////////////////////////////////////////////////////////////
//  PlxDevice::StartIo
//
//	Routine Description:
//		Irp processing routine
//
//	Parameters:
//		[in] I
//			Irp to process
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID PlxQueue::StartIo(KIrp I)
{
	PlxDevice* pDevice = (PlxDevice*)KDevicePTR(I.DeviceObject());

	pDevice->StartReadWrite(I);
}


////////////////////////////////////////////////////////////////////////
//  PlxDevice::PlxDevice
//
//	Routine Description:
//		This is the constructor for the Functional Device Object, or FDO.
//		It is derived from KPnpDevice, which builds in automatic
//	    dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP to
//		virtual member functions.
//
//	Parameters:
//		[in] Pdo
//			Physical Device Object - this is a pointer to a system
//			device object that represents the physical device.
//
//	Return Value:
//		None
//
//	Comments:
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the FDO to the
//		PDO and creates an interface to the upper edge of the system class driver.
//
PlxDevice::PlxDevice(PDEVICE_OBJECT Pdo) :
	KPnpDevice(Pdo, &PLXDEVICE_CLASS_GUID),
	m_ReadQueue(),
	m_WriteQueue(),
	m_pDummyDevice(NULL)
{
	t << "PlxDevice::PlxDevice\n";

	m_ReadMode = ModeSGDma;
//	m_ReadMode = ModeBlockDma;
//	m_WriteMode = ModeDirectSlave;
	m_WriteMode = ModeSGDma;

    if ( NT_SUCCESS(m_ConstructorStatus) )
	{
		// Initialize the lower device
		m_Lower.Initialize(this, Pdo);

		// Inform the base class of the lower edge device object
		SetLowerDevice(&m_Lower);

		// Initialize the PnP Policy settings to the "standard" policy
		SetPnpPolicy();

		// Initialize the Power Policy settings to the "standard" policy
		SetPowerPolicy();

		// Initialize DPC for ISR
		m_DPC.Setup(LinkTo(DpcForIsr), this);

		// Initialize driver managed queue
		m_ReadQueue.Initialize(*this);
		m_WriteQueue.Initialize(*this);

		// Create dummy device object so we can request read and write
		// dma adapter channel requests at the same time
		m_pDummyDevice = new (NonPagedPool) KDevice(NULL, FILE_DEVICE_UNKNOWN, NULL, 0, DO_DIRECT_IO);
		if ( m_pDummyDevice )
			m_ConstructorStatus = m_pDummyDevice->ConstructorStatus();
		else
			m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;
	}
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::~PlxDevice
//
//	Routine Description:
//		This is the destructor for the Functional Device Object, or FDO.
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
PlxDevice::~PlxDevice()
{
	t << "PlxDevice::~PlxDevice()\n";

	if ( m_pDummyDevice )
		delete m_pDummyDevice;
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::DefaultPnp
//
//	Routine Description:
//		Default handler for IRP_MJ_PNP
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is
//		the default handler for IRP_MJ_PNP. IRPs that correspond to
//		any virtual members of KPnpDevice that handle minor functions of
//		IRP_MJ_PNP and that are not overridden get passed to this routine.
//
NTSTATUS PlxDevice::DefaultPnp(KIrp I)
{
	t << "PlxDevice::DefaultPnp " << I;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::DefaultPower
//
//	Routine Description:
//		Default handler for IRP_MJ_POWER
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the lower device. It is
//		the default handler for IRP_MJ_POWER.
//
NTSTATUS PlxDevice::DefaultPower(KIrp I)
{
	t << "PlxDevice::DefaultPower " << I;

	I.IndicatePowerIrpProcessed();
	I.CopyParametersDown();
	return m_Lower.PnpPowerCall(this, I);
}

////////////////////////////////////////////////////////////////////////////////
//  PlxDevice::SystemControl
//
//	Routine Description:
//		Default handler for IRP_MJ_SYSTEM_CONTROL
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result returned from lower device
//
//	Comments:
//		This routine just passes the IRP through to the next device since this driver
//		is not a WMI provider.
//
NTSTATUS PlxDevice::SystemControl(KIrp I)
{
	t << "PlxDevice::SystemControl\n";

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::OnStartDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE
//
//	Parameters:
//		[in] I
//		Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		Initialize the physical device.
//
NTSTATUS PlxDevice::OnStartDevice(KIrp I)
{
	t << "PlxDevice::OnStartDevice\n";

	I.Information() = 0;

	PCM_RESOURCE_LIST pResListRaw = I.AllocatedResources();
	PCM_RESOURCE_LIST pResListTranslated = I.TranslatedResources();

	NTSTATUS status;

	do
	{
		// initialize PLX9056 helper class.
		status = m_plx.Initialize(m_Lower.TopOfStack(), pResListTranslated, pResListRaw, LinkTo(Isr), this);
		if ( !NT_SUCCESS(status) )
		{
			t << "Plx chip initialization failed. Status: " << status << EOL;
			break;
		}

		// Initialize DMA resources.
		DEVICE_DESCRIPTION dd;

		RtlZeroMemory(&dd, sizeof(DEVICE_DESCRIPTION));

		dd.Version			= DEVICE_DESCRIPTION_VERSION;
		dd.Master			= TRUE;
		dd.ScatterGather	= TRUE;
		dd.DemandMode		= FALSE;
		dd.AutoInitialize 	= FALSE;
		dd.Dma32BitAddresses= TRUE;
		dd.IgnoreCount 		= FALSE;
		dd.Dma64BitAddresses= FALSE;
		dd.DmaChannel		= 0;
		dd.InterfaceType	= PCIBus;
		dd.DmaWidth 		= Width32Bits;
		dd.DmaSpeed			= Compatible;
		dd.MaximumLength	= MAX_SG*PAGE_SIZE;
		dd.DmaPort			= 0;

		// Initialize Read Dma Adapter
		if ( !m_ReadAdapter.Initialize(&dd, m_Lower.PDO()) )
			break;

		if ( m_ReadMode == ModeSGDma )
		{
			// Initialize Read Common Buffer for scatter-gather descriptors.
			m_ReadBuffer.Initialize(&m_ReadAdapter, MAX_SG*sizeof(PLX9056_DESCRIPTOR));
			if ( !m_ReadBuffer.IsValid() )
				break;

			RtlZeroMemory(m_ReadBuffer.VirtualAddress(), m_ReadBuffer.Size());
		}

		// Initialize Write Dma Adapter
		if ( !m_WriteAdapter.Initialize(&dd, m_Lower.PDO()) )
			break;

		if ( m_WriteMode == ModeSGDma )
		{
			// Initialize Write Common Buffer for scatter-gather descriptors.
			m_WriteBuffer.Initialize(&m_WriteAdapter, MAX_SG*sizeof(PLX9056_DESCRIPTOR));
			if ( !m_WriteBuffer.IsValid() )
				break;

			RtlZeroMemory(m_WriteBuffer.VirtualAddress(), m_WriteBuffer.Size());
		}

		// Reset PLX Chip, so it is in a known state.
		m_plx.Reset();
		m_bAccess = true;

		// Dump EEPROM.
		for (ULONG i = 0; i < 86; i += 2)
		{
			t << i << "  " << m_plx.EepromRead(i) << EOL;
		}

		// Enable Interrupts we are interrested in.
		m_plx.m_MemConfig[PLX9056_INTCSR] = PLX9056_INTCSR_DIE | PLX9056_INTCSR_AIE | PLX9056_INTCSR_LIIE | PLX9056_INTCSR_DMA0IE | PLX9056_INTCSR_DMA1IE;
		m_plx.EnableInterrupts();

	} while ( false );

	if ( !NT_SUCCESS(status) )
	{
		FreeResources();

		t << "PlxDevice::OnStartDevice Failed. Status = " << status << EOL;
	}

	return status;
}


////////////////////////////////////////////////////////////////////////
//  PlxDevice::OnStopDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		The system calls this when the device is stopped.
//		The driver should release any hardware resources
//		in this routine.
//
//		The base class passes the irp to the lower device.
//
NTSTATUS PlxDevice::OnStopDevice(KIrp I)
{
	t << "PlxDevice::OnStopDevice\n";

	// queues should be empty by now, but just in case.
	m_ReadQueue.CleanUp(NULL);
	m_WriteQueue.CleanUp(NULL);

	FreeResources();

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::OnSurpriseRemoval
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_SURPRISE_REMOVAL
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		None
//
NTSTATUS PlxDevice::OnSurpriseRemoval(KIrp I)
{
	t << "PlxDevice::OnSurpriseRemoval\n";

	m_bAccess = false;

	m_ReadQueue.CleanUp(NULL);
	m_WriteQueue.CleanUp(NULL);

	FreeResources();

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::OnRemoveDevice
//
//	Routine Description:
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		The system calls this when the device is removed.
//		Our PnP policy will take care of
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object
//
NTSTATUS PlxDevice::OnRemoveDevice(KIrp I)
{
	t << "PlxDevice::OnRemoveDevice\n";

	// queues should be empty by now, but just in case.
	m_ReadQueue.CleanUp(NULL);
	m_WriteQueue.CleanUp(NULL);

	FreeResources();

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::OnDevicePowerUp
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to power on state from low power state
//
//	Parameters:
//		[in] I
//			IRP containing POWER request
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		This routine implements the OnDevicePowerUp function.
//		This function was called by the framework from the completion
//		routine of the IRP_MJ_POWER dispatch handler in KPnpDevice.
//		The bus driver has completed the IRP and this driver can now
//		access the hardware device.
//		This routine runs at dispatch level.
//
NTSTATUS PlxDevice::OnDevicePowerUp(KIrp I)
{
	t << "PlxDevice::OnDevicePowerUp\n";

	m_plx.Reset();
	m_bAccess = true;

	// Enable Interrupts we are interrested in.
	m_plx.m_MemConfig[PLX9056_INTCSR] = PLX9056_INTCSR_DIE | PLX9056_INTCSR_AIE | PLX9056_INTCSR_LIIE | PLX9056_INTCSR_DMA0IE | PLX9056_INTCSR_DMA1IE;
	m_plx.EnableInterrupts();

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::OnDeviceSleep
//
//	Routine Description:
//		Handler for IRP_MJ_POWER with minor function IRP_MN_SET_POWER
//		for a request to go to a low power state from a high power state
//
//	Parameters:
//		[in] I
//			IRP containing POWER request
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		This routine implements the OnDeviceSleep function.
//		This function was called by the framework from the IRP_MJ_POWER
//		dispatch handler in KPnpDevice prior to forwarding to the PDO.
//		The hardware has yet to be powered down and this driver can now
//		access the hardware device.
//		This routine runs at passive level.
//
NTSTATUS PlxDevice::OnDeviceSleep(KIrp I)
{
	t << "PlxDevice::OnDeviceSleep\n";

	m_plx.DisableInterrupts();
	m_plx.Reset();
	m_bAccess = false;

	return STATUS_SUCCESS;
	UNREFERENCED_PARAMETER(I);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::Create
//
//	Routine Description:
//		Handler for IRP_MJ_CREATE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		None
//
NTSTATUS PlxDevice::Create(KIrp I)
{
	t << "PlxDevice::Create\n";

	return I.PnpComplete(this, STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::Close
//
//	Routine Description:
//		Handler for IRP_MJ_CLOSE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//		None
//
NTSTATUS PlxDevice::Close(KIrp I)
{
	t << "PlxDevice::Close\n";

	return I.PnpComplete(this, STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::Cleanup
//
//	Routine Description:
//		Handler for IRP_MJ_CLEANUP
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		STATUS_SUCCESS
//
//	Comments:
//
NTSTATUS PlxDevice::CleanUp(KIrp I)
{
	t << "PlxDevice::CleanUp\n";

	m_ReadQueue.CleanUp(I.FileObject());
	m_WriteQueue.CleanUp(I.FileObject());

	return I.PnpComplete(this, STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////
//  PlxDevice::Read
//
//	Routine Description:
//		Handler for IRP_MJ_READ
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		status
//
//	Comments:
//		This routine handles read requests.
//
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.
//
NTSTATUS PlxDevice::Read(KIrp I)
{
	t << "PlxDevice::Read\n";

	NTSTATUS status;

	if ( m_ReadMode == ModeDirectSlave )
	{
		ULONG nRead = I.ReadSize();

		if ( nRead )
		{
			KMemory Mdl = I.Mdl();

			status = m_plx.BusIopRead(0, 0, true, Mdl.MapToSystemSpace(), nRead, Plx9056BitSize32);
			if ( !NT_SUCCESS(status) )
			{
				nRead = 0;
			}
		}
		else
			status = STATUS_SUCCESS;

		I.Information() = nRead;
		I.PnpComplete(this, status);
	}
	else
		status = m_ReadQueue.QueueIrp(I);

	return status;
}


////////////////////////////////////////////////////////////////////////
//  PlxDevice::Write
//
//	Routine Description:
//		Handler for IRP_MJ_WRITE
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		This routine handles write requests.
//
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.
//
NTSTATUS PlxDevice::Write(KIrp I)
{
	t << "PlxDevice::Write\n";

	NTSTATUS status;

	if ( m_WriteMode == ModeDirectSlave )
	{
		ULONG nWritten = I.WriteSize();

		if ( nWritten )
		{
			KMemory Mdl = I.Mdl();

			status = m_plx.BusIopWrite(0, 0, true, Mdl.MapToSystemSpace(), nWritten, Plx9056BitSize32);
			if ( !NT_SUCCESS(status) )
			{
				nWritten = 0;
			}
		}
		else
			status = STATUS_SUCCESS;

		I.Information() = nWritten;
		I.PnpComplete(this, status);
	}
	else
		status = m_WriteQueue.QueueIrp(I);

	return status;
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::DeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_DEVICE_CONTROL
//
//	Parameters:
//		[in] I
//			Current IRP
//
//	Return Value:
//		Status
//
//	Comments:
//		This routine is the first handler for Device Control requests.
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.
//
NTSTATUS PlxDevice::DeviceControl(KIrp I)
{
	NTSTATUS status;

	t << "PlxDevice::DeviceControl\n";

	switch ( I.IoctlCode() )
	{
	case PLX9056_IOCTL_READ_MAILBOX:
		status = ReadMailbox(I);
		break;

	case PLX9056_IOCTL_WRITE_MAILBOX:
		status = WriteMailbox(I);
		break;

	default:
		status = STATUS_INVALID_PARAMETER;
		break;
	}

	return I.PnpComplete(this, status);
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::Isr
//
//	Routine Description:
//		Interrupt Service Routine
//
//	Parameters:
//		None
//
//	Return Value:
//		TRUE, if it is our interrupt
//
//	Comments:
//		None
//
BOOLEAN PlxDevice::Isr(void)
{
	t << "PlxDevice::Isr\n";

	// check if device is up
	if ( !m_bAccess )
		return FALSE;

	PLX9056_ISR_REASON Reason = m_plx.GetIsrReason();

	if ( Reason != Plx9056ReasonNone )
	{
		m_plx.DisableInterrupts(true);
		m_DPC.Request((PVOID)(ULONG_PTR)Reason, NULL);

		return TRUE;
	}
	else
		return FALSE;
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::DpcForIsr
//
//	Routine Description:
//		DPC for ISR
//
//	Parameters:
//		[in] Arg1
//			Reason of Interrupt
//
//		[in] Arg2
//			unused
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
VOID PlxDevice::DpcForIsr(PVOID Arg1, PVOID Arg2)
{
	PLX9056_ISR_REASON Reason = (PLX9056_ISR_REASON)(ULONG_PTR)Arg1;

	t << "PlxDevice::DpcForIsr\n";

	m_plx.ClearIsrReason(Reason);

	if ( Reason & Plx9056ReasonDma0 )
		m_ReadTransfer.Continue(UseTransferSize);

	if ( Reason & Plx9056ReasonDma1 )
		m_WriteTransfer.Continue(UseTransferSize);

	m_plx.EnableInterrupts();
}


////////////////////////////////////////////////////////////////////////
//  PlxDevice::StartReadWrite
//
//	Routine Description:
//		Irp processing routine
//
//	Parameters:
//		[in] I
//			Irp to process
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
inline VOID PlxDevice::StartReadWrite(KIrp I)
{
	t << "PlxDevice::StartReadWrite\n";

	if ( I.MajorFunction() == IRP_MJ_READ )
	{
		m_ReadTransfer.Initiate(this, &m_ReadAdapter, I.Mdl(), FromDeviceToMemory, LinkTo(OnDmaReady), NULL, this);
	}
	else
	{
		// use dummy device object to queue dma adapter channel request.
		m_WriteTransfer.Initiate(m_pDummyDevice, &m_WriteAdapter, I.Mdl(), FromMemoryToDevice, LinkTo(OnDmaReady), NULL, this);
	}

	return;
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::OnDmaReady
//
//	Routine Description:
//		This routine is called when adapter channel is allocated
//
//	Parameters:
//		[in] pTransfer
//			pointer to KDmaTransfer class
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void PlxDevice::OnDmaReady(KDmaTransfer* pTransfer)
{
	t << "PlxDevice::OnDmaReady\n";

	ULONG							channel;
	PLX9056_MODE					mode;
	bool							bRead;
	PlxQueue*						queue;
	KCommonDmaBuffer*				buffer;
	NTSTATUS						status = STATUS_INSUFFICIENT_RESOURCES;
	ULONG							information = 0;
	bool							bTerminate = false;

	// check if it is read or write
	if ( pTransfer->Direction() == FromDeviceToMemory )
	{
		channel = 0;
		mode = m_ReadMode;
		bRead = true;
		queue = &m_ReadQueue;
		buffer = &m_ReadBuffer;
	}
	else
	{
		channel = 1;
		mode = m_WriteMode;
		bRead = false;
		queue = &m_WriteQueue;
		buffer = &m_WriteBuffer;
	}

	KIrp I = queue->CurrentIrp();

	if ( pTransfer->BytesRemaining() != 0 )
	{
		// initialize dma transfer

		PTRANSFER_DESCRIPTOR pTd;

		if ( mode == ModeBlockDma )
		{
			if ( pTransfer->SequenceTransferDescriptors(&pTd) )
			{
				m_plx.Lock(TRUE);
				m_plx.SetBlockedDma(channel, pTd->td_PhysAddr, 0, pTd->td_Length, bRead);
				m_plx.StartDma(channel);
				m_plx.Unlock();
			}
			else
				bTerminate = true;
		}
		else
		{
			PPLX9056_DESCRIPTOR pDesc = (PPLX9056_DESCRIPTOR)buffer->VirtualAddress();
			ULONG Offset = 0;

			TRANSFER_DESCRIPTOR FirstTd;
			TRANSFER_DESCRIPTOR LastTd;

			for (ULONG i = 0; i < MAX_SG; i++)
			{
				if ( pTransfer->SequenceTransferDescriptors(&pTd) )
				{
					if ( i == 0 )
					{
						// we have only one fragment so far, so we do not know yet if we want to use blocked mode
						// or scatter-gather mode
						FirstTd = *pTd;
					}
					else if ( i == 1 )
					{
						// we have more than one fragment, so let's use scatter-gather mode
						m_plx.Lock(TRUE);
						m_plx.SetSgDma(channel, FirstTd.td_PhysAddr, 0, FirstTd.td_Length, bRead, true, buffer->LogicalAddress().LowPart);
						m_plx.Unlock();

						Offset += FirstTd.td_Length;
					}
					else
					{
						// program scatter-gather descriptor
						m_plx.SetSgDesc(pDesc, LastTd.td_PhysAddr, Offset, LastTd.td_Length, bRead, true, false, buffer->LogicalAddress().LowPart + (i - 1)*sizeof(PLX9056_DESCRIPTOR));
						Offset += LastTd.td_Length;

						pDesc++;
					}

					LastTd = *pTd;
				}
				else
				{
					if ( i > 1 )
					{
						// program scatter-gather descriptor and mark it as the last one
						m_plx.SetSgDesc(pDesc, LastTd.td_PhysAddr, Offset, LastTd.td_Length, bRead, true, true, 0);
						m_plx.Lock(TRUE);
						m_plx.StartDma(channel);
						m_plx.Unlock();
					}
					else if ( i == 1 ) // there is only one element, so let's use blocked mode
					{
						m_plx.Lock(TRUE);
						m_plx.SetBlockedDma(channel, FirstTd.td_PhysAddr, 0, FirstTd.td_Length, bRead);
						m_plx.StartDma(channel);
						m_plx.Unlock();
					}
					else
						bTerminate = true;

					break;
				}
			}
		}
	}
	else
	{
		bTerminate = true;
		information = I.ReadSize();
		status = STATUS_SUCCESS;
	}

	if ( bTerminate )
	{
		pTransfer->Terminate();
		I.Information() = information;
		I.Status() = status;
		queue->PnpNextIrp(I);
	}

	return;
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::ReadMailbox
//
//	Routine Description:
//		Reads Mailbox register
//
//	Parameters:
//		[in] I
//			Ioctl Irp
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS PlxDevice::ReadMailbox(KIrp I)
{
	NTSTATUS status = STATUS_INVALID_PARAMETER;
	I.Information() = 0;

	t << "PlxDevice::ReadMailbox\n";

	if ( (I.IoctlInputBufferSize() == sizeof(ULONG)) && (I.IoctlOutputBufferSize() == sizeof(ULONG)) )
	{
		PULONG p = (PULONG)I.IoctlBuffer();

		if ( *p < 8 )
		{
			ULONG reg;

			switch ( *p )
			{
			case 0:	reg = PLX9056_MBOX0;	break;
			case 1:	reg = PLX9056_MBOX1;	break;
			case 2:	reg = PLX9056_MBOX2;	break;
			case 3:	reg = PLX9056_MBOX3;	break;
			case 4:	reg = PLX9056_MBOX4;	break;
			case 5:	reg = PLX9056_MBOX5;	break;
			case 6:	reg = PLX9056_MBOX6;	break;
			case 7:	reg = PLX9056_MBOX7;	break;
			}

			m_plx.Lock();
			*p = m_plx.m_MemConfig[reg];
			m_plx.Unlock();

			I.Information() = sizeof(ULONG);
			status = STATUS_SUCCESS;

			t << "MailBox register value " << *p << EOL;
		}
	}

	return status;
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::WriteMailbox
//
//	Routine Description:
//		Writes Mailbox register
//
//	Parameters:
//		[in] I
//			Ioctl Irp
//
//	Return Value:
//		status
//
//	Comments:
//		None
//
NTSTATUS PlxDevice::WriteMailbox(KIrp I)
{
	NTSTATUS status = STATUS_INVALID_PARAMETER;
	I.Information() = 0;

	t << "PlxDevice::WriteMailbox\n";

	if ( I.IoctlInputBufferSize() == 2*sizeof(ULONG) )
	{
		PULONG p = (PULONG)I.IoctlBuffer();

		if ( p[0] < 8 )
		{
			ULONG reg;

			switch ( p[0] )
			{
			case 0:	reg = PLX9056_MBOX0;	break;
			case 1:	reg = PLX9056_MBOX1;	break;
			case 2:	reg = PLX9056_MBOX2;	break;
			case 3:	reg = PLX9056_MBOX3;	break;
			case 4:	reg = PLX9056_MBOX4;	break;
			case 5:	reg = PLX9056_MBOX5;	break;
			case 6:	reg = PLX9056_MBOX6;	break;
			case 7:	reg = PLX9056_MBOX7;	break;
			}

			m_plx.Lock();
			m_plx.m_MemConfig[reg] = p[1];
			m_plx.Unlock();

			status = STATUS_SUCCESS;
		}
	}

	return status;
}

////////////////////////////////////////////////////////////////////////
//  PlxDevice::FreeResources
//
//	Routine Description:
//		Frees allocated resources
//
//	Parameters:
//		[in] I
//		Current IRP
//
//	Return Value:
//		None
//
//	Comments:
//		None
//
void PlxDevice::FreeResources()
{
	t << "PlxDevice::FreeResources\n";

	if ( m_bAccess )
		m_plx.DisableInterrupts();

	m_bAccess = false;

	m_plx.Invalidate();

	m_ReadBuffer.Invalidate();
	m_ReadAdapter.Invalidate();

	m_WriteBuffer.Invalidate();
	m_WriteAdapter.Invalidate();
}
