// KbfilterDevice.cpp
// Implementation of KbfilterDevice device class
//
// Generated by DriverWizard version DriverStudio 2.0.0 (Build 473)
// Requires Compuware's DriverWorks classes
//

#pragma warning(disable:4065) // Allow switch statement with no cases


#include <vdw.h>
#include <kwdmfltr.cpp>  //WDM filter class

#include "..\\KbfilterDeviceinterface.h"

#include "Kbfilter.h"
#include "KbfilterDevice.h"

#pragma hdrstop("Kbfilter.pch")

extern KTrace t;			// Global driver trace object	

GUID KbfilterDevice_Guid = KbfilterDevice_CLASS_GUID;

////////////////////////////////////////////////////////////////////////
//  KbfilterDevice::KbfilterDevice
//
//	Routine Description:
//		This is the constructor for the Functional Device Object, or FDO.
//		It is derived from KPnpDevice, which builds in automatic
//	    dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP to
//		virtual member functions.
//
//	Parameters:
//		Pdo - Physical Device Object - this is a pointer to a system
//			device object that represents the physical device.
//
//		Unit - Unit number. This is a number to append to the device's
//			base device name to form the Logical Device Object's name
//
//	Return Value:
//		None   
//
//	Comments:
//    For class KWdmFilterDevice, the class needs only to call 
//    AttachFilter.  This creates and attaches a filter device
//    object that will be called by the PassThrough function.

KbfilterDevice::KbfilterDevice(PDEVICE_OBJECT Pdo, ULONG Unit) :
KWdmFilterDevice(Pdo, &KbfilterDevice_Guid)
{
	t << "Entering KbfilterDevice::KbfilterDevice (constructor)\n";
	
	
	// Check constructor status
    if ( ! NT_SUCCESS(m_ConstructorStatus) )
	{
		return;
	}
	
	NTSTATUS status = AttachFilter(Pdo); //Attach the filter
	if(!NT_SUCCESS(status))
	{
		m_ConstructorStatus = status;
		return;
	}
	
	SetFilterPowerPolicy();
	SetFilterPnpPolicy();
}

////////////////////////////////////////////////////////////////////////
//  KbfilterDevice::InternalDeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_INTERNAL_DEVICE_CONTROL
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		In this routine, we hook the keyboard's service callback
//      function by replacing the original function pointer 
//      with ours before passing the IRP down.  
//   
NTSTATUS KbfilterDevice::InternalDeviceControl(KIrp I)
{
	t << "Entering KbfilterDevice::Internal Device Control, " << I << EOL;
	ULONG IoctlCode = I.IoctlCode();
	PCONNECT_DATA theConnectData;
	
	//Hook the callback routine
	if(IoctlCode == IOCTL_INTERNAL_KEYBOARD_CONNECT)
	{	
		if(I.IoctlInputBufferSize() != sizeof(CONNECT_DATA))
			return I.PnpComplete(STATUS_INVALID_PARAMETER);
		theConnectData = (PCONNECT_DATA)I.IoctlType3InputBuffer();
		
		//Save the original service and device object for the
		// callback.
		m_RealClassService = (PMY_SERVICE_CALLBACK)theConnectData->ClassService;
		m_RealDeviceObject = theConnectData->ClassDeviceObject;
		
		//Put in our device object and callback
		theConnectData->ClassDeviceObject = m_pDeviceObject;
		theConnectData->ClassService = LinkTo(KBServiceCallback);
	}
	//Don't allow a disconnect
	else if (IoctlCode == IOCTL_INTERNAL_KEYBOARD_DISCONNECT)
		return I.PnpComplete(STATUS_NOT_IMPLEMENTED);
	
	
	return PassThrough(I, LinkTo(InternalDeviceCompletion), this);
}

NTSTATUS KbfilterDevice::InternalDeviceCompletion(KIrp I)
{
	t << "Completion routine called" << "\n";
	return I.Status();
}
//////////////////////////////////////////////////////////////
//Hooked service callback routine.
//
// Our filter simply prints the scancode read from the keyboard 
//  to a debugger such as SoftICE.
void
KbfilterDevice::KBServiceCallback(
								  PKEYBOARD_INPUT_DATA InputDataStart,
								  PKEYBOARD_INPUT_DATA InputDataEnd,
								  PULONG InputDataConsumed)
{
	if(InputDataStart->Flags & KEY_BREAK)
	{
		char theLetter = ConvertScancodeToLetter(InputDataStart->MakeCode);
		//Print out the scancode
		if(theLetter != ' ')
			t << theLetter << " was pressed" << "\n";
		else
			t << "scancode " << InputDataStart->MakeCode << "\n";
		
	}
	//Call the original service routine
	m_RealClassService(
		m_RealDeviceObject,
		InputDataStart,
		InputDataEnd,
		InputDataConsumed);
}

///////////////////////////////////////////////////////////////////////
char KbfilterDevice::ConvertScancodeToLetter(ULONG scancode)
{
	switch(scancode)
	{
	case 0x10: return 'Q';
	case 0x11: return 'W';
	case 0x12: return 'E';
	case 0x13: return 'R';
	case 0x14: return 'T';
	case 0x15: return 'Y';
	case 0x16: return 'U';
	case 0x17: return 'I';
	case 0x18: return 'O';
	case 0x19: return 'P';
		
	case 0x1E: return 'A';
	case 0x1F: return 'S';
	case 0x20: return 'D';
	case 0x21: return 'F';
	case 0x22: return 'G';
	case 0x23: return 'H';
	case 0x24: return 'J';
	case 0x25: return 'K';
	case 0x26: return 'L';
		
	case 0x2C: return 'Z';
	case 0x2D: return 'X';
	case 0x2E: return 'C';
	case 0x2F: return 'V';
	case 0x30: return 'B';
	case 0x31: return 'N';
	case 0x32: return 'M';
		
	default: return ' ';
	}
	
}

////////////////////////////////////////////////////////////////////////
//  KbfilterDevice::~KbfilterDevice
//
//	Routine Description:
//		This is the destructor for the Functional Device Object, or FDO.
//

KbfilterDevice::~KbfilterDevice()
{
	t << "Entering KbfilterDevice::~KbfilterDevice() (destructor)\n";
}
