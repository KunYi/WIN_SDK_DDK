//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 1998 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================

// VtdWdmDevice.cpp
// Implementation of VtdWdmDevice device class
//
// Generated by Driver::Wizard version 2.0
// Uses Compuware's Driver::Works classes
//
//
// Copyright (c) 1998, Compuware Corporation
//
// This WDM driver is meant to work in conjunction with a VxD driver named
// TstNtkrn, which is in the directory Ntkrn\TstNtkrn.  VtdWdm is very
// simple.  It is simply a buffer that can be written to and read from.
// There are a few Device Ioctl Commands that fill, flush and return the
// number of bytes stored in the buffer.
//
// The steps for testing this VxD/WDM driver pair are as follows.
//		1. Install the VtdWdm device under Windows 98.  This WDM driver is
//			buildable if you have Driver::Works, but is included compiled
//			in a DEBUG version with .nms file (for SoftIce) in case you
//			don't.  Install it using the following procedure:
//
//			A. Open control panel and select Add New Hardware
//			B. Click Next until the Wizard asks if the device is listed and
//				click the radio button "No, the device isn't in the list" and
//				then Next again.
//			C. Click the radio button "No, I want to select the hardware from
//				a list.", then Next.
//			D. Select "Other devices" and click Next
//			E. Click the "Have Disk" button and then browse to the \VtdWdm
//				directory and select the VtdWdm.inf file. Click Ok twice.
//			F. The VToolsD to WDM Test Device is highlighted.  Click Next and
//				then Finish.  The device is now installed.
//			G. When you are done the device can be removed using the Device
//				Manager tab of the System control panel applet, where the
//				device is shown under the "Other devices" tab.  Highlight it
//				and click Remove.  If you want to modify the driver don't forget
//				to remove the vtdwdm.sys file from \windows\system32\drivers,
//				since it won't necessarily be overwritten and replaced if you
//				reinstall using the above procedure.  Also you may want to remove
//				the Compuware Corporation vtdwdm.inf file from \windows\inf\other
//				directory.
//		2. From the TstNtkrn directory, build the TstNtkrn VxD from the
//			command line using "nmake /f TstNtkrn.mak" (VToolsD must be installed
//			and the VTOOLSD environment variable must be set to the path where
//			VToolsD is installed)
//		3. Optionally load the .nms symbol files, using SoftIce(if you use it),
//			for VtdWdm and TstNtkrn and set some breakpoints.
//		4. Open the Debug Monitor program that came with VToolsD, and dynamically
//			load the TstNtkrn VxD using the Load command.  This will automatically
//			run the test and provide debug messages to the Debug Monitor
//			display (and to SoftIce).
//		5. Unload the VxD using Debug Monitor's Unload command.  It can be
//			loaded again to rerun.
//

#pragma warning(disable:4065) // Allow switch statement with no cases
		  
#include <vdw.h>

#include "VtdWdm.h"
#include "VtdWdmDevice.h"
#include "..\VtdWdmioctl.h"
#include "..\VtdWdmtypes.h"

#pragma hdrstop("VtdWdm.pch")

extern KTrace t;			// Global driver trace object	

////////////////////////////////////////////////////////////////////////
// VtdWdmDevice Constructor
//
//		This is the constructor for the Functional Device Object, or FDO.
//		It is derived from KPnpDevice, which builds in automatic
//	    dispatching of subfunctions of IRP_MJ_POWER and IRP_MJ_PNP to
//		virtual member functions.
//
// Input
//		Pdo		Physical Device Object - this is a pointer to a system
//				device object that represents the physical device.
//
//		Unit	Unit number - this is a number to append to the device's
//				base device name to form the Logical Device Object's name
//
// Output
//		None   
//
// Notes   
//		The object being constructed contains a data member (m_Lower) of type
//		KPnpLowerDevice. By initializing it, the driver binds the FDO to the
//		PDO and creates an interface to the upper edge of the system class driver.

VtdWdmDevice::VtdWdmDevice(PDEVICE_OBJECT Pdo, ULONG Unit) :

   KPnpDevice(
	    Pdo,
		KUnitizedName(L"VtdWdmDevice", Unit), 
		FILE_DEVICE_UNKNOWN,
		KUnitizedName(L"VtdWdmDevice", Unit),
		0,
#ifdef VTDWDM_USE_BUFFERED_IO
		DO_BUFFERED_IO
#else // VTDWDM_USE_BUFFERED_IO
		DO_DIRECT_IO
#endif // VTDWDM_USE_BUFFERED_IO
		),
	m_Fifo(VTDWDM_FIFO_LENGTH, NonPagedPool),
	m_TimedCallback()
{
	t << "Entering VtdWdmDevice::VtdWdmDevice (constructor)\n";


	// Check constructor status
    if ( ! NT_SUCCESS(m_ConstructorStatus) )
	{
	    return;
	}

	// Remember our unit number
	m_Unit = Unit;

	// Initialize the lower device
	m_Lower.Initialize(this, Pdo);

    // Inform the base class of the lower edge device object
	SetLowerDevice(&m_Lower);

	// Initialize the PnP Policy settings to the "standard" policy
	SetPnpPolicy();
}


////////////////////////////////////////////////////////////////////////
// VtdWdmDevice Destructor
//
//		This is the destructor for the Functional Device Object, or FDO.
//
// Input
//		None
//
// Output
//		None
//
// Notes
//		None

VtdWdmDevice::~VtdWdmDevice()
{
	t << "Entering VtdWdmDevice::~VtdWdmDevice() (destructor)\n";
}

////////////////////////////////////////////////////////////////////////
// PNPMinorFunctionName
//
//		Return a string describing the Plug and Play minor function	
//
// Input	
//		mn		Minor function code
//
// Output	
//		char *	Ascii name of minor function
//
// Notes	
//		This function is used for tracing the IRPs.  Remove the function,
//		or conditionalize it for debug-only builds, if you want to save
//		space in the driver image.
	
char *PNPMinorFunctionName(ULONG mn)
{
	static char* minors[] = {
		"IRP_MN_START_DEVICE",
		"IRP_MN_QUERY_REMOVE_DEVICE",
		"IRP_MN_REMOVE_DEVICE",
		"IRP_MN_CANCEL_REMOVE_DEVICE",
		"IRP_MN_STOP_DEVICE",
		"IRP_MN_QUERY_STOP_DEVICE",
		"IRP_MN_CANCEL_STOP_DEVICE",
		"IRP_MN_QUERY_DEVICE_RELATIONS",
		"IRP_MN_QUERY_INTERFACE",
		"IRP_MN_QUERY_CAPABILITIES",
		"IRP_MN_QUERY_RESOURCES",
		"IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
		"IRP_MN_QUERY_DEVICE_TEXT",
		"IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
		"IRP_MN_READ_CONFIG",
		"IRP_MN_WRITE_CONFIG",
		"IRP_MN_EJECT",
		"IRP_MN_SET_LOCK",
		"IRP_MN_QUERY_ID",
		"IRP_MN_QUERY_PNP_DEVICE_STATE",
		"IRP_MN_QUERY_BUS_INFORMATION",
		"IRP_MN_DEVICE_USAGE_NOTIFICATION",
		"IRP_MN_SURPRISE_REMOVAL"
	};

	if (mn > IRP_MN_SURPRISE_REMOVAL) 
		return "<unknown minor function>";
	else
		return minors[mn];
}

////////////////////////////////////////////////////////////////////////
// DefaultPnp (member of VtdWdmDevice)
//
//		Default handler for IRP_MJ_PNP
//
// Input
//		I			Current IRP
//
// Output
//		NTSTATUS	Result returned from lower device
//
// Notes   
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_PNP. IRPs that correspond to
//		any virtual members of KpnpDevice that handle minor functions of
//		IRP_MJ_PNP and that are not overridden get passed to this routine.

NTSTATUS VtdWdmDevice::DefaultPnp(KIrp I) 
{
	t << "Entering VtdWdmDevice::DefaultPnp with IRP minor function="
	  << PNPMinorFunctionName(I.MinorFunction()) << EOL;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	return m_Lower.PnpCall(this, I);
}


////////////////////////////////////////////////////////////////////////
// DefaultPower (member of VtdWdmDevice)
//
//		Default handler for IRP_MJ_POWER 
//
// Input
//		I			Current IRP
//
// Output
//		NTSTATUS	Result returned from lower device
//
// Notes
//		This routine just passes the IRP through to the lower device. It is 
//		the default handler for IRP_MJ_POWER.

NTSTATUS VtdWdmDevice::DefaultPower(KIrp I) 
{
	t << "Entering VtdWdmDevice::DefaultPower\n";

	I.IndicatePowerIrpProcessed();
	I.CopyParametersDown();
	return m_Lower.PnpPowerCall(this, I);
}


////////////////////////////////////////////////////////////////////////
// OnStartDevice (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_PNP subfcn IRP_MN_START_DEVICE
//
// Input
//		I			Current IRP
//
// Output
//		NTSTATUS	Result code
//
// Notes
//		Initialize the physical device.  Typically, the driver initializes
//		physical resources here.  Call I.AllocatedResources() for a list
//		of the raw resources that the system has assigned to the device,
//		or I.TranslatedResources() for the translated resource list.

NTSTATUS VtdWdmDevice::OnStartDevice(KIrp I)
{
	t << "Entering VtdWdmDevice::OnStartDevice\n";

   NTSTATUS status = STATUS_SUCCESS;

	I.Information() = 0;

	// The default Pnp policy has already cleared the IRP with the lower device
	// Initialize the physical device object.
	// First get the list of translated resources from the IRP

	PCM_RESOURCE_LIST pResList = I.TranslatedResources();


    // The base class will handle completion
	return status;
}


////////////////////////////////////////////////////////////////////////
// OnStopDevice (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_PNP subfcn IRP_MN_STOP_DEVICE
//
// Input
//		I			Current IRP
//
// Output
//		NTSTATUS	Result code
//
// Notes
//		The system calls this when the device is stopped.
//		The driver should release any hardware resources
//		in this routine.
//
//		The base class passes the irp to the lower device.

NTSTATUS VtdWdmDevice::OnStopDevice(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VtdWdmDevice::OnStopDevice\n";

	return status;
}

////////////////////////////////////////////////////////////////////////
// OnRemoveDevice (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_PNP subfcn IRP_MN_REMOVE_DEVICE
//
// Input
//		I			Current IRP
//
// Output
//		NTSTATUS	Result code
//
// Notes
//		The system calls this when the device is removed.
//		Our PnP policy will take care of 
//			(1) giving the IRP to the lower device
//			(2) detaching the PDO
//			(3) deleting the device object

NTSTATUS VtdWdmDevice::OnRemoveDevice(KIrp I)
{
	t << "Entering VtdWdmDevice::OnRemoveDevice\n";

	return STATUS_SUCCESS;
}


////////////////////////////////////////////////////////////////////////
// Cancel (member of VtdWdmDevice)
//
//		This routine is called when an IRP is cancelled.
//
// Input
//		I			IRP being cancelled
//
// Output	
//		None
//
// Notes	
//

VOID VtdWdmDevice::Cancel(KIrp I)
{
	t << "IRP canceled " << I << EOL;

    I.Information() = 0;
	if ( (PIRP)I == CurrentIrp() )
	{
		CurrentIrp() = NULL;
		CancelSpinLock::Release(I.CancelIrql());
		I.Status() = STATUS_CANCELLED;
		NextIrp(I);
	}
	else
	{
		KDeviceQueue(DeviceQueue()).RemoveSpecificEntry(I);
		CancelSpinLock::Release(I.CancelIrql());
		I.PnpComplete(this, STATUS_CANCELLED);
	}
}

////////////////////////////////////////////////////////////////////////
// StartIo (member of VtdWdmDevice)
//
//		StartIo is called when an IRP is taken off the device queue
//		used by the	system for serializing I/O.  StartIo is called at
//		dispatch level.
//
// Input
//		I			IRP removed from queue
//
// Output
//		None
//
// Notes	
//

VOID VtdWdmDevice::StartIo(KIrp I)
{
	t << "Entering StartIo, " << I << EOL;

    // Check to see if the Irp has been canceled.
	CancelSpinLock::Acquire();
	if (I.WasCanceled())
	{
		CancelSpinLock::Release();
		return;
	}
	else
	{
		// Setting the cancel routine to NULL prevents the IRP
		// from being cancelled.  You may want to set a different
		// cancel routine here, or at other points within this function.
		I.SetCancelRoutine(NULL);
		CancelSpinLock::Release();
	}

	// Start processing request.

	// Switch on the IRP's function:
	switch (I.MajorFunction())
	{
		case IRP_MJ_READ:
			SerialRead(I);
			break;
		case IRP_MJ_DEVICE_CONTROL:
			SerialDeviceControl(I);
			break;
		default:
			// The driver queued an Irp that isn't handled
			// by StartIo.  This shouldn't happen.
			ASSERT(FALSE);
			PnpNextIrp(I);
			break;
	}
}

////////////////////////////////////////////////////////////////////////
// Create (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_CREATE
//
// Input
//		I			Current IRP
//
// Output   
//		NTSTATUS	Result code
//
// Notes   
//

NTSTATUS VtdWdmDevice::Create(KIrp I)
{ 
	t << "Entering VtdWdmDevice::Create, " << I << EOL;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	NTSTATUS status = m_Lower.PnpCall(this, I);

	t << "VtdWdmDevice::Create Status " << (ULONG)status << EOL;

	return status;
}


////////////////////////////////////////////////////////////////////////
// Close (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_CLOSE
//
// Input
//		I			Current IRP
//
// Output
//		NTSTATUS	Result code
//
// Notes
//

NTSTATUS VtdWdmDevice::Close(KIrp I)
{
	t << "Entering VtdWdmDevice::Close, " << I << EOL;

	I.ForceReuseOfCurrentStackLocationInCalldown();
	NTSTATUS status = m_Lower.PnpCall(this, I);

	t << "VtdWdmDevice::Close Status " << (ULONG)status << EOL;

    return status;
}

////////////////////////////////////////////////////////////////////////
// SerialRead (member of VtdWdmDevice)
//	
//		Handler for serialized READ
//
// Input	
//		I		Current IRP
//
// Output	
//		None
//
// Notes	
//		This routine is called when the IRP is removed from the
//		STARTIO queue.  This guarantees that multiple requests are
//		never processed simultaneously.
//
//		The read operation is completed asynchronously to test 
//		the NtKrn API under asynchronous completion conditions.
//
//		This routine is called at dispatch level.	

void VtdWdmDevice::SerialRead(KIrp I)
{

	t << "Entering VtdWdmDevice::SerialRead, " << I << EOL;

	// Waste some time here to ensure that this read actually
	// completes asynchronously.  Do this by invoking a timed
	// callback, which will actually perform the serialized read.

	// Calculate wait as 100ns intervals.  Negative is relative
	ULONG mSec = 2000;
	LARGE_INTEGER Wait100nSec;
	Wait100nSec.LowPart = -10000 * mSec;
	Wait100nSec.HighPart = -1;

	// Set m_TimedCallback with our relative wait interval
	m_TimedCallback.Set(Wait100nSec, LinkTo(SerialReadTimedCallback),
		this);
}

////////////////////////////////////////////////////////////////////////
// SerialReadTimedCallback (member of VtdWdmDevice)
//	
//		Finishes serialized read
//
// Input	
//		I		Current IRP
//
// Output	
//		None
//
// Notes	
//
//		This routine is called at dispatch level.	

void VtdWdmDevice::SerialReadTimedCallback(PVOID arg1, PVOID arg2)
{

	KIrp I = CurrentIrp();

	t << "Entering VtdWdmDevice::SerialReadTimedCallback, " << I << EOL;

	NTSTATUS status		= STATUS_SUCCESS;

#ifdef VTDWDM_USE_BUFFERED_IO

	PUCHAR	pBuffer		= (PUCHAR) I.BufferedReadDest();

#else // VTDWDM_USE_BUFFERED_IO

	// Declare a memory object
	KMemory Mem(I.Mdl());						// Declare a memory object
	// Use the memory object to create a pointer to the caller's buffer
	PUCHAR	pBuffer		= (PUCHAR) Mem.MapToSystemSpace();

#endif // VTDWDM_USE_BUFFERED_IO

	ULONG   dwTotalSize = I.ReadSize(CURRENT);	// Requested read size
	ULONG   dwBytesRead = 0;					// Count of bytes read

	dwBytesRead = m_Fifo.Read(pBuffer, dwTotalSize);

	I.Information() = dwBytesRead;
	I.Status() = status;

	PnpNextIrp(I);
}

////////////////////////////////////////////////////////////////////////
// Read (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_READ
//
// Input
//		I			Current IRP
//
// Output   
//		NTSTATUS	Result code
//
// Note   
//		This routine handles read requests.
//		The requests are queued to the StartIo	
//		queue.  This enforces serialization so that
//		multiple requests are not processed	
//		simultaneously.
//
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.

NTSTATUS VtdWdmDevice::Read(KIrp I) 
{
	t << "Entering VtdWdmDevice::Read, " << I << EOL;

	// Check the incomming request.  We have no special requirements so
	// this check never fails
    if (FALSE)		// If (Request is invalid)
	{
		// Invalid parameter in the Read request
		I.Information() = 0;
		return I.PnpComplete(this, STATUS_INVALID_PARAMETER);
	}

	// Always ok to read 0 elements.
	if (I.ReadSize() == 0)
	{
		I.Information() = 0;
		return I.PnpComplete(this, STATUS_SUCCESS);
	}


	// Queue the IRP for processing in StartIO
	// The read function is performed in SerialRead
	return QueueIrp(I, LinkTo(Cancel));
}


////////////////////////////////////////////////////////////////////////
// Write (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_WRITE
//
// Input
//		I			Current IRP
//
// Output   
//		NTSTATUS	Result code
//
// Note   
//		This routine handles write requests.  It does so synchronously.
//
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.

NTSTATUS VtdWdmDevice::Write(KIrp I) 
{
	t << "Entering VtdWdmDevice::Write, " << I << EOL;

	// Check the incomming request.  We have no special requirements so
	// this check never fails
    if (FALSE)
	{
		// Invalid parameter in the Write request
		I.Information() = 0;
		return I.PnpComplete(this, STATUS_INVALID_PARAMETER);
	}

	// Always ok to write 0 elements.
	if (I.WriteSize() == 0)
	{
		I.Information() = 0;
		return I.PnpComplete(this, STATUS_SUCCESS);
	}
	NTSTATUS status		= STATUS_SUCCESS;

#ifdef VTDWDM_USE_BUFFERED_IO

	PUCHAR	pBuffer		= (PUCHAR)I.BufferedWriteSource();

#else // VTDWDM_USE_BUFFERED_IO

	KMemory Mem(I.Mdl());						// Declare a memory object
	// Use the memory object to create a pointer to the caller's buffer
	PUCHAR	pBuffer		= (PUCHAR) Mem.VirtualAddress();

#endif // VTDWDM_USE_BUFFERED_IO

	ULONG   dwTotalSize = I.WriteSize(CURRENT);
	ULONG   dwBytesSent = 0;

	dwBytesSent = m_Fifo.Write(pBuffer, dwTotalSize);

	I.Information() = dwBytesSent;

	return I.PnpComplete(this, status);
}

////////////////////////////////////////////////////////////////////////
// SerialDeviceControl (member of VtdWdmDevice)
//
//		Handler for serialized IRP_MJ_DEVICECONTROL
//
// Input
//		I		Current IRP
//
// Output
//		None
//
// Notes	
//		This routine is called when the IRP is removed from the
//		STARTIO queue.  This guarantees that multiple requests are
//		never processed simultaneously.	

void VtdWdmDevice::SerialDeviceControl(KIrp I)
{
	NTSTATUS status;

	t << "Entering VtdWdmDevice::SerialDeviceControl, " << I << EOL;
    switch (I.IoctlCode())
	{
		default:
			// We queued a request that shouldn't have been queued
			// (should never get here)
			ASSERT(FALSE);
			status = STATUS_INVALID_PARAMETER;
			break;
	}

	I.Status() = status;
	PnpNextIrp(I);
}

////////////////////////////////////////////////////////////////////////
// DeviceControl (member of VtdWdmDevice)
//
//		Handler for IRP_MJ_DEVICE_CONTROL
//
// Input
//		I		Current IRP
// 
// Output
//		None
//
// Notes:
//		This routine is the first handler for Device Control requests.
//		Some function codes may be handled immediately, 
//		while others may be serialized through the StartIo routine.
//		
//		The KPnpDevice class handles restricting IRP flow
//		if the device is stopping or being removed.
//
NTSTATUS VtdWdmDevice::DeviceControl(KIrp I) 
{
	NTSTATUS status;

	t << "Entering VtdWdmDevice::Device Control, " << I << EOL;
	switch (I.IoctlCode())
	{
		case VTDWDM_IOCTL_800_GET_BUFFERED_COUNT:
			status = VTDWDM_IOCTL_800_GET_BUFFERED_COUNT_Handler(I);
			break;

		case VTDWDM_IOCTL_801_FILL_BUFFER:
			status = VTDWDM_IOCTL_801_FILL_BUFFER_Handler(I);
			break;
		
		case VTDWDM_IOCTL_802_FLUSH_BUFFER:
			status = VTDWDM_IOCTL_802_FLUSH_BUFFER_Handler(I);
			break;

		default:
			// Unrecognized IOCTL request
			status = STATUS_INVALID_PARAMETER;
			break;
	}

	// Drop out of case statement only if request has been handled, not queued
	return I.PnpComplete(this, status);
}

////////////////////////////////////////////////////////////////////////
//	VTDWDM_IOCTL_800_GET_BUFFERED_COUNT_Handler (member of VtdWdmDevice)
//
//		Handler for IO Control Code VTDWDM_IOCTL_800_GET_BUFFERED_COUNT
//
// Input
//		I			IRP containing IOCTL request
//
// Output
//		NTSTATUS	Status code indicating success or failure
//
// Note
//		This routine implements the VTDWDM_IOCTL_800_GET_BUFFERED_COUNT function.
//		This routine runs at passive level.
//
NTSTATUS VtdWdmDevice::VTDWDM_IOCTL_800_GET_BUFFERED_COUNT_Handler(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VtdWdmDevice::VTDWDM_IOCTL_800_GET_BUFFERED_COUNT_Handler, " << I << EOL;

	// make sure we have enough space to return perf info
	if(I.IoctlOutputBufferSize() < sizeof(IOCTL_800_GET_BUFFERED_COUNT_STRUCT)
		|| !I.IoctlBuffer())
	{
		status = I.Status() = STATUS_INVALID_PARAMETER;
		I.Information() = 0;
	}
	else
	{
		IOCTL_800_GET_BUFFERED_COUNT_STRUCT Struct;
		Struct.Count = m_Fifo.NumberOfItemsAvailableForRead();
		RtlCopyMemory(I.IoctlBuffer(),
			&Struct,
			sizeof(IOCTL_800_GET_BUFFERED_COUNT_STRUCT));
		I.Information() = sizeof(IOCTL_800_GET_BUFFERED_COUNT_STRUCT);
	}

	return status;
}

////////////////////////////////////////////////////////////////////////
//	VTDWDM_IOCTL_801_FILL_BUFFER_Handler (member of VtdWdmDevice)
//
//		Handler for IO Control Code VTDWDM_IOCTL_801_FILL_BUFFER
//
// Input
//		I			IRP containing IOCTL request
//
// Output
//		NTSTATUS	Status code indicating success or failure
//
// Note
//		This routine implements the VTDWDM_IOCTL_801_FILL_BUFFER function.
//		This routine runs at passive level.
//
NTSTATUS VtdWdmDevice::VTDWDM_IOCTL_801_FILL_BUFFER_Handler(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VtdWdmDevice::VTDWDM_IOCTL_801_FILL_BUFFER_Handler, " << I << EOL;

	// make sure the size of the buffer passed down is OK
	if(I.IoctlInputBufferSize() != sizeof(IOCTL_801_FILL_BUFFER_STRUCT) || !I.IoctlBuffer())
	{
		status = STATUS_INVALID_PARAMETER;
		I.Information() = 0;
		return status;
	}
	
	// Create a pointer to the setup structure
	PIOCTL_801_FILL_BUFFER_STRUCT pStruct =
		(PIOCTL_801_FILL_BUFFER_STRUCT)I.IoctlBuffer();

	// Fill the fifo
	m_Fifo.Lock();
	while(m_Fifo.Write((UCHAR *)&pStruct->Fill, 1))
	{
		continue;
	}
	m_Fifo.Unlock();

	// No information copied back
	I.Information() = 0;

	return status;
}

////////////////////////////////////////////////////////////////////////
//	VTDWDM_IOCTL_802_FLUSH_BUFFER_Handler (member of VtdWdmDevice)
//
//		Handler for IO Control Code VTDWDM_IOCTL_802_FLUSH_BUFFER
//
// Input
//		I			IRP containing IOCTL request
//
// Output
//		NTSTATUS	Status code indicating success or failure
//
// Note
//		This routine implements the VTDWDM_IOCTL_802_FLUSH_BUFFER function.
//		This routine runs at passive level.
//
NTSTATUS VtdWdmDevice::VTDWDM_IOCTL_802_FLUSH_BUFFER_Handler(KIrp I)
{
	NTSTATUS status = STATUS_SUCCESS;

	t << "Entering VtdWdmDevice::VTDWDM_IOCTL_802_FLUSH_BUFFER_Handler, " << I << EOL;

	// Flush the Fifo
	m_Fifo.LockedFlush();

	// No information copied back
	I.Information() = 0;

	return status;
}


