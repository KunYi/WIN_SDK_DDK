//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 1998 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
// U.S. GOVERNMENT RIGHTS-Use, duplication, or disclosure by the
// U.S. Government is subject to restrictions as set forth in 
// Compuware Corporation license agreement and as provided in 
// DFARS 227.7202-1(a) and 227.7202-3(a) (1995), 
// DFARS 252.227-7013(c)(1)(ii)(OCT 1988), FAR 12.212(a) (1995), 
// FAR 52.227-19, or FAR 52.227-14 (ALT III), as applicable.  
// Compuware Corporation.
// 
// This product contains confidential information and trade secrets 
// of Compuware Corporation. Use, disclosure, or reproduction is 
// prohibited without the prior express written permission of Compuware 
// Corporation.
//
//=============================================================================
//
// vv86api.cpp - implementation file for class VDeviceAPI
//

#include <vtoolscp.h>

#ifdef __BORLANDC__
	extern	"C" VOID __cdecl _call_previous(VMHANDLE, CLIENT_STRUCT*,
			VOID (VDeviceAPI::*)(VMHANDLE,CLIENT_STRUCT*));
#endif

#include PAGEABLE_CODE_SEGMENT
#include PAGEABLE_DATA_SEGMENT

extern "C" PVOID __cdecl createForeignAPIThunk(VDeviceAPI*, BYTE*, VOID(VDeviceAPI::*)(VMHANDLE,CLIENT_STRUCT*));

// Function
//	VDeviceAPI::VDeviceAPI
//
// Syntax
//	VDeviceAPI::VDeviceAPI(DWORD deviceID)
//
// Parameters
//	deviceID	identifies the device of the V86 API in question
//	flags		option bits:
//			DEVICE_V86_API		V86 API entry point
//			DEVICE_PM_API		PM API entry point
//
// Remarks
//	Constructs an instance of class VDeviceAPI. Each instance corresponds
//	to a particular device, which is identified by parameter deviceID.
//	A single instance of VDeviceAPI can process either the protected
//	mode API entry point, the V86 API entry point, or both.  Set one or 
//	both option bits in parameter flags to indicate which of device's API 
//	entry points you wish to trap.
//
VDeviceAPI::VDeviceAPI(DWORD deviceID, DWORD flags)
{
	m_ID = deviceID;
	m_prevV86 = 0;
	m_prevPM = 0;
	m_flags = flags;

}

// Function
//	VDeviceAPI::hook
//
// Syntax
//	BOOL VDeviceAPI::hook()
//
// Remarks
//	Hooks member function handler to the V86 and/or PM API of the device 
//	whose ID was specified in the call to the constructor.
//
// Return Value
//	Returns TRUE if successfully hooked.
//
BOOL VDeviceAPI::hook()
{
        PVOID pFunc = createForeignAPIThunk(this, m_thunk, &VDeviceAPI::handler);

	if (pFunc == 0)
		return FALSE;

	if (m_flags & DEVICE_V86_API)
	{
		*(PVOID*)&m_prevV86 = Hook_Device_V86_API(m_ID, (PV86Api_HANDLER) pFunc, NULL);
		if (m_prevV86 == 0)
		{
		 	DEBUGEVENT(DBG_HINT, "Failed to hook device V86 API");
			return FALSE;
		}
	}

	if (m_flags & DEVICE_PM_API)
	{
		*(PVOID*)&m_prevPM = Hook_Device_PM_API(m_ID, (PPMApi_HANDLER) pFunc, NULL);
		if (m_prevPM == 0)
		{
		 	DEBUGEVENT(DBG_HINT, "Failed to hook device PM API");
			return FALSE;
		}

	}

	return TRUE;
}

// Function
//	VDeviceAPI::unhook
//
// Syntax
//	BOOL VDeviceAPI::unhook()
//
// Remarks
//	Unhooks the handler from the the V86 and/or PM API of the device 
//	whose ID was specified in the call to the constructor.
//
// Return Value
//	Returns TRUE if successfully unhooked.
//
BOOL VDeviceAPI::unhook()
{
	VOID (VDeviceAPI::*prev)(VMHANDLE,CLIENT_STRUCT*);

	if (m_prevV86 != 0)
		if (Hook_Device_V86_API(m_ID, *(PV86Api_HANDLER*)&m_prevV86, NULL) == 0)
		{
		 	DEBUGEVENT(DBG_HINT, "Failed to unhook device V86 API");
			return FALSE;
		}


	if (m_prevPM != 0)
		if (Hook_Device_PM_API(m_ID, *(PPMApi_HANDLER*)&m_prevPM, NULL) == 0)
		{
		 	DEBUGEVENT(DBG_HINT, "Failed to unhook device PM API");
			return FALSE;
		}


	return TRUE;
}

// Dummy entry point for member function handler is located in the pageable
// code segment to ensure that the thunk generated by taking its address is
// accessible at the time it is hooked.  The actual handler (of the derived
// class) may be in the locked segment if desired.  The routine that creates
// the thunk for the handler invocation "un-thunks" the compiler generated
// thunk before hooking.

// Function
//	VDeviceAPI::handler
//
// Syntax
//	VOID VDeviceAPI::handler(VMHANDLE hVM, CLIENT_STRUCT* pRegs)
//
// Parameters
//	hVM	handler of virtual machine making API call
//	pRegs	pointer to register structure of client virtual machine
//
// Remarks
//	Override this function in the class you derive from VDeviceAPI.
//	Whenever a virtual machine makes a call to the V86 API of the
//	device specified in the call to the constructor, the system
//	will invoke this function. 
//
//	You can pass control to the API handler that was present at the
//	time the API entry point was hooked by calling member function
//	callPreviousHandler.
//
//	If you hooked both the PM and V86 APIs, you can distinguish which
//	is being called by testing the VM bit in the client's flags.
//
//		if (_clientEFlags & VM_MASK)
//			// client is V86
//		else
//			// client is protected mode
//
VOID VDeviceAPI::handler(VMHANDLE hVM, CLIENT_STRUCT* pRegs) 
{
	// if this function is called, it means you have not correctly
	// overridden member function handler in the class you derived
	// from VDeviceAPI

	DEBUGEVENT(DBG_ERROR,"\"handler\" for VDeviceAPI class is not defined correctly");
}


#include LOCKED_CODE_SEGMENT
#include LOCKED_DATA_SEGMENT

// Function
//	VDeviceAPI::callPreviousHandler
//
// Syntax
//	VOID VDeviceAPI::callPreviousHandler(VMHANDLE hVM, CLIENT_STRUCT* pRegs)
//
// Parameters
//	hVM	handle of virtual machine making API call
//	pRegs	pointer to register structure of client virtual machine
//
// Remarks
//	Invokes the API handler which was present at the time member function
//	hook was called.  Do not call this function unless you have already
//	successfully called member function hook.
//
//	Normally, the caller passes the same arguments (possibly with 
//	modifications) that were passed to member function handler.
//
//	If the client is in V86 mode, the previous V86 API entry point is 
//	called; if the client is not in V86 mode, the prevoius protected
//	mode API entry is called.
//
VOID VDeviceAPI::callPreviousHandler(VMHANDLE hVM, CLIENT_STRUCT* pRegs)
{
	VOID (VDeviceAPI::*prev)(VMHANDLE,CLIENT_STRUCT*);

	if (_clientEFlags & VM_MASK)
		prev = m_prevV86;
	else
		prev = m_prevPM;

	if (prev != 0)
	{
#ifndef __BORLANDC__
		_asm push ebp
		_asm mov edx, prev
		_asm mov ebx, hVM
		_asm mov eax, pRegs
		_asm mov ebp, eax
		_asm call edx
		_asm pop ebp
#else
		_call_previous(hVM, pRegs, prev);
#endif
	}

}

