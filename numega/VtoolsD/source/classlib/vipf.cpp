// vipf.cpp - implementation of class VInvalidPageFault
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 1998 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
// U.S. GOVERNMENT RIGHTS-Use, duplication, or disclosure by the
// U.S. Government is subject to restrictions as set forth in 
// Compuware Corporation license agreement and as provided in 
// DFARS 227.7202-1(a) and 227.7202-3(a) (1995), 
// DFARS 252.227-7013(c)(1)(ii)(OCT 1988), FAR 12.212(a) (1995), 
// FAR 52.227-19, or FAR 52.227-14 (ALT III), as applicable.  
// Compuware Corporation.
// 
// This product contains confidential information and trade secrets 
// of Compuware Corporation. Use, disclosure, or reproduction is 
// prohibited without the prior express written permission of Compuware 
// Corporation.
//
//=============================================================================



#include <vtoolscp.h>

#include PAGEABLE_CODE_SEGMENT
#include PAGEABLE_DATA_SEGMENT

extern "C" PVOID __cdecl createIPFThunk(VInvalidPageFault*,BYTE*,BOOL (VInvalidPageFault::*)(VMHANDLE, IPF_DATA*, CLIENT_STRUCT*));
extern "C" PVOID __cdecl getIPFHookAddress(BYTE*);

// Function
//	VInvalidPageFault::hook
//
// Syntax
//	BOOL VInvalidPageFault::hook()
//
// Remarks
//	Hooks the invalid page fault event to the member function handler.  
//	Calls the VMM serivce Hook_Invalid_Page_Fault.  If this function 
//	returns TRUE, any page faults that the system cannot handle will 
//	cause the handler to be called.
//
// Return Value
//	Returns TRUE if successful; otherwise FALSE
//
BOOL VInvalidPageFault::hook()
{
	PVOID pFunc;

	pFunc = createIPFThunk(this, m_thunk, &VInvalidPageFault::handler);

	if (Hook_Invalid_Page_Fault((PIPF_HANDLER) pFunc, NULL))
	{
		m_flags |= IPF_HOOKED;
		return TRUE;
	}
	else
	{
		DEBUGEVENT(DBG_WARNING, "Failed to hook invalid page fault");
		return FALSE;
	}
}

// Function
//	VInvalidPageFault::unhook
//
// Syntax
//	BOOL VInvalidPageFault::unhook()
//
// Remarks
//	Unhooks a previously hooked VInvalidPageFault.
//
// Return Value
//	Returns TRUE if the handler is successfully unhooked.
//
BOOL VInvalidPageFault::unhook()
{
	PVOID pFunc = (PVOID)&m_thunk[0];

	if (m_flags & IPF_HOOKED)
		return Unhook_Invalid_Page_Fault((PIPF_HANDLER) pFunc, NULL);
	else
		return FALSE;
}


// Function
//	VInvalidPageFault::handler
//
// Syntax
//	BOOL VInvalidPageFault::handler(VMHANDLE hVM, IPF_DATA* pIpf)
//
// Parameters
//	hVM	handle of the current virtual machine
//	pIpf	pointer to page fault information structure
//
// Remarks
//	Override this member function in the class you derive from 
//	VInvalidPageFault. It will be invoked whenever a page fault cannot 
//	be handled by the system.
//
// Return Value
//	Returns TRUE if the handler handles the page fault. Returns FALSE to
//	direct the system to call the next handler in the chain.
//
BOOL VInvalidPageFault::handler(VMHANDLE hVM, IPF_DATA* pIpf, CLIENT_STRUCT* pRegs)
{
	// if this function is called, it means you have not correctly
	// overridden member function handler in the class you derived
	// from VInvalidPageFault.

	DEBUGEVENT(DBG_ERROR,"\"handler\" for VInvalidPageFault class is not defined correctly");
	return FALSE;
}

// Dummy entry point for member function handler is located in the pageable
// code segment to ensure that the thunk generated by taking its address is
// accessible at the time it is hooked.  The actual handler (of the derived
// class) may be in the locked segment if desired.  The routine that creates
// the thunk for the handler invocation "un-thunks" the compiler generated
// thunk before hooking.
