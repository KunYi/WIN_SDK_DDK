// Tcpecho.cpp
//
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 2001 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================
// Generated by Driver::Wizard version 2.0

#define VDW_MAIN
#include <vdw.h>
#include "function.h"
#include "Tcpecho.h"
#pragma hdrstop("Tcpecho.pch")

#ifndef dprintf
# define dprintf DbgPrint
#endif


/////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(Tcpecho, NULL)

/////////////////////////////////////////////////////////////////////
// Driver Entry
// 
NTSTATUS Tcpecho::DriverEntry(PUNICODE_STRING RegistryPath)
{
	UNREFERENCED_PARAMETER(RegistryPath);

	// Initialize the TDIClient framework first

	if (!KTDInterface::Initialize())
	{
		return STATUS_NOT_FOUND; // something wrong with TDI
	}

	// Create our echo server, port 7

	CIPTRANSPORT_ADDRESS echo_port(IPPORT_ECHO);
	m_pListener = new KStreamServer<TcpEchoSession> (echo_port);

    // If succeeded - enable network events

    if (m_pListener && m_pListener->IsCreated()) {
        m_pListener->SetEvents(TRUE);
        dprintf("TcpechoDevice: Listener started\n");
    }
    else {
        dprintf("TcpechoDevice: Failed to start (port conflict?)\n");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

	return STATUS_SUCCESS;
}



#pragma code_seg()
#pragma warning( disable : 4706 )

//////////////////////////////////////////////////////////////////////////////
//	Unload is responsible for releasing any system objects that
//	the driver has allocated. 
//
VOID Tcpecho::Unload(VOID)
{
    if (m_pListener) 
	{
		// Disable network event notifications
		m_pListener->SetEvents(FALSE);

		// Iterate through the list of active sessions
		// and forcefully disconnect all active sessions
		TcpEchoSession* p;
		TDI_STATUS Status;

		while ( p = m_ActiveSessionList.RemoveHead() )
		{
			// By default, this method will perform an
			// abortive disconnect (RST)
			Status = p->disconnect();

			ASSERT(TDI_PENDING == Status || TDI_SUCCESS == Status);
		}

		// Wait for all outstanding requests to complete
		// By issuing a disconnect for all sessions, any
		// pending requests should be completed by the transport
		m_pListener->Wait();

		// destroy the socket
		delete m_pListener; 
		m_pListener = NULL;

	    dprintf("TcpechoDevice: Listener stopped\n");
	}

    // Call base class to delete all devices.
	KDriver::Unload();
}

/////////////////////////////////////////////////////////////////////////
// TcpEchoSession   -- Event handlers. 
BOOLEAN  TcpEchoSession::OnConnect(uint AddressLength, PTRANSPORT_ADDRESS pTA, 
                                    	uint OptionsLength, PVOID Options)
{
	// Connecting: print the IP address of the requestor and grant the connection

	char szIPaddr[20];

	inet_ntoa(PTDI_ADDRESS_IP(pTA->Address[0].Address)->in_addr, szIPaddr, sizeof(szIPaddr));

    dprintf("TcpechoDevice: Connecting client, IP addr = %s, session %8X\n", szIPaddr, this);

	// obtain a pointer to the KDriver derived class
	Tcpecho* p = reinterpret_cast<Tcpecho*>(KDriver::DriverInstance());
	ASSERT(p);

	// Add this object to the session list maintained by the driver
	p->m_ActiveSessionList.InsertTail(this);

	UNREFERENCED_PARAMETERS4(AddressLength, pTA, OptionsLength, Options);
    return TRUE;
}

void TcpEchoSession::OnDisconnect(uint OptionsLength, PVOID Options, BOOLEAN bAbort)
{
    dprintf("TcpechoDevice: Disconnecting client, session %8X\n", this);

	// obtain a pointer to the KDriver derived class
	Tcpecho* p = reinterpret_cast<Tcpecho*>(KDriver::DriverInstance());
	ASSERT(p);

	// Remove this object from the session list maintained by the driver
	p->m_ActiveSessionList.Remove(this);

	UNREFERENCED_PARAMETERS3(OptionsLength, Options,bAbort);
}

uint TcpEchoSession::OnReceive(uint Indicated, uchar *Data, uint Available,
									uchar **RcvBuffer, uint* RcvBufferLen) 
{ 
    // Received some data from the client peer. Allocate a buffer and echo the data.
	// Note the use of the echo buffer as a context for the callback.

    uchar* echo = new uchar [Indicated];
    if (echo) {
        memcpy(echo, Data, Indicated);
        TDI_STATUS status = send(echo, Indicated, echo);
        if (status == TDI_PENDING) 
            return Indicated; // normal case
        if (status != TDI_SUCCESS)
            dprintf("TcpechoDevice: Error %u sending echo\n", status);
        delete echo;
    }

	// Now, if the transport has more data available than indicated,
	// allocate another buffer to read the rest. When the transport
	// done with it - asynchronously - our OnReceiveComplete() handler
	// is called. Note that failure to submit a buffer supressed further
	// recieve indications - until and if a recv() is issued.

	if (Indicated < Available) {
		*RcvBuffer = new uchar [*RcvBufferLen = Available-Indicated];
	}

    return Indicated;
}

void TcpEchoSession::OnSendComplete(PVOID buf, TDI_STATUS status, uint bytecnt)
{ 
    // Our send request has completed. Free the buffer

    if (status != TDI_SUCCESS)
        dprintf("TcpechoDevice: Failed sending echo, err %X\n", status);
    delete ((uchar*)buf);

	UNREFERENCED_PARAMETER(bytecnt);
}

void TcpEchoSession::OnReceiveComplete(TDI_STATUS status, uint Indicated, uchar *Data)
{
	// Buffer for the partially indicated data allocated and submitted during 
	// OnReceive() processing is filled in by the transport. If everything is OK,
	// echo the buffer back to the remote client

    if (status == TDI_SUCCESS) 
		status = send(Data, Indicated, Data);
	else 
        dprintf("TcpechoDevice: Failed completing receive, err %X\n", status);

	if (status != TDI_PENDING)
		delete Data;
}


// end of file
