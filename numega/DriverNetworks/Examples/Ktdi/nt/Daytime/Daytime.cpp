/////////////////////////////////////////////////////////////////
// Daytime.cpp
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 2001 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================
//
// A trivial KTDI driver implementing RFC867 ("daytime") client.
// The driver periodically connects to NTP Server 192.5.41.41
// (U.S. Naval Observatory) to query the day time and prints the time
// to the debug monitor.
//
// Generated by Driver::Wizard version 2.0
// Requires Vireo's Driver::Works classes

#define VDW_MAIN
#include <vdw.h>
#include "function.h"
#include "Daytime.h"
#pragma hdrstop("Daytime.pch")

// Generated by Driver::Wizard version 2.0

/////////////////////////////////////////////////////////////////////
// Begin INIT section
#pragma code_seg("INIT")

DECLARE_DRIVER_CLASS(Daytime, NULL)

/////////////////////////////////////////////////////////////////////
// Driver Entry
// 
NTSTATUS Daytime::DriverEntry(PUNICODE_STRING RegistryPath)
{
	SetPoolTag(' weN');

	// Initialize the TDIClient framework first
	if (!KTDInterface::Initialize())
	{
		return STATUS_NOT_FOUND; // something wrong with TDI
	}

	// Create our client socket
	m_pSocket = new CDaytimeSocket;

    // If succeeded - enable network events
    if (m_pSocket && m_pSocket->IsCreated()) {
        m_pSocket->SetEvents(TRUE);
        DbgPrint("Daytime device: started at TCP port %u\n", m_pSocket->QueryPort());
    }
    else {
        DbgPrint("Daytime: Failed to start\n");
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Init 1st query
    m_pSocket->ScheduleQuery();

	return STATUS_SUCCESS;
}



#pragma code_seg()

/////////////////////////////////////////////////////////////////////
//	Unload is responsible for releasing any system objects that
//	the driver has allocated. 
//
VOID Daytime::Unload(VOID)
{
    if (m_pSocket)
        delete m_pSocket;

    // Call base class to delete all devices.
	KDriver::Unload();
}

/////////////////////////////////////////////////////////////////////////
// TCP client-side socket for "daytime"
CDaytimeSocket::CDaytimeSocket() : 
    KStreamSocket() 
{
}

CDaytimeSocket::~CDaytimeSocket()
{
    m_Timer.Cancel();
}


// Events:
void CDaytimeSocket::OnDisconnect(uint OptionsLength, PVOID Options, BOOLEAN bAbort)
{
    // OK: server disconnects, according to the RFC. Schedule next query.
    ScheduleQuery(); 
}

uint CDaytimeSocket::OnReceive(uint Indicated, uchar *Data,
									uint Available, uchar **RcvBuffer, uint* RcvBufferLen)
{
	UNREFERENCED_PARAMETERS3(Available, RcvBuffer, RcvBufferLen); // no need in this simple proto

    // Data from the server. It must be the ascii GMT, so print it.
    // NOTE that the server's string is NOT null-terminated, so
    // we put 0 at the end.

    Data[Indicated-1]=0;
    DbgPrint("Daytime GMT (%u bytes): %s\n", Indicated, (char*)Data);
    return Indicated;
}

void CDaytimeSocket::On_connectComplete(PVOID, TDI_STATUS Status, uint)
{
    if (Status != TDI_SUCCESS) {
        DbgPrint("Daytime: Error %X connecting to the server\n", Status);
        ScheduleQuery(); // try later
    }
}

//////////////////////////////////////////////////////////////////////
// Schedules timeout
void CDaytimeSocket::ScheduleQuery()
{
    LARGE_INTEGER tmo; 

    tmo.QuadPart = -LONGLONG(10000*DAYTIME_QUERY_PERIOD);
    m_Timer.Set(tmo, LinkTo(QueryTimeProc), this);
}

//////////////////////////////////////////////////////////////////////
// Procedure called periodically. 
// It initiates a TCP connection to server's port 13
//
void CDaytimeSocket::QueryTimeProc(PVOID arg1, PVOID arg2)
{
    TDI_ADDRESS_IP addr = {htons(IPPORT_DAYTIME), SERVER_US_NAVAL_OBSERVATORY};
    CTDI_CONNECTION_INFORMATION server(addr);

    TDI_STATUS status = connect(server, DAYTIME_QUERY_PERIOD/2);
    if (status != TDI_PENDING && status != TDI_SUCCESS)
       DbgPrint("Daytime: Failed to initiate connection due to err %X\n", status);
}


