// USBNICAdap.h: interface for the USBNICAdapter class.
//
// Generated by DriverNetworks Wizard 
//====================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 2002 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//====================================================================

#if !defined(AFX_USBNICADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_)
#define AFX_USBNICADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include	<kndis.h>
#include	"Characteristics.h" 
#if	BINARY_COMPATIBLE
// For Win9X compatability
#include	<KNdisWdm9XIndication.h>
#endif
	
#include <kndisvdw.h>	  // DriverWorks NDIS WDM	
#include <KIrpPool.h>	  // IRP Pool Helper	
typedef KIrpPool<KGenericIrpBuilder, KSpinLock> KWdmIrpPool;

#include <kusb.h>		  // USB classes
#include "hwimage.h"

//-------------------------------------------------------------------------
// Ethernet Frame Sizes
//-------------------------------------------------------------------------
const USHORT	ETHERNET_ADDRESS_LENGTH         =	6;
const USHORT	ETHERNET_HEADER_SIZE			=	14;
const USHORT	MINIMUM_ETHERNET_PACKET_SIZE	=	60;
const USHORT	MAXIMUM_ETHERNET_PACKET_SIZE    =	1514;
const USHORT	RCB_BUFFER_SIZE					=	1520; // 0x5F0

//-------------------------------------------------------------------------
// Ethernet Frame Structure
//-------------------------------------------------------------------------
#pragma pack(1)
//- Ethernet 6-byte Address
typedef struct _ETH_ADDRESS_STRUC {
    UCHAR       EthNodeAddress[ETHERNET_ADDRESS_LENGTH];
} ETH_ADDRESS_STRUC, *PETH_ADDRESS_STRUC;


//- Ethernet 14-byte Header
typedef struct _ETH_HEADER_STRUC {
    UCHAR       Destination[ETHERNET_ADDRESS_LENGTH];
    UCHAR       Source[ETHERNET_ADDRESS_LENGTH];
    USHORT      TypeLength;
} ETH_HEADER_STRUC, *PETH_HEADER_STRUC;

#pragma pack()


//-------------------------------------------------------------------------
// Device Specific Defines And Data Structures
//-------------------------------------------------------------------------
	#define TIMEOUT									10000
	#define BUF_SIZE								0x1000
	#define SOFS_TO_WAIT							0x1

	// Filter setting masks
	#define USBNIC_PACKET_FILTER_PROMISCUOUS        0x01
	#define USBNIC_PACKET_FILTER_ALL_MULTICAST      0x02
	#define USBNIC_PACKET_FILTER_DIRECTED           0x04
	#define USBNIC_PACKET_FILTER_BROADCAST          0x08
	#define USBNIC_PACKET_FILTER_MULTICAST          0x10

	// Command codes for the device
	#define USBNIC_COMMAND_GET_ETHERNET_DESC        0x00
	#define USBNIC_COMMAND_SET_PACKET_FILTER        0x01
	#define USBNIC_COMMAND_GET_MAC                  0x02
	#define USBNIC_COMMAND_SET_URB_SIZE             0x03
	#define USBNIC_COMMAND_SET_SOFS_WAIT            0x04
	#define USBNIC_COMMAND_SCAN                     0x05



#pragma pack(1)

typedef struct _RX_BUFFER_STRUC {
    UCHAR               RxBufferData[BUF_SIZE];
} RX_BUFFER_STRUC, *PRX_BUFFER_STRUC;

struct Ethernet_Configuration
{
	UCHAR	Size;
	UCHAR	Reserved1;
	UCHAR	Reserved2;
	ETH_ADDRESS_STRUC MAC_Address;
	UINT	Stats_Mask;
	USHORT	Segment_Size;
	USHORT	Max_Multicast_Filters;
	UCHAR	Reserved3;
};

#pragma pack()

///////////////////////////////////////////////////////////////////////
// USBNICAdapter		
//
// This class defines member methods which are passed control on
// NDIS callbacks. 
//
// The instances of the class are created automatically
// by KNDIS framework. The class expose no public methods
// since its methods are called only from the "friendly"
// KNdisWrapper class.
//
class USBNICAdapter : public KNdisMiniAdapter  
{
	SAFE_DESTRUCTORS

public:

	USBNICAdapter();
	~USBNICAdapter();

	// This structure is only used by the Tx functionality
	struct IRP_CONTEXT : public KNdisHeapClient<IRP_CONTEXT> {
		USBNICAdapter*	Adapter;			// should be present
		USBNICAdapter*	m_pClass;			// should be present - used by CompletionCntrlRoutine
		union _type {						// the rest is optional
			PNDIS_PACKET	m_Packet;		// for Tx SendComplete
			PVOID Something;				// Dummy pointer used in intialization
			//... Add more here if needed ...
		} type;
		UCHAR			Buffer[BUF_SIZE];	// for Tx - used as the transmit buffer
											// NOTE:
											// The first 2 bytes in the buffer are used to 
											// store the size of the Packet being transmitted. This is 
											// a device specific requirement and may not apply to the 
											// device your are using.
		PURB			m_pUrb;				// for Rx/Tx
		inline IRP_CONTEXT(USBNICAdapter* a, PVOID cxt=NULL) : Adapter(a) { type.Something=cxt; }
	}; 

	// This structure in only used by the KNdisSystemReceiveArea
	typedef struct _WDM_RFD {
		LIST_ENTRY			m_ListEntry;		// List entry for m_RxIrpList
		USBNICAdapter*		m_pAdapter;			// should be present
		PURB				m_pUrb;				// for Rx/Tx
		PIRP				m_Irp;				// Associated Irp for the URB
		UCHAR				m_RfdBuffer[BUF_SIZE];	// Data buffer for NDIS buffer - access using GetPacket()
		ULONG				m_RfdActualCount;	// Number Of Bytes Received
		ULONG				m_RfdSize;			// Number Of Bytes In RFD
		
		static ULONG GetBufferLength()			// Required by KNdisSystemReceiveArea
			{ return MAXIMUM_ETHERNET_PACKET_SIZE; }

		static ULONG GetBufferOffset()			// Required by KNdisSystemReceiveArea
		{
			ULONG x = FIELD_OFFSET(WDM_RFD, m_RfdBuffer) + 2;
			return x;
		}
												// A 2 byte advancement to the m_RfdBuffer is required
												// because the USB NIC device that was tested reserved
												// the first two bytes in the buffer for the Packet length
												// that is being received. This may not apply to the device 
												// you are using.
	} WDM_RFD, *PWDM_RFD;

	// These methods are callbacks required by KNdisSystemReceiveArea to initialize h/w RFD's
	VOID DescriptorInitialize(PWDM_RFD pHwDesc, PNDIS_PHYSICAL_ADDRESS pPhysAddr);
	VOID DescriptorInvalidate(PWDM_RFD pHwDesc);
	VOID DescriptorComplete(PWDM_RFD pHwDesc, PNDIS_PHYSICAL_ADDRESS pPhysAddr);
	VOID DescriptorReclaim(PWDM_RFD pHwDesc, PNDIS_PHYSICAL_ADDRESS pPhysAddr);
	VOID DumpWdmRfd(PWDM_RFD p);
	// Receive Area for incomming network packets
	KNdisSystemReceiveArea< USBNICAdapter, WDM_RFD >* m_pRxArea;
	void ReSubmitRfd(PWDM_RFD pHwDesc);

	// List of WDM_RFDs each containing a receive IRP.  Used to keep track of the IRPs
	// that are passed to the Bus driver. The Halt() routine uses this list for cleanup.
	KNdisList <WDM_RFD>		m_RxIrpList;

	// Need completion routines to take care of completed Rx/Tx IRPs:
	NTSTATUS CompletionTxRoutine(PIRP pIrp, IRP_CONTEXT* Context);
	NTSTATUS CompletionRxRoutine(PIRP pIrp, IRP_CONTEXT* Context);

	// Control Pipe completion routine for completed Control Irps
	MEMBER_COMPLETEIRPWITHCONTEXT(IRP_CONTEXT, CompletionCntrlRoutine)
	KWdmIrpPool			m_CntrlIrpPool;

#if	BINARY_COMPATIBLE
	VOID ProcessReceiveIndicate(PNDIS_PACKET Packet);
	KNdisWdm9XIndication<USBNICAdapter> m_PacketIndicate;
#endif

protected:

	// These methods MUST be implemented:
    VOID Halt(VOID);
    NDIS_STATUS Reset(OUT PBOOLEAN AddressingReset);
	NDIS_STATUS Initialize(IN OUT KNdisMedium& Medium, IN KNdisConfig& Config);

	// Optional handlers in accord with the content of Characteristics.h file.
	// The handlers are called from the following "friendly" class:
	friend class KNdisWrapper<USBNICAdapter>;

	// sending packets
	NDIS_STATUS Transmit(PNDIS_PACKET Packet);
    NDIS_STATUS Send(IN	PNDIS_PACKET Packet, IN	UINT Flags);

	// checking for bad things
    BOOLEAN CheckForHang();
		
	// recliaming packets
	VOID ReturnPacket(IN PNDIS_PACKET Packet);

	// processing shutdown
	VOID Shutdown(VOID);

	// OID processing (via OID_MAP)
	NDIS_STATUS QueryInformation(
			IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesWritten,
			OUT PULONG					BytesNeeded
			);
	NDIS_STATUS SetInformation(
			IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesRead,
			OUT PULONG					BytesNeeded
			);

	// Standard OID hanlders. This should be included in every adapter class declaration.
	#include	<KNdisOidDefs.h>

	// A list of supported OIDs. 
	static NDIS_OID sm_OID_GEN_SUPPORTED_LIST[];

private:

	// Device specific functions and variables
	Ethernet_Configuration	EthConfig;
	UCHAR					FirmwareBuffer[BUF_SIZE];
	NTSTATUS ControlCommand (
						  UCHAR Request, 
						  UCHAR Direction, 
						  USHORT value, 
						  USHORT index, 
						  PUCHAR data, 
						  short size, 
						  short timeout );

	AC_STATUS ActivateDevice();
	NTSTATUS ConfigureAndProbeDevice();
	NTSTATUS SetURBSize(short urb_size);
	NTSTATUS SetSOFSWait(short sofs_wait);
	NTSTATUS TriggerFirmware();
	NTSTATUS SetReceiveFilter(ULONG Rxfilters);
	NTSTATUS ReadConfiguration(Ethernet_Configuration	*pEthConfig);
	NTSTATUS DownLoadFirmware(PUCHAR data, USHORT length, UCHAR interrupt, UCHAR type);

	BOOLEAN				m_HaltFlag;
	KNdisEvent			m_RxIdleEvent;
	KNdisCounter		m_RxIrpsOutstanding;

	ETHERNET_ADDRESS	m_CurrentAddress;
	ETHERNET_ADDRESS	m_PermanentAddress;

	// NDIS_PACKET_TYPE_xxx bit set 
	ULONG			m_uPacketFilter;

	// NDIS_MAC_OPTION_xxx bit set
	ULONG			m_uMacOptions;
		
	// Queue of "pending" Tx packets. Serialized miniports might use
	// this queue to keep track of "pending" packets. Deserialized miniports 
	// have to maintain  an internal queue to cope with low resource situations
	// since NDIS doesn't take care of that in this case.
	KNdisPacketList	m_TxQueue;

	// Statistics. Included are the statistics defined by NDIS statistics OIDs
	KNdisStatsGen						m_GenStats;		// Mandatory GENeral stats
	// KNdisStatsGenEx					m_GenStats;		// Optional GENeral stats
	KNdisStatsEx<USBNIC_MEDIUM_TYPE>	m_MediumStats;	// Medium-specific stats

	// Power Management State
#if KNDIS_PNP_AWARE
	KNdisPnpMode<USBNICAdapter>		m_Power;
#endif

	// USB device access
	KUsbLowerDevice		m_BusDevice;	
	KUsbInterface		m_Interface;

	// Input Pipe for receives 
	KUsbPipe			m_ReceivePipe;
	// Output Pipe for Transmits 
	KUsbPipe			m_SendPipe;
	// Interrupt Control - This pipe is not always used
	KUsbPipe			m_InterruptPipe;

	// NDIS WDM Specific
	// Lower (bus) device objects:
	PDEVICE_OBJECT		m_PhysicalDeviceObject;
	PDEVICE_OBJECT		m_TopOfStackDeviceObject;

	// IRP Pools for talking to the WDM device
	KWdmIrpPool			m_TxIrpPool;
	KWdmIrpPool			m_RxIrpPool;

	// Fast Context storage (lookaside list-based)
	KNdisHeap<IRP_CONTEXT>	m_ContextHeap;

};

#endif // !defined(AFX_USBNICADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_)
 