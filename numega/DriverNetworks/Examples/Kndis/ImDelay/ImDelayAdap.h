// ImDelayAdap.h: interface for the ImDelayAdapter class.
//
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 2001 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================
// Generated by DriverNetworks Wizard on Monday, March 12, 2001
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_IMDELAYADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_)
#define AFX_IMDELAYADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include	<kndis.h>
#include	"Characteristics.h" 

// TODO:	Include your .h files as needed

///////////////////////////////////////////////////////////////////////
// Using private packet pools.
//
// NOTE Functionally, this driver does not need private packet pools.
//		It simply delays each packet for 10 msec (by default) without changing 
//		the content. Private packet pools are useful when you generate your own packets.
//      Our goal is to show how private pools (KNdisFilterPacketPool) should be used 
//		safely with DriverNetworks filter framework. 
//
//		The tricky part about using the pools is the access to the NDIS_PACKET's
//		Reserved areas. The Reserved areas are context sensitive (Protocol/Miniport)
//		and used by the frameworks internally. See online Help and this sample for
//		more about it.
// 
//		Uncomment and define the following statement for using the private pools. 
//
// #define	IMDELAY_USE_PRIVATE_POOLS

//////////////////////////////////////////////////////////////////////////////////
// Define the base class based on NDIS version

#if defined NDIS51_MINIPORT
typedef	KNdisFilterAdapter51	ImDelayBase;	// 5.1
#else
typedef	KNdisFilterAdapter50	ImDelayBase;	// 5.0
#endif



///////////////////////////////////////////////////////////////////////
// ImDelayAdapter		IM (Filter) Adapter Class 
//
// This class defines member methods which are passed control on
// NDIS callbacks. 
//
// The instances of the class are created automatically
// by DriverNetwork framework. The class exposes no public methods
// since its methods are called only from the "friendly"
// KNdisWrapper and KNdisFilterBinding classes.
//

class ImDelayAdapter : public ImDelayBase 
{
	SAFE_DESTRUCTORS

public:
	ImDelayAdapter();
	~ImDelayAdapter();

protected:
// Base class handler overrides

	// First call on a new object: a chance to accept or reject the binding
	 NDIS_STATUS OnInitialize(const KNdisMedium&, KNdisConfig&);

	// Last call on the object about to be destroyed
	 VOID OnHalt();

	// Reseting the  NIC:
	// NDIS_STATUS OnReset() { return NDIS_STATUS_SUCCESS; }

	// Intercepting upper-layer send. MUST be implemented
	 NDIS_STATUS OnSend(const KNdisPacket& Original, KNdisPacket& Repackaged);

	// Notifying on privately submitted Tx packet comletions:
	 VOID OnSendComplete(PNDIS_PACKET, NDIS_STATUS);
	// Notifying on return on privately submitted Rx packet indications:
	 // VOID OnReturnPacket(IN PNDIS_PACKET)  {}

	// Intercepting upper-layer OID requests:
	NDIS_STATUS OnQuery(KNdisRequest&, NDIS_STATUS ReturnedStatus);
	NDIS_STATUS OnSet(KNdisRequest&);

// Lower-edge Handlers: delegated from KNdisProtocolWrapper<Binding>

	// Intercetpting lower-layer packet receive:
	NDIS_STATUS OnReceive(const KNdisPacket& Original, KNdisPacket& Repackaged);

	// Processes the return of the indicated received packet
	VOID OnReturnPacket(PNDIS_PACKET pPacket);

	// Intercepting partial receive indication:
	NDIS_STATUS OnReceive(IN OUT KNdisPartialPacket& PacketToAccept,	
								  IN PVOID HeaderBuffer, IN UINT HeaderBufferSize,
								  IN PVOID LookAheadBuffer, IN UINT LookaheadBufferSize,
								  IN UINT PacketSize);

	// Intercepting lower-layer Status indications
	 NDIS_STATUS OnStatusIndication(NDIS_STATUS Status, IN OUT PVOID*, UINT*);

	// Intercepting protocol reconfigurations (PnP)
	NDIS_STATUS OnReconfiguration(PCWSTR wsSection, PNET_PNP_EVENT pEvent);

	 //  NDIS_STATUS OnStatusIndicationComplete() {}

	// NDIS 5.1 (KNdisFilterAdapter51)
	VOID OnCancelSendPackets(IN PVOID CancelId);

	// The hanlders are called from the following "friendly" class only:

	friend class KNdisWrapper<ImDelayAdapter>;
	friend class KNdisFilterBinding;

	// TODO: Add Your custom data members

	// Lists of delayed packets. Note the difference in construction of the lists

	KNdisInterlockedPacketList m_SendDelayQ;
	KNdisInterlockedPacketList m_ReceiveDelayQ;

#ifdef IMDELAY_USE_PRIVATE_POOLS

	// My examplary structure I store in the packet descriptors
	
	struct PacketContext 
	{
		PNDIS_PACKET	FrameworkPacket;				// eg
	};
	   
	// Pools


		typedef  KNdisFilterPacketPool<PacketContext, true> CTxPool;
		typedef  KNdisFilterPacketPool<PacketContext, false> CRxPool;
	
		CTxPool		m_TxPool;
		CRxPool		m_RxPool;
#endif //IMDELAY_USE_PRIVATE_POOLS

	KNdisTimer m_Timer; //declare timer
	KNDIS_DECLARE_TIMERCALLBACK(ImDelayAdapter, OnTimeout); // declare callback

	bool		m_bOn;		// controls operation
	ULONG		m_Delay;	// timer period in msec

	void OnTimeout();		// timeout callback

};


#endif // !defined(AFX_IMDELAYADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_)
 