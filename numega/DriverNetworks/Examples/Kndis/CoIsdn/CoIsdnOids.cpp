//////////////////////////////////////////////////////////////////////
// CoIsdnOids.cpp:	Definition of supported OIDs data 
//
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03063  USA
//
// Copyright (c) 2001 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================
//////////////////////////////////////////////////////////////////////
//
// Generated by Network Driver Wizard on Monday, July 22, 2002
//

#include "KNdis.h"
#include "NdisTapi.h"
#include "NdisWan.h"

#define INIT_STRING_CONST(name)     NDIS_STRING_CONST(name)
#define DECLARE_WIDE_STRING(name)   L##name
#define INIT_WIDE_STRING(name)      DECLARE_WIDE_STRING(name)

#define VER_DEVICE_STR "DriverNetWorks COISDN"

//////////////////////////////////////////////////////////////////////
//
KNDIS_OID_PROPERTY_NONBASIC ( OID_CO_TAPI_CM_CAPS, CO_TAPI_CM_CAPS, true)
KNDIS_OID_PROPERTY_NONBASIC ( OID_CO_TAPI_LINE_CAPS, CO_TAPI_LINE_CAPS, true)
KNDIS_OID_PROPERTY_NONBASIC ( OID_CO_TAPI_ADDRESS_CAPS, CO_TAPI_ADDRESS_CAPS, true)

KNDIS_OID_PROPERTY ( OID_WAN_PERMANENT_ADDRESS, ETHERNET_ADDRESS, false)
KNDIS_OID_PROPERTY ( OID_WAN_CURRENT_ADDRESS, ETHERNET_ADDRESS, false)
KNDIS_OID_PROPERTY ( OID_WAN_MEDIUM_SUBTYPE, NDIS_WAN_MEDIUM_SUBTYPE, false)

KNDIS_OID_PROPERTY_NONBASIC ( OID_WAN_CO_GET_INFO, NDIS_WAN_CO_INFO, true)
KNDIS_OID_PROPERTY_NONBASIC ( OID_WAN_CO_SET_LINK_INFO, NDIS_WAN_CO_SET_LINK_INFO, true)
KNDIS_OID_PROPERTY_NONBASIC ( OID_WAN_CO_GET_LINK_INFO, NDIS_WAN_CO_GET_LINK_INFO, true)

#include "CoIsdnAdap.h"
#include "BChannel.h"

extern KNdisTrace g_trace;

/////////////////////////////////////////////////////////////////////////////
// List of supported OIDs. 
// NOTES 
//	1. The static variable name is a standartized ("reserved") name in KNDIS
//  2. No compile-time provisions are made to guarantee the acsending order
//	   of the array. There is a run-time assertion in DBG builds, though.
/////////////////////////////////////////////////////////////////////////////
NDIS_OID CoIsdnAdapter::sm_OID_GEN_SUPPORTED_LIST[] = {
    OID_GEN_CO_SUPPORTED_LIST,
    OID_GEN_CO_HARDWARE_STATUS,
    OID_GEN_CO_MEDIA_SUPPORTED,
    OID_GEN_CO_MEDIA_IN_USE,
    OID_GEN_CO_LINK_SPEED,
    OID_GEN_CO_VENDOR_ID,
    OID_GEN_CO_VENDOR_DESCRIPTION,
    OID_GEN_CO_DRIVER_VERSION,
    OID_GEN_CO_PROTOCOL_OPTIONS,
    OID_GEN_CO_MAC_OPTIONS,
    OID_GEN_CO_MEDIA_CONNECT_STATUS,
    OID_GEN_CO_VENDOR_DRIVER_VERSION,
    OID_GEN_CO_SUPPORTED_GUIDS,
    
    OID_802_3_PERMANENT_ADDRESS,
    OID_802_3_CURRENT_ADDRESS,
    
    OID_WAN_PERMANENT_ADDRESS,
    OID_WAN_CURRENT_ADDRESS,
    OID_WAN_MEDIUM_SUBTYPE,
    
    OID_WAN_LINE_COUNT,

    OID_WAN_CO_GET_INFO,
    OID_WAN_CO_SET_LINK_INFO,
    OID_WAN_CO_GET_LINK_INFO,
        
    OID_PNP_CAPABILITIES,
    OID_PNP_SET_POWER,
    OID_PNP_QUERY_POWER,

    OID_CO_TAPI_CM_CAPS,
    OID_CO_TAPI_LINE_CAPS,
    OID_CO_TAPI_ADDRESS_CAPS,
    
};


/////////////////////////////////////////////////////////////////////////////
// OID Query Map
/////////////////////////////////////////////////////////////////////////////
//{{AFX_DNW 
// turn on optimization to compile out dead handler references
#pragma optimize("g", on)	
BEGIN_CO_OID_QUERY_MAP(CoIsdnAdapter, KNdisCallManagerVc, KNdisAdapterTraits<CoIsdnAdapter>)

	// GEN
	CO_OID_QUERY_ENTRY( OID_GEN_CO_HARDWARE_STATUS)
	CO_OID_QUERY_ENTRY( OID_GEN_CO_MEDIA_SUPPORTED)
	CO_OID_QUERY_ENTRY( OID_GEN_CO_MEDIA_IN_USE)
	CO_OID_QUERY_ENTRY( OID_GEN_CO_LINK_SPEED)
	CO_OID_QUERY_ENTRY( OID_GEN_CO_VENDOR_ID)
    CO_OID_QUERY_ENTRY( OID_GEN_CO_VENDOR_DESCRIPTION)
    
	CO_OID_QUERY_ENTRY( OID_GEN_CO_DRIVER_VERSION)

	CO_OID_QUERY_ENTRY( OID_GEN_CO_MAC_OPTIONS)
	CO_OID_QUERY_ENTRY( OID_GEN_CO_MEDIA_CONNECT_STATUS)
	CO_OID_QUERY_ENTRY( OID_GEN_CO_VENDOR_DRIVER_VERSION)
	CO_OID_QUERY_ENTRY( OID_GEN_CO_SUPPORTED_GUIDS)

	// OID_QUERY_ENTRY( OID_GEN_SUPPORTED_GUIDS)

	// TAPI
    CO_OID_QUERY_ENTRY( OID_CO_TAPI_CM_CAPS)
    CO_OID_QUERY_ENTRY( OID_CO_TAPI_LINE_CAPS)
    CO_OID_QUERY_ENTRY( OID_CO_TAPI_ADDRESS_CAPS)
    
    // 802.3
    CO_OID_QUERY_ENTRY( OID_802_3_PERMANENT_ADDRESS)
    CO_OID_QUERY_ENTRY( OID_802_3_CURRENT_ADDRESS)
    
    // WAN
    CO_OID_QUERY_ENTRY( OID_WAN_PERMANENT_ADDRESS)
    CO_OID_QUERY_ENTRY( OID_WAN_CURRENT_ADDRESS)
    CO_OID_QUERY_ENTRY( OID_WAN_MEDIUM_SUBTYPE)
    CO_OID_QUERY_ENTRY( OID_WAN_CO_GET_INFO)
    CO_OID_QUERY_ENTRY( OID_WAN_CO_GET_LINK_INFO)
    CO_OID_QUERY_ENTRY( OID_WAN_LINE_COUNT)
    
    
    // PNP
#if KNDIS_PNP_AWARE
    CO_OID_QUERY_ENTRY( OID_PNP_QUERY_POWER)
#endif // KNDIS_PNP_AWARE
    
END_CO_OID_QUERY_MAP()
#pragma optimize("", on)	// restore default optimization
//}}AFX_DNW


///////////////////////////////////////////////////////////////////////////
// OID Set Map
/////////////////////////////////////////////////////////////////////////////
//{{AFX_DNW 
// turn on optimization to compile out dead handler references
#pragma optimize("g", on)	
BEGIN_CO_OID_SET_MAP(CoIsdnAdapter, KNdisCallManagerVc, KNdisAdapterTraits<CoIsdnAdapter>)

	// GEN
    CO_OID_SET_ENTRY( OID_GEN_CO_PROTOCOL_OPTIONS)
    
    // WAN
    CO_OID_SET_ENTRY( OID_WAN_CO_SET_LINK_INFO)

    // PNP
#if KNDIS_PNP_AWARE
    CO_OID_SET_ENTRY( OID_PNP_SET_POWER)
#endif // KNDIS_PNP_AWARE

END_CO_OID_SET_MAP()
#pragma optimize("", on)	// restore default optimization
//}}AFX_DNW

///////////////////////////////////////////////////////////////////////////
// OID Handlers
// Don't use inlines for debug builds to allow breakpoints on handlers.
#ifdef _inline_
#undef _inline_
#endif
#if DBG
# define _inline_
#else
# define _inline_	inline
#endif 
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////
// OID Query Handlers


_inline_ NDIS_HARDWARE_STATUS CoIsdnAdapter::getOID_GEN_CO_HARDWARE_STATUS(KNdisCallManagerVc *pVC)
{
	return NdisHardwareStatusReady;
}

NDIS_STATUS  CoIsdnAdapter::getOID_GEN_CO_MEDIA_SUPPORTED(KNdisCallManagerVc *pVC, NDIS_MEDIUM* pMedium, PULONG ByteCount, OUT PULONG BytesNeeded) 
{
    // supported medium
    static NDIS_MEDIUM medium[] = { COISDN_MEDIUM_TYPE };
    
    if ( (*BytesNeeded = sizeof(medium)) > *ByteCount) {
        *ByteCount = 0;
        return NDIS_STATUS_BUFFER_TOO_SHORT;
    }
    NdisMoveMemory(pMedium, medium, (*ByteCount = sizeof(medium)));
    return NDIS_STATUS_SUCCESS; 
}

NDIS_STATUS  CoIsdnAdapter::getOID_GEN_CO_MEDIA_IN_USE(KNdisCallManagerVc *pVC, NDIS_MEDIUM* pMedium, PULONG ByteCount, OUT PULONG BytesNeeded) 
{
    if ( (*BytesNeeded = sizeof(NDIS_MEDIUM)) > *ByteCount) {
        *ByteCount = 0;
        return NDIS_STATUS_BUFFER_TOO_SHORT;
    }
    *pMedium = COISDN_MEDIUM_TYPE;
    *ByteCount = sizeof(NDIS_MEDIUM);
    return NDIS_STATUS_SUCCESS; 
}

_inline_ NDIS_STATUS CoIsdnAdapter::getOID_GEN_CO_LINK_SPEED(KNdisCallManagerVc *pVC, NDIS_CO_LINK_SPEED *pLinkSpeed, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded)
{
    *BytesNeeded = sizeof(*pLinkSpeed);
    if (*BytesCount < *BytesNeeded)
    {
        *BytesCount = 0;
        return NDIS_STATUS_BUFFER_TOO_SHORT;
    }
    *BytesCount = *BytesNeeded;

    CBChannel *pBChannel = static_cast<CBChannel*>(pVC);
    if (pBChannel)
    {
        pLinkSpeed->Inbound = pBChannel->m_LinkSpeed/100;
        pLinkSpeed->Outbound = pBChannel->m_LinkSpeed/100;
    }
    else
    {
        // Arbitrarily return the link speed of channel 0.
        if (m_BChannelVector.size())
        {
            pLinkSpeed->Inbound = m_BChannelVector[0]->m_LinkSpeed/100;
            pLinkSpeed->Outbound = m_BChannelVector[0]->m_LinkSpeed/100;
        }
        else
        {
            *BytesCount = 0;
            return NDIS_STATUS_FAILURE;            
        }
    }
    return NDIS_STATUS_SUCCESS;
}

_inline_ ULONG  CoIsdnAdapter::getOID_GEN_CO_VENDOR_ID(KNdisCallManagerVc *pVC)
{
    // This OID specifies a three-byte IEEE-registered vendor code.
    ETHERNET_ADDRESS addr = m_PermanentAddress;
    ULONG id = addr;			// get 1st 4 bytes
    * (PUCHAR(&id)+3) = 0;		// my "NIC" id
    return id;
}

NDIS_STATUS  CoIsdnAdapter::getOID_GEN_CO_VENDOR_DESCRIPTION(KNdisCallManagerVc *pVC, char* pDesc, IN OUT PULONG ByteCount, OUT PULONG BytesNeeded)
{
    static char Desc[] = COISDN_VENDOR_DESCRIPTION;
    if ((*BytesNeeded = sizeof(Desc)) > *ByteCount) {
        *ByteCount = 0; 
        return NDIS_STATUS_BUFFER_TOO_SHORT;
    }
    NdisMoveMemory(pDesc, Desc, (*ByteCount = sizeof(Desc)));
    return NDIS_STATUS_SUCCESS; 
}

_inline_ USHORT CoIsdnAdapter::getOID_GEN_CO_DRIVER_VERSION(KNdisCallManagerVc *pVC)
{
    return KNdisAdapterTraits<CoIsdnAdapter>::NdisVersion();
}

_inline_ ULONG  CoIsdnAdapter::getOID_GEN_CO_MAC_OPTIONS(KNdisCallManagerVc *pVC)
{
    return m_uMacOptions;
}

_inline_ NDIS_MEDIA_STATE  CoIsdnAdapter::getOID_GEN_CO_MEDIA_CONNECT_STATUS(KNdisCallManagerVc *pVC)
{
	// TODO:	Read status form h/w
	return NdisMediaStateConnected;
}

_inline_ ULONG CoIsdnAdapter::getOID_GEN_CO_VENDOR_DRIVER_VERSION(KNdisCallManagerVc *pVC)
{
	return (COISDN_VERSION_MAJOR<<8) | COISDN_VERSION_MINOR;
}

_inline_ NDIS_STATUS CoIsdnAdapter::getOID_GEN_CO_SUPPORTED_GUIDS(KNdisCallManagerVc *pVC, NDIS_GUID* pGuids, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded) 
{
    *BytesCount = 0;
    *BytesNeeded = 0;
    return NDIS_STATUS_SUCCESS;
}

_inline_ NDIS_STATUS CoIsdnAdapter::getOID_CO_TAPI_CM_CAPS(KNdisCallManagerVc *pVC, CO_TAPI_CM_CAPS *pCaps, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded)
{
    pCaps->ulCoTapiVersion = CO_TAPI_VERSION;
    pCaps->ulNumLines = m_BChannelVector.size();
    pCaps->ulFlags = 0;    

    *BytesCount = *BytesNeeded = sizeof(CO_TAPI_CM_CAPS);
    return NDIS_STATUS_SUCCESS;
}

_inline_ NDIS_STATUS CoIsdnAdapter::getOID_CO_TAPI_LINE_CAPS(KNdisCallManagerVc *pVC, CO_TAPI_LINE_CAPS *pCaps, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded) 
{
    UINT InfoOffset;
    UINT InfoLength;
    static NDIS_STRING VendorDescriptionString = INIT_STRING_CONST(COISDN_VENDOR_DESCRIPTION);
    static WCHAR LineSwitchName[] = INIT_WIDE_STRING(VER_DEVICE_STR) DECLARE_WIDE_STRING(" Switch");
    // TODO: Replace with unicode string to identify the ISDN switch.    
    pCaps->ulFlags = 0;
    
    *BytesNeeded = sizeof(CO_TAPI_CM_CAPS);
    if (*BytesCount >= *BytesNeeded)
    {
        if (pCaps->ulLineID >= m_BChannelVector.size())
        {
            *BytesCount = 0;
            return NDIS_STATUS_INVALID_DATA;
        }

        CBChannel *pBChannel = m_BChannelVector[pCaps->ulLineID];
    
        pCaps->LineDevCaps.ulNeededSize =
            pCaps->LineDevCaps.ulUsedSize = sizeof(pCaps->LineDevCaps);
    
        /*
        // The driver numbers lines sequentially from 1, so this will 
        // always be the same number.
        */
        pCaps->LineDevCaps.ulPermanentLineID = pCaps->ulLineID;
    
        /*
        // All the strings are ASCII format rather than UNICODE.
        */
        pCaps->LineDevCaps.ulStringFormat = STRINGFORMAT_UNICODE;
    
        /*
        // Report the capabilities of this device.
        */
        pCaps->LineDevCaps.ulLineFeatures = LINEFEATURE_MAKECALL;
        pCaps->LineDevCaps.ulAddressModes = LINEADDRESSMODE_ADDRESSID;
        pCaps->LineDevCaps.ulNumAddresses = 1;
        pCaps->LineDevCaps.ulBearerModes  = pBChannel->m_BearerModesCaps;
        pCaps->LineDevCaps.ulMaxRate      = pBChannel->m_LinkSpeed;
        pCaps->LineDevCaps.ulMediaModes   = pBChannel->m_MediaModesCaps;
    
        /*
        // Each line on the PRI only supports a single call.
        */
        pCaps->LineDevCaps.ulDevCapFlags = LINEDEVCAPFLAGS_CLOSEDROP;
        pCaps->LineDevCaps.ulMaxNumActiveCalls = 1;
        pCaps->LineDevCaps.ulAnswerMode = LINEANSWERMODE_DROP;
        pCaps->LineDevCaps.ulRingModes  = 1;
        pCaps->LineDevCaps.ulLineStates = pBChannel->m_DevStatesCaps;
    
        /*
        // RASTAPI requires TSPI provider name to be placed in the
        // ProviderInfo field at the end of this structure.
        */
        InfoOffset = sizeof(pCaps->LineDevCaps);
        InfoLength = VendorDescriptionString.MaximumLength;
        pCaps->LineDevCaps.ulNeededSize += InfoLength;
        *BytesNeeded += InfoLength;
        if (pCaps->LineDevCaps.ulNeededSize <= 
            pCaps->LineDevCaps.ulTotalSize)
        {
            pCaps->LineDevCaps.ulProviderInfoSize   = InfoLength;
            pCaps->LineDevCaps.ulProviderInfoOffset = InfoOffset;
            NdisMoveMemory((PUCHAR) &pCaps->LineDevCaps + InfoOffset,
                VendorDescriptionString.Buffer,
                InfoLength
                );
            pCaps->LineDevCaps.ulUsedSize += InfoLength;
            InfoOffset += InfoLength;
        }
    
        /*
        // SwitchName is not yet displayed by the Dialup Networking App,
        // but we'll return something reasonable just in case.
        */
        InfoLength = sizeof(LineSwitchName);
        pCaps->LineDevCaps.ulNeededSize += InfoLength;
        *BytesNeeded += InfoLength;
        if (pCaps->LineDevCaps.ulNeededSize <= 
            pCaps->LineDevCaps.ulTotalSize)
        {
            pCaps->LineDevCaps.ulSwitchInfoSize   = InfoLength;
            pCaps->LineDevCaps.ulSwitchInfoOffset = InfoOffset;
            NdisMoveMemory((PUCHAR) &pCaps->LineDevCaps + InfoOffset,
                LineSwitchName,
                InfoLength
                );
            pCaps->LineDevCaps.ulUsedSize += InfoLength;
            InfoOffset += InfoLength;
        }
        else
        {
            g_trace.Trace("STRUCTURETOOSMALL %d<%d\n",
                pCaps->LineDevCaps.ulTotalSize,
                pCaps->LineDevCaps.ulNeededSize);
            *BytesCount = 0;
            return NDIS_STATUS_INVALID_LENGTH;
        }
    }
    else
    {
        g_trace.Trace("OID_CO_TAPI_LINE_CAPS: Invalid size=%d expected=%d\n",
            *BytesCount, *BytesNeeded);
    }
    if (*BytesNeeded <= *BytesCount)
    {
        *BytesCount = *BytesNeeded;
        return NDIS_STATUS_SUCCESS;
    }
    else
    {
        *BytesCount = 0;
        return NDIS_STATUS_INVALID_LENGTH;;
    }
}

_inline_ NDIS_STATUS CoIsdnAdapter::getOID_CO_TAPI_ADDRESS_CAPS(KNdisCallManagerVc *pVC, CO_TAPI_ADDRESS_CAPS *pCaps, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded)
{
    UINT InfoOffset;
    UINT InfoLength;
    static WCHAR LineAddressName[] = INIT_WIDE_STRING(VER_DEVICE_STR) DECLARE_WIDE_STRING(" Address 00");

    *BytesNeeded = sizeof(*pCaps);
    if (*BytesCount >= *BytesNeeded)
    {
        pCaps->ulFlags = 0;
        
        if (pCaps->ulLineID >= m_BChannelVector.size())
        {
            *BytesCount = 0;
            return NDIS_STATUS_INVALID_DATA;
        }
        CBChannel *pBChannel = m_BChannelVector[pCaps->ulLineID];
        
        // We're writting at least this much, maybe more.
        pCaps->LineAddressCaps.ulNeededSize =
            pCaps->LineAddressCaps.ulUsedSize = 
            sizeof(pCaps->LineAddressCaps);
        
        pCaps->LineAddressCaps.ulLineDeviceID = pCaps->ulLineID;
        
        /*
        // Return the various address capabilites for the adapter.
        */
        pCaps->LineAddressCaps.ulAddressFeatures = 
            LINEADDRFEATURE_MAKECALL;
        pCaps->LineAddressCaps.ulAddressSharing = 
            LINEADDRESSSHARING_PRIVATE;
        pCaps->LineAddressCaps.ulAddressStates = 
            pBChannel->m_AddressStatesCaps;
        pCaps->LineAddressCaps.ulCallStates = 
            pBChannel->m_CallStatesCaps;
        pCaps->LineAddressCaps.ulDialToneModes = 
            LINEDIALTONEMODE_NORMAL;
        pCaps->LineAddressCaps.ulDisconnectModes =
            LINEDISCONNECTMODE_NORMAL |
            LINEDISCONNECTMODE_UNKNOWN |
            LINEDISCONNECTMODE_BUSY |
            LINEDISCONNECTMODE_NOANSWER;
        /*
        // This driver does not support conference calls, transfers, 
        // or holds.
        */
        pCaps->LineAddressCaps.ulMaxNumActiveCalls = 1;
        pCaps->LineAddressCaps.ulAddrCapFlags = 
            LINEADDRCAPFLAGS_DIALED;
        pCaps->LineAddressCaps.ulCallFeatures = 
            LINECALLFEATURE_ACCEPT |
            LINECALLFEATURE_ANSWER |
            LINECALLFEATURE_DROP;
        
        /*
        // AddressName is displayed by the Dialup Networking App.
        */
        InfoOffset = sizeof(pCaps->LineAddressCaps);
        InfoLength = sizeof(LineAddressName);
        pCaps->LineAddressCaps.ulNeededSize += InfoLength;
        *BytesNeeded += InfoLength;
        if (pCaps->LineAddressCaps.ulNeededSize <= 
            pCaps->LineAddressCaps.ulTotalSize)
        {
            pCaps->LineAddressCaps.ulAddressSize = InfoLength;
            pCaps->LineAddressCaps.ulAddressOffset = InfoOffset;
            NdisMoveMemory(
                (PUCHAR) &pCaps->LineAddressCaps + InfoOffset,
                LineAddressName,
                InfoLength);
            pCaps->LineAddressCaps.ulUsedSize += InfoLength;
            InfoOffset += InfoLength;
        }
        else
        {
            g_trace.Trace("STRUCTURETOOSMALL %d<%d\n",
                pCaps->LineAddressCaps.ulTotalSize,
                pCaps->LineAddressCaps.ulNeededSize);
            *BytesCount = 0;
            return NDIS_STATUS_INVALID_LENGTH;;
        }
        
    }
    else
    {
        g_trace.Trace("OID_CO_TAPI_ADDRESS_CAPS: Invalid size=%d expected=%d\n",
            *BytesCount, *BytesNeeded);
    }
    if (*BytesNeeded <= *BytesCount)
    {
        *BytesCount = *BytesNeeded;
        return NDIS_STATUS_SUCCESS;
    }
    else
    {
        *BytesCount = 0;
        return NDIS_STATUS_INVALID_LENGTH;;
    }
}

_inline_ ETHERNET_ADDRESS  CoIsdnAdapter::getOID_802_3_CURRENT_ADDRESS(KNdisCallManagerVc *pVC)
{
    return m_CurrentAddress;
}

_inline_ ETHERNET_ADDRESS CoIsdnAdapter::getOID_802_3_PERMANENT_ADDRESS(KNdisCallManagerVc *pVC)
{
    return m_PermanentAddress;
}

_inline_ ETHERNET_ADDRESS  CoIsdnAdapter::getOID_WAN_PERMANENT_ADDRESS(KNdisCallManagerVc *pVC)
{
    return m_PermanentAddress;
}

_inline_ ETHERNET_ADDRESS CoIsdnAdapter::getOID_WAN_CURRENT_ADDRESS(KNdisCallManagerVc *pVC)
{
    return m_CurrentAddress;
}

_inline_ NDIS_STATUS CoIsdnAdapter::getOID_WAN_CO_GET_INFO(KNdisCallManagerVc *pVC, NDIS_WAN_CO_INFO *pInfo, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded)
{
    *pInfo = m_WanInfo;
    *BytesNeeded = *BytesCount = sizeof(NDIS_WAN_CO_INFO);
    return NDIS_STATUS_SUCCESS;
}

_inline_ NDIS_STATUS CoIsdnAdapter::getOID_WAN_CO_GET_LINK_INFO(KNdisCallManagerVc *pVC, NDIS_WAN_CO_GET_LINK_INFO *pLinkInfo, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded)
{
    CBChannel *pBChannel = static_cast<CBChannel*>(pVC);
    if (pBChannel)
    {
        NdisMoveMemory(pLinkInfo, &pBChannel->m_WanLinkInfo, sizeof (*pLinkInfo));
        *BytesNeeded = *BytesCount = sizeof(NDIS_WAN_CO_GET_LINK_INFO);
        return NDIS_STATUS_SUCCESS;
    }
    return NDIS_STATUS_INVALID_DATA;
}

_inline_ ULONG CoIsdnAdapter::getOID_WAN_LINE_COUNT(KNdisCallManagerVc *pVC)
{
    return m_BChannelVector.size();
}

_inline_ NDIS_WAN_MEDIUM_SUBTYPE CoIsdnAdapter::getOID_WAN_MEDIUM_SUBTYPE(KNdisCallManagerVc *pVC)
{
    return NdisWanMediumIsdn;
}

/////////////////////////////////////////////////////////////////
// OID Set Handlers

NDIS_STATUS  CoIsdnAdapter::setOID_GEN_CO_PROTOCOL_OPTIONS(KNdisCallManagerVc *pVC, PULONG Param)
{
	m_uMacOptions = *Param;
	return NDIS_STATUS_SUCCESS;	// ignore for now
}


////////////////////////////////////////////////////////
// Medium specific handlers
//

NDIS_STATUS  CoIsdnAdapter::setOID_WAN_CO_SET_LINK_INFO
(KNdisCallManagerVc *pVC, NDIS_WAN_CO_SET_LINK_INFO *pLinkInfo, IN OUT PULONG BytesCount, OUT PULONG BytesNeeded)
{
    CBChannel *pBChannel =  static_cast<CBChannel*>(pVC);
    if (!pBChannel)
    {
        return NDIS_STATUS_INVALID_DATA;
    }
    
    ASSERT(!(pBChannel->m_WanLinkInfo.SendFramingBits & 
        ~m_WanInfo.FramingBits));
    ASSERT(!(pBChannel->m_WanLinkInfo.RecvFramingBits & 
        ~m_WanInfo.FramingBits));
    
    /*
    // Copy the data into our WanLinkInfo sturcture.
    */
    pBChannel->m_WanLinkInfo = *pLinkInfo;

    if (pBChannel->m_WanLinkInfo.MaxSendFrameSize != 
        m_WanInfo.MaxFrameSize ||
        pBChannel->m_WanLinkInfo.MaxRecvFrameSize != 
        m_WanInfo.MaxFrameSize)
    {
        g_trace.Trace("Line=%p - "
            "SendFrameSize=%08lX - "
            "RecvFrameSize=%08lX\n",
            pBChannel,
            pBChannel->m_WanLinkInfo.MaxSendFrameSize,
            pBChannel->m_WanLinkInfo.MaxRecvFrameSize);
    }
    *BytesCount = *BytesNeeded = sizeof(NDIS_WAN_CO_SET_LINK_INFO);
    return NDIS_STATUS_SUCCESS;
}

///////////////////////////////////////////////////////////////
// PnP Hanlders

#if (KNDIS_PNP_AWARE)

NDIS_STATUS CoIsdnAdapter::getOID_PNP_QUERY_POWER(KNdisCallManagerVc *pVC, PNDIS_DEVICE_POWER_STATE DesiredState)
{
	// TODO: Check if it is safe to switch to the specified lower-power state.
	//       On successful return, NDIS will immediately call OID_PNP_SET_POWER
	UNREFERENCED_PARAMETER(DesiredState);
	return NDIS_STATUS_SUCCESS;
}

NDIS_STATUS CoIsdnAdapter::setOID_PNP_SET_POWER(KNdisCallManagerVc *pVC, PNDIS_DEVICE_POWER_STATE DesiredState)
{
	// TODO: Do switch to the specified lower-power state. Can't fail.

	m_Power = *DesiredState;
	return NDIS_STATUS_SUCCESS;
}

#endif // KNDIS_PNP_AWARE
