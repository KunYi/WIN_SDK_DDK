//////////////////////////////////////////////////////////////////////
// CoIsdnAdap.h: interface for the CoIsdnAdapter class.
//
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03063  USA
//
// Copyright (c) 2001 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================
//////////////////////////////////////////////////////////////////////
//
// Generated by Network Driver Wizard on Monday, July 22, 2002

#if !defined(AFX_COISDNADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_)
#define AFX_COISDNADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define _CTYPE_DISABLE_MACROS
#define _INC_WCHAR

#include <kndis.h>
#include "Characteristics.h"
#include "KNdisCoMiniportChars.h"
#include "KNdisCallManagerChars.h"
#include <kstl.h>
#include <vector>
#include "CardEvents.h"
#include "KNdisPacketList.h"
#include "NdisWan.h"
#include "BChannel.h"

/*
// The link speeds we support.
*/
#define _64KBPS                     64000
#define _56KBPS                     56000

#define MICROSECONDS                (1)
#define MILLISECONDS                (1000*MICROSECONDS)
#define SECONDS                     (1000*MILLISECONDS)

#define TSPI_ADDRESS_ID             0

///////////////////////////////////////////////////////////////////////
//Forward declarations
class CCard;
class CBChannel;
class CDChannel;

///////////////////////////////////////////////////////////////////////
// CoIsdnAdapter		
//
// This class defines member methods which are passed control on
// NDIS callbacks. 
//
// The instances of the class are created automatically
// by KNDIS framework. The class exposes no public methods
// since its methods are called only from the "friendly"
// KNdisWrapper class.
//
class CoIsdnAdapter : public KNdisMiniAdapter  
{
	SAFE_DESTRUCTORS
public:
	CoIsdnAdapter();

    // Configure a channel's link info
    VOID ConfigureLinkInfo(NDIS_WAN_CO_SET_LINK_INFO& LinkInfo);
    CDChannel *GetDChannel()
    {
        return m_pDChannel;
    }
    CCard* GetCard()
    {
        return m_pCard;
    }

    ULONG GetNumBChannels() const
    {
        return m_BChannelVector.size();
    }

    VOID ScheduleEvent(UINT MillisecondsDelay);
    VOID FlushSendPackets(CBChannel *pBChannel);
    VOID TransmitCompleteHandler();
    VOID TransmitStartPacket(CBChannel *pBChannel, PNDIS_PACKET pPacket);

    VOID BChannelFromPhoneNumber(const basic_string<UCHAR>& rstrDial, CBChannel **ppBChannel);
    NDIS_STATUS SetupIncomingCall(CBChannel **ppBChannel);
    VOID RecordTransmitCompletion(PNDIS_PACKET pPacket);

protected:
	~CoIsdnAdapter();

	// These methods MUST be implemented:
	NDIS_STATUS Initialize(IN OUT KNdisMedium& Medium, IN KNdisConfig& Config);
    VOID Halt(VOID);
    NDIS_STATUS Reset(OUT PBOOLEAN AddressingReset);

	// Optional handlers in accord with the content of Characteristics.h file.
	// The handlers are called from the following "friendly" class:
    friend class KNdisWrapper<CoIsdnAdapter>;
	friend class KNdisCoWrapper<CoIsdnAdapter, CBChannel>;
    friend KNdisMiniportVcTraits<CoIsdnAdapter, CBChannel>;
    friend class KNdisCallManagerWrapper<CoIsdnAdapter, CBChannel>;
    friend class KNdisCallManagerVcTraits<CoIsdnAdapter, CBChannel>;

    VOID TransmitPacketHandler();
    VOID CompleteCmOpenAf(NDIS_STATUS Status);
    VOID CompleteCmRegisterSap(CBChannel *pBChannel, NDIS_STATUS Status);
    VOID CompleteCmDeregisterSap(CBChannel *pBChannel, NDIS_STATUS Status);
    VOID CompleteCloseAf(NDIS_STATUS Status);

public:
	// checking for bad things
    BOOLEAN CheckForHang();

	// Interrupt Processing
     VOID DisableInterrupt();
     VOID EnableInterrupt();
     VOID HandleInterrupt();
     VOID Isr(OUT PBOOLEAN InterruptRecognized, 
			  OUT PBOOLEAN QueueMiniportHandleInterrupt);

	// reclaiming packets
	VOID ReturnPacket(IN PNDIS_PACKET Packet);

	// processing shutdown
	VOID Shutdown(VOID);

	// OID processing (via OID_MAP)
	NDIS_STATUS CoQueryInformation(
            IN  KNdisCallManagerVc      *pVC,
			IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesWritten,
			OUT PULONG					BytesNeeded
			);
	NDIS_STATUS CoSetInformation(
            IN  KNdisCallManagerVc      *pVC,
            IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesRead,
			OUT PULONG					BytesNeeded
			);

	// NDIS 5.1 Handlers
#if defined(NDIS51_MINIPORT)
	VOID PnPEventNotify(
			IN NDIS_DEVICE_PNP_EVENT  PnPEvent,
			IN PVOID  InformationBuffer,
			IN ULONG  InformationBufferLength
		    );

#endif // NDIS51_MINIPORT

        
	// Standard OID handlers. This should be included in every adapter class declaration.
	#include	<KNdisCoOidDefs.h>

	// A list of supported OIDs. 
	static NDIS_OID sm_OID_GEN_SUPPORTED_LIST[];

    // Connection-Oriented Miniport operations
    NDIS_STATUS CoRequest(CBChannel *pBChannel, IN OUT PNDIS_REQUEST NdisRequest);
    NDIS_STATUS GetAvailableIsdnChannel(NDIS_HANDLE NdisVcHandle, CBChannel **ppBChannel);
    NDIS_STATUS FreeIsdnChannel(CBChannel *pBChannel);

    // Call Manager operations
    NDIS_STATUS CmOpenAf(
        IN PCO_ADDRESS_FAMILY AddressFamily,
        IN NDIS_HANDLE NdisAfHandle,
        OUT PNDIS_HANDLE CallMgrAfContext
        );
        
    static NDIS_STATUS CmRegisterSap(
        IN NDIS_HANDLE CallMgrAfContext,
        IN PCO_SAP Sap,
        IN NDIS_HANDLE NdisSapHandle,
        OUT PNDIS_HANDLE CallMgrSapContext
        );

    static NDIS_STATUS CmDeregisterSap(IN NDIS_HANDLE CallMgrSapContext);
        
    static NDIS_STATUS CmCloseAf(IN NDIS_HANDLE CallMgrAfContext);

    static NDIS_STATUS CmRequest(
        IN NDIS_HANDLE              ProtocolAfContext,
        IN CBChannel                *pBChannel OPTIONAL, 
        IN NDIS_HANDLE              ProtocolPartyContext OPTIONAL, 
        IN OUT  PNDIS_REQUEST       NdisRequest
        );
        
    static VOID CmRequestComplete(
        IN NDIS_STATUS              Status,
        IN NDIS_HANDLE              ProtocolAfContext OPTIONAL,
        IN CBChannel                *pBChannel        OPTIONAL, 
        IN NDIS_HANDLE              ProtocolPartyContext OPTIONAL, 
        IN OUT  PNDIS_REQUEST       NdisRequest
        );
        
private:
    NDIS_STATUS ReadConfiguration(KNdisConfig& Config);
    NDIS_STATUS CreateObjects(KNdisConfig& Config);
    VOID DestroyObjects();

private:
    ///////////////////////////////////////////////////////////////////
	// Your custom data members go in here

    // A representation of a physical card object.
    CCard *m_pCard;
    
    // Spin Locks needed to serialize access to various queues of the adapter
    KNdisSpinLock m_TransmitLock;

    // Packets waiting to be sent when the controller is available.
    KNdisInterlockedPacketList m_TransmitPendingList;
    // Packets waiting for completion processing.  After the packet is
    // transmitted, the protocol stack is given an indication.
    KNdisInterlockedPacketList m_TransmitCompleteList;
    // Buffers waiting to be processed by the protocol stack
    KNdisInterlockedPacketList m_ReceiveCompleteList;
    
    // This timer is used to schedule the event processing routine to run
    // when the system reaches a quiescent state.
    KNDIS_DECLARE_TIMER(CoIsdnAdapter, OnTimer) m_EventTimer;
    
    // Pointer to the adpator's DChannel object. One for the entire NIC
    CDChannel *m_pDChannel;

    // A vector of BChannels exposed by the adaptor
    vector<CBChannel*> m_BChannelVector;
    // A linked list of availabe BChannels
    KNdisInterlockedList<CBChannel> m_BChannelAvailableList;

    NDIS_WAN_CO_INFO m_WanInfo;                    // @field
    // A copy of our NDIS_WAN_CO_INFO structure is setup at init
    // time and doesn't change.
    
    // The address family handle associated with the single TAPI
    //AF registered with NDIS.
    NDIS_HANDLE m_NdisAfHandle;

    // Keeps track of the number of active events that need to be handled
    LONG m_EventHandlingDepth;

    //////////////////////////////////////////////////////////////////
    // Wizard-generated members
    ETHERNET_ADDRESS m_CurrentAddress;
	ETHERNET_ADDRESS m_PermanentAddress;

    // NDIS_PACKET_TYPE_xxx bit set 
    ULONG			m_uPacketFilter;
    
    // NDIS_MAC_OPTION_xxx bit set
    ULONG			m_uMacOptions;

    // Queue of "pending" Tx packets. Serialized miniports might use
	// this queue to keep track of "pending" packets. Deserialized miniports 
	// have to maintain  an internal queue to cope with low resource situations
	// since NDIS doesn't take care of that in this case.
	KNdisPacketList	m_TxQueue;

	// Statistics. Included are the statistics defined by NDIS statistics OIDs
	KNdisStatsGen m_GenStats;		// Mandatory GENeral stats
	// KNdisStatsGenEx					m_GenStats;		// Optional GENeral stats
	KNdisStatsEx<COISDN_MEDIUM_TYPE> m_MediumStats;	// Medium-specific stats

	// Power Management State
#if KNDIS_PNP_AWARE
	KNdisPnpMode<CoIsdnAdapter>		m_Power;
#endif

	// TODO: Add Low-level control for your "NIC"

};



#endif // !defined(AFX_COISDNADAP_H__8534F9A9_27F5_11D3_8F9E_00C04F7445B7__INCLUDED_)
