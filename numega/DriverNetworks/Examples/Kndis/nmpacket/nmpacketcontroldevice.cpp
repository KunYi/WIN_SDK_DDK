// NmPacketControlDevice.cpp
// Implementation of NmPacketControlDevice device class
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03060  USA
//
// Copyright (c) 2001 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================
//
// Generated by DriverWizard version DriverStudio 2.0.0 (Build 4409)
// Requires Compuware's DriverWorks classes
//

#include <vdw.h>

#include "NmPacket.h"
#include "NmPacketControlDevice.h"
#include "NmPacketioctl.h"
#include "NmPacketBinding.h"

#pragma warning(disable:4065) // Allow switch statement with no cases

extern	KTrace	t;			// Global driver trace object	

////////////////////////////////////////////////////////////////////////
// NmPacketControlDevice::~NmPacketControlDevice
//
//	Routine Description:
//		This is the destructor for the NmPacketControlDevice
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		Disconnect and release resources here.
//
//		Although the use of SAFE_DESTRUCTORS in the class definition cures
//		improper emission of the destructor into the INIT section most of the
//		time, certain rare cases can still cause improper behavior.  To avoid
//		these cases, the destructor	must preceed the INIT section, causing it
//		to be referenced first by the default compiler section.
//

NmPacketControlDevice::~NmPacketControlDevice()
{
	delete m_RegPath;
}

#pragma code_seg("INIT")

////////////////////////////////////////////////////////////////////////////////
//  NmPacketControlDevice::NmPacketControlDevice
//
//	Routine Description:
//		The device constructor is typically responsible for allocating
//		any physical resources that are associated with the device.
//
//	Parameters:
//		None
//
//	Return Value:
//		None
//
//	Comments:
//		The device constructor often reads the registry to setup
//		various configurable parameters.

NmPacketControlDevice::NmPacketControlDevice() :
	KDevice()
{
	if ( ! NT_SUCCESS(m_ConstructorStatus) )
	{
		t << "Failed to create device NmPacketControlDevice, err"  << (ULONG) m_ConstructorStatus << EOL;
		return;
	}

	m_RegPath = CreateRegistryPath(L"NmPacketControlDevice", 0);
	if (m_RegPath == NULL)
	{
		// Error, cannot allocate memory for registry path
		t << "Failed to create registry path\n";
		m_ConstructorStatus = STATUS_INSUFFICIENT_RESOURCES;
		return;
	}

}
#pragma code_seg()


////////////////////////////////////////////////////////////////////////
//  NmPacketControlDevice::DeviceControl
//
//	Routine Description:
//		Handler for IRP_MJ_DEVICE_CONTROL
//
//	Parameters:
//		I - Current IRP
// 
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//		This routine is the first handler for Device Control requests.

NTSTATUS NmPacketControlDevice::DeviceControl(KIrp I) 
{
	NTSTATUS status;

	t << "Entering NmPacketControlDevice::Device Control, " << I;
	switch (I.IoctlCode())
	{
		case IOCTL_ENUM_ADAPTERS:
		    status = IOCTL_ENUM_ADAPTERS_Handler(I);
			break;

		default:
			// Unrecognized IOCTL request
			status = STATUS_INVALID_PARAMETER;
			break;
	}

	// If the IRP's IOCTL handler deferred processing using some driver
	// specific scheme, the status variable is set to STATUS_PENDING.
	// In this case we simply return that status, and the IRP will be
	// completed later.  Otherwise, complete the IRP using the status
	// returned by the IOCTL handler.
	if (status == STATUS_PENDING)
	{
		return status;
	}
	else
	{
		return I.Complete(status);
	}
}

////////////////////////////////////////////////////////////////////////
//  NmPacketControlDevice::IOCTL_ENUM_ADAPTERS_Handler
//
//	Routine Description:
//		Handler for IO Control Code IOCTL_ENUM_ADAPTERS
//
//	Parameters:
//		I - IRP containing IOCTL request
//
//	Return Value:
//		NTSTATUS - Status code indicating success or failure
//
//	Comments:
//		Returns a list of adapter names into the supplied buffer
//
NTSTATUS NmPacketControlDevice::IOCTL_ENUM_ADAPTERS_Handler(KIrp I)
{
	t << "Entering NmPacketControlDevice::IOCTL_ENUM_ADAPTERS_Handler, " << I << EOL;

	ULONG Written;
	NTSTATUS status = GetAdapterList
			(I.IoctlBuffer(), I.IoctlOutputBufferSize(), &Written);

	I.Information() = Written;

	return status;
}

////////////////////////////////////////////////////////////////////////
//  NmPacketControlDevice::Cleanup
//
//	Routine Description:
//		Handler for IRP_MJ_CLEANUP	
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS	Result code
//
//	Comments:
//

NTSTATUS NmPacketControlDevice::CleanUp(KIrp I)
{
	t << "Entering CleanUp, " << I;

// TODO:	Insert your code to respond to the CLEANUP message.
	return I.Complete(STATUS_SUCCESS);
}


////////////////////////////////////////////////////////////////////////
//  NmPacketControlDevice::Create
//
//	Routine Description:
//		Handler for IRP_MJ_CREATE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS NmPacketControlDevice::Create(KIrp I)
{
	t << "Entering Create, " << I;
	I.Information() = 0;
	return I.Complete(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  NmPacketControlDevice::Close
//
//	Routine Description:
//		Handler for IRP_MJ_CLOSE
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS - Result code
//
//	Comments:
//

NTSTATUS NmPacketControlDevice::Close(KIrp I)
{
	t << "Entering Close, " << I;
	I.Information() = 0;
	return I.Complete(STATUS_SUCCESS);
}

////////////////////////////////////////////////////////////////////////
//  NmPacketControlDevice::Shutdown
//
//	Routine Description:
//		Handler for IRP_MJ_SHUTDOWN
//
//	Parameters:
//		I - Current IRP
//
//	Return Value:
//		NTSTATUS	Result code	
//
//	Comments:
//

NTSTATUS NmPacketControlDevice::Shutdown(KIrp I)
{
	t << "Entering Shutdown\n";
// TODO:	Insert SHUTDOWN code

   return I.Complete(STATUS_SUCCESS);
}


///////////////////////////////////////////////////////////////////////
// Retrieves adapter list for existing bindings
//
// Parameters:
// 	Buffer               - input buffer to write the binding info
// 	Length               - length of this buffer
// 	DataLength           - output pointer for total length written (or required)
// Returns:
// 	Status of opertion
// Comments:
//	Format of the buffer for IOCTL_ENUM_ADAPTERS (as per the DDK sample):
//  <NumOfAdapters><FriendlyAdapterName>0<DeviceSymLink>0
//      ULONG         WCHAR[]              WCHAR[]
//	This format is used by the app...
// 
NTSTATUS NmPacketControlDevice::GetAdapterList(PVOID Buffer, ULONG Length, PULONG DataLength)
{
	// Set length available for strings following the ULONG NumOfAdapters

	Length = (Length < sizeof(ULONG)) ? 0 : Length - sizeof(ULONG);

	// Initialize parameters of the copy

	NodeCopier::Parameters params(PCHAR(Buffer)+sizeof(ULONG), Length);

	// Process the list. Note the list's spinlock is held while processing

	KListBrowser<NmPacketBinding>::ForEach
				(NmPacketBinding::m_BindingList, NodeCopier(params));

	// Check the results and return status

	*DataLength = params.required + sizeof(ULONG);	

	if (params.required > params.total || Length == 0)
		return STATUS_BUFFER_TOO_SMALL;
	else 
		*PULONG(Buffer) = params.NumOfNodes;

	t << "NmPacketControlDevice::GetAdapterList() " << params.NumOfNodes << " found" << EOL;

	return STATUS_SUCCESS;
}


///////////////////////////////////////////////////////////////////////
// Function operator called by KListBrowser. Copies adapter name
// and symlink into buffer supplied on construction and maintains
// the number of successfully processed nodes
//
// Parameters:
// 	b		-	Binding object the function is called for
// Returns:
// 	none
// Comments:
// 	Called by ForEach() to copy the adapter name and symlink
//  to the buffer described by data member 'state'.
//
// Note: Whan building the driver for NT4.0 with NDIS 4.0, the
//		 Symbolic name is returned to the TestApp. GetAdapterName 
//		 is not a supported funtion in NDIS 4.0.
void NmPacketControlDevice::NodeCopier::operator() (NmPacketBinding* b) {
	ULONG n, m, l;
	n = b->GetAdapterNameString().Size() + sizeof(UNICODE_NULL);
	m = b->GetSymLink()->Length + sizeof(UNICODE_NULL);
#if	defined(NDIS40)
	l = m<<1;
#else
	l = n + m;
#endif
	state.required += l;
	if (l <= state.avail) {
#if	defined(NDIS40)
		memcpy(state.buf, b->GetSymLink()->Buffer, m); 
		state.buf+=m;
#else
		memcpy(state.buf, b->GetAdapterName(), n); 
		state.buf+=n;
#endif
		memcpy(state.buf, b->GetSymLink()->Buffer, m); 
		state.buf+=m;
		state.avail -= l;
		++state.NumOfNodes;
	}
} 
	



