// KNdisProtocolWrapper.h: interface for the KNdisProtocolWrapper class.
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03063  USA
//
// Copyright (c) 2004 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================

#if !defined(AFX_KNDISPROTOCOLWRAPPER_H__819D9676_9135_11D3_9001_00C04F7445B7__INCLUDED_)
#define AFX_KNDISPROTOCOLWRAPPER_H__819D9676_9135_11D3_9001_00C04F7445B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////
// KNdisProtocolWrapper
//
// A template class that maps native NDIS callbacks into method invokations
// on KNdisProtocolBinding-derived objects. This class has no dynamic instances;
// Its static methods are instantiated by means of references to them
// in Characteristics.h, which is generated by the Wizard.
//
// KNdisProtocolWrapper also acts as a factory of KNdisProtocolBinding-derived
// objects. The Open() method creates binding objects and Close() destroys them.
//
// Parameters:
//
//		Binding			Binding class publicly derived from KNdisProtocolBinding.
//						Appropriate handler methods must be defined for this class.
//
// NOTE Although the class declares ALL known NDIS 4 and 5 handlers, only those
//		referenced in Characteristics.h will get expanded into real code.
//
template<class Binding>
class KNdisProtocolWrapper
{
public:
	// called directly from NDIS: protocol handlers

		// 3.0+
	static VOID OpenAdapterComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_STATUS				Status,
		IN	NDIS_STATUS				OpenErrorStatus
		);

	static VOID CloseAdapterComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_STATUS				Status
		);

	static VOID ResetComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_STATUS				Status
		);

	static VOID RequestComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	PNDIS_REQUEST			NdisRequest,
		IN	NDIS_STATUS				Status
		);

	static VOID Status(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_STATUS				GeneralStatus,
		IN	PVOID					StatusBuffer,
		IN	UINT					StatusBufferSize
		);

	static VOID StatusComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext
		);

	static VOID SendComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	PNDIS_PACKET			Packet,
		IN	NDIS_STATUS				Status
		);

	static VOID WanSendComplete (
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	PNDIS_WAN_PACKET		Packet,
		IN	NDIS_STATUS				Status
		);

	static VOID TransferDataComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	PNDIS_PACKET			Packet,
		IN	NDIS_STATUS				Status,
		IN	UINT					BytesTransferred
		);

	static VOID WanTransferDataComplete(
		VOID
	    );

	static NDIS_STATUS Receive(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_HANDLE				MacReceiveContext,
		IN	PVOID					HeaderBuffer,
		IN	UINT					HeaderBufferSize,
		IN	PVOID					LookAheadBuffer,
		IN	UINT					LookaheadBufferSize,
		IN	UINT					PacketSize
		);

	static NDIS_STATUS WanReceive(
		IN	NDIS_HANDLE				NdisLinkHandle,
		IN	PUCHAR					Packet,
		IN	ULONG					PacketSize
	    );

	static VOID ReceiveComplete(
		IN	NDIS_HANDLE				ProtocolBindingContext
		);

	// 4.0+
	static INT ReceivePacket(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	PNDIS_PACKET			Packet
		);

	static VOID Bind(
		OUT	PNDIS_STATUS			Status,
		IN	NDIS_HANDLE				BindContext,
		IN	PNDIS_STRING			DeviceName,
		IN	PVOID					SystemSpecific1,
		IN	PVOID					SystemSpecific2
		);

	static VOID Unbind(
		OUT	PNDIS_STATUS			Status,
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_HANDLE				UnbindContext
		);

	#if KNDIS_PNP_AWARE
	static NDIS_STATUS PnpEvent(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	PNET_PNP_EVENT			NetPnPEvent
		);
	#endif

	static VOID Unload(
		VOID
		);

	// 5.0+
	static VOID CoSendComplete(
		IN	NDIS_STATUS				Status,
		IN	NDIS_HANDLE				ProtocolVcContext,
		IN	PNDIS_PACKET			Packet
		);

	static VOID CoStatus(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
		IN	NDIS_STATUS				GeneralStatus,
		IN	PVOID					StatusBuffer,
		IN	UINT					StatusBufferSize
		);

	static UINT CoReceivePacket(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	NDIS_HANDLE				ProtocolVcContext,
		IN	PNDIS_PACKET			Packet
		);

	static NDIS_STATUS CoRequest(
		IN	NDIS_HANDLE				ProtocolAfContext,
		IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
		IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
		IN OUT PNDIS_REQUEST		NdisRequest
		);

	static VOID CoRequestComplete(
		IN	NDIS_STATUS				Status,
		IN	NDIS_HANDLE				ProtocolAfContext		OPTIONAL,
		IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
		IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
		IN	PNDIS_REQUEST			NdisRequest
		);

	static NDIS_STATUS CoCreateVc(
		IN	NDIS_HANDLE				ProtocolAfContext,
		IN	NDIS_HANDLE				NdisVcHandle,
		OUT	PNDIS_HANDLE			ProtocolVcContext
		);

	static NDIS_STATUS CoDeleteVc(
		IN	NDIS_HANDLE				ProtocolVcContext
		);

	static VOID CoAfRegisterNotify(
		IN	NDIS_HANDLE				ProtocolBindingContext,
		IN	PCO_ADDRESS_FAMILY		AddressFamily
		);

protected:
	// Internal helper methods

	// Signaling bidning's synchronization method. Note that for
	// ResetComplete() and RequestComplete() both the event is set
	// and the callback is called. Thus, it is assumed
	// the driver uses one or another. Currently, it is not customizable

	static Binding* ptSignalCompletion(NDIS_HANDLE ProtocolBindingContext, NDIS_STATUS Status)
	{
		Binding* b = reinterpret_cast<Binding*>(ProtocolBindingContext);
		if (_KNDIS::IsValid(b))
		{
			b->SignalCompletion(Status);
			return b;
		}
		else
		{
			ASSERT(!"IsValid");
			return NULL;
		}
	}
}; // KNdisProtocolWrapper

/////////////////////////////////////////////////////////////////////////////////////////////
// Implementations

// 3.0+
template <class B> VOID KNdisProtocolWrapper<B>::OpenAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status,
	IN	NDIS_STATUS				OpenErrorStatus
	)
{
	ptSignalCompletion(ProtocolBindingContext, Status);
	UNREFERENCED_PARAMETER(OpenErrorStatus);
}

template <class B> VOID KNdisProtocolWrapper<B>::CloseAdapterComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	if (_KNDIS::IsValid(b))
	{
		b->SetBound(false);
		b->SignalCompletion(Status); // Signal to the waiting Unbind() thread
	}
}


template <class B> VOID KNdisProtocolWrapper<B>::ResetComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				Status
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	if (_KNDIS::IsValid(b))
		b->ResetComplete(Status);
	ptSignalCompletion(ProtocolBindingContext, Status);
}


template <class B> VOID KNdisProtocolWrapper<B>::RequestComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_REQUEST			NdisRequest,
	IN	NDIS_STATUS				Status
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	if (_KNDIS::IsValid(b))
		b->RequestComplete(NdisRequest, Status);
	ptSignalCompletion(ProtocolBindingContext, Status);
}

template <class B> VOID KNdisProtocolWrapper<B>::StatusComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	if (_KNDIS::IsValid(b))
		b->StatusComplete();
}


template <class B> VOID KNdisProtocolWrapper<B>::SendComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet,
	IN	NDIS_STATUS				Status
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	ASSERT(_KNDIS::IsValid(b));
	b->SendComplete(Packet, Status);
}


template <class B> VOID KNdisProtocolWrapper<B>::WanSendComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_WAN_PACKET		Packet,
	IN	NDIS_STATUS				Status
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	ASSERT(_KNDIS::IsValid(b));
	b->SendComplete(Packet, Status);
}


template <class B> VOID KNdisProtocolWrapper<B>::TransferDataComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet,
	IN	NDIS_STATUS				Status,
	IN	UINT					BytesTransferred
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	ASSERT(_KNDIS::IsValid(b));
	b->TransferDataComplete(Packet, Status, BytesTransferred);
}


template <class B> VOID KNdisProtocolWrapper<B>::WanTransferDataComplete(
	VOID
    )
{
	// ??? context ???
}

template <class B> VOID KNdisProtocolWrapper<B>::Status(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	)
{
	// consider: splitting based on GeneralStatus
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	if (_KNDIS::IsValid(b))
		b->StatusIndication(GeneralStatus, StatusBuffer, StatusBufferSize);
	else ASSERT(!"IsValid");

}

template <class B> NDIS_STATUS KNdisProtocolWrapper<B>::Receive(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				MacReceiveContext,
	IN	PVOID					HeaderBuffer,
	IN	UINT					HeaderBufferSize,
	IN	PVOID					LookAheadBuffer,
	IN	UINT					LookaheadBufferSize,
	IN	UINT					PacketSize
	)
{
	// Check if there is an associated packet for this indication.
	// If there is, delegete to the packet receive handler, otherwise
	// delegate to partial receive handler
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	ASSERT (_KNDIS::IsValid(b));
	NDIS_STATUS Status;
#if (defined(NDIS50) || defined(NDIS51))
	PNDIS_PACKET pkt = NdisGetReceivedPacket(*b, MacReceiveContext);
	if (pkt)
	{
		Status = ( b->Receive(pkt) ) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_NOT_ACCEPTED;
	}
	else
#endif
	{
		// Do partial. If a packet pointer is provided on the output, initiate
		// transfer into this packet.
		KNdisPartialPacket partial(MacReceiveContext);

		Status = b->Receive(partial,
			HeaderBuffer,
			HeaderBufferSize,
			LookAheadBuffer,
			LookaheadBufferSize,
			PacketSize);

		// If the client provided a valid packet transfer the data right away
		if (Status==NDIS_STATUS_SUCCESS && partial.IsValid())
		{
			UINT BytesTransferred;

			NdisTransferData(
				&Status,
				(NDIS_HANDLE)*b,
				MacReceiveContext,
				partial.ByteOffset(),
				partial.BytesToTransfer(),
				partial,
				&BytesTransferred);

			if (Status != NDIS_STATUS_PENDING) // simulate completion
				b->TransferDataComplete(partial, Status, BytesTransferred);
			else; // the wrapper handler will be called
		}
	}
	return Status;
}


template <class B> NDIS_STATUS KNdisProtocolWrapper<B>::WanReceive(
	IN	NDIS_HANDLE				NdisLinkHandle,
	IN	PUCHAR					Packet,
	IN	ULONG					PacketSize
    )
{
	// TODO //
}

template <class B> VOID KNdisProtocolWrapper<B>::ReceiveComplete(
	IN	NDIS_HANDLE				ProtocolBindingContext
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	ASSERT(_KNDIS::IsValid(b));
	b->ReceiveComplete();
}

//////////////////////////////////////////////////////
// 4.0+

// Bind():		New NIC is available
template <class B> VOID KNdisProtocolWrapper<B>::Bind(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				BindContext,
	IN	PNDIS_STRING			DeviceName,
	IN	PVOID					SystemSpecific1,
	IN	PVOID					SystemSpecific2
	)
{

	// Instantiate binding object
	B*	b = KNdisProtocolTraits<B>::CreateInstance();
	if (!b)
	{
		*Status = NDIS_STATUS_RESOURCES;
		return;
	}

	// Construct protocol config and empty medium objects. Note SystemSpecific1 is
	// a "protocol section" name in the Registry. Then pass control to client's Open()
	KNdisConfig		Config( reinterpret_cast<PNDIS_STRING> (SystemSpecific1) );
	KNdisMedium		Medium;
	PSTRING			AddressInfo=NULL;

	NDIS_STATUS sts_ex;
	NDIS_STATUS sts = b->Open(DeviceName, Config, Medium, &AddressInfo);
	if (sts != NDIS_STATUS_SUCCESS)
	{
		*Status = sts;					// protocol decided not to bind, bail out
		delete b;
		return;
	}

	// Nice going. Try to open the adapter in question.
	// Note that 'B' must provide GetContainerHandle() method, which returns
	// protocol handle assigned on NdisRegisterProtocol().

	NdisOpenAdapter(&sts,
		  			&sts_ex,					// extended err code if any
		  			b->HandlePTR(),				// cached handle value to be assigned
		  			(PUINT)PNDIS_MEDIUM(*b),	// cached medium index to be selected
		  			Medium,
		  			Medium.Size(),
		  			b->GetContainerHandle(),	// protocol handle
		  			b,							// 'this' we want to get in all consequitive callbacks
		  			DeviceName,
		  			0,							// reserved
		  			AddressInfo					// optional
					);

	if (sts == NDIS_STATUS_PENDING)
	{
		b->WaitForCompletion();					// OK, wait until it's done
		sts = *PNDIS_STATUS(*b);				// retrieve the result
	}
	else
		*PNDIS_STATUS(*b) = sts;				// save status in the object

	if (sts == NDIS_STATUS_SUCCESS)
	{
		// Now, cache the adapter's friendly name, if we're set to do so
		if (KNdisProtocolTraits<B>::CacheFriendlyAdapterName())
			b->GetAdapterName();
		b->SetBound(true);
	}

	// Inform the client on completion. If it was unsuccessful the binding object is destroyed.
	b->OpenComplete();
	*Status = sts = *PNDIS_STATUS(*b); // retrieve the status of open complete operation

	if (sts != NDIS_STATUS_SUCCESS)
	{
		// ASSERT(!"NdisOpenAdapter");				// eg medium type mismatch
		delete b;
		return;
	}

	// OK. Turn medium index into medium type
	*PNDIS_MEDIUM(*b) = Medium [*(PUINT)PNDIS_MEDIUM(*b)];

	UNREFERENCED_PARAMETER(SystemSpecific2);
}

template <class B> VOID KNdisProtocolWrapper<B>::Unbind(
	OUT	PNDIS_STATUS			Status,
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				UnbindContext
	)
{

	// Inform the client that the bound adapter or binding is going away.
	// Then close the adapter and delete the object

	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	if (_KNDIS::IsValid(b))
	{
		if (ProtocolBindingContext != UnbindContext) // heuristic to check if it's simulated vs NDIS initiated
			b->SetBound(false);					 // real: set it off
		BOOLEAN bDelete = b->Close();
		if (bDelete)
		{
			b->CloseAdapter();		// synchronous!
			delete b;
		}
	}
	else ASSERT(!"IsValid");
	*Status = NDIS_STATUS_SUCCESS;

	// Note: The framework always returns synchronously from this callback.
	// If this is to be changed, we will have to cache UnbindContext and use
	// it in NdisCompleteUnbindAdapter() when ProtocolAdapterCloseComplete is called.
	// (TBD)

	UNREFERENCED_PARAMETER(UnbindContext);
}

template <class B> INT KNdisProtocolWrapper<B>::ReceivePacket(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNDIS_PACKET			Packet
	)
{
	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	ASSERT (_KNDIS::IsValid(b));
	return b->Receive(Packet);
}

#if KNDIS_PNP_AWARE
template <class B> NDIS_STATUS KNdisProtocolWrapper<B>::PnpEvent(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PNET_PNP_EVENT			NetPnPEvent
	)
{
	// Split into PnP event types and delegate.
	// NOTE some PnP events has no associated context (system-wide)

	B* b = reinterpret_cast<B*>(ProtocolBindingContext);
	NET_PNP_EVENT_CODE event = NetPnPEvent->NetEvent;

	if (_KNDIS::IsValid(b))
	{	// this binding's targeted event
		switch (event)
		{
		case NetEventSetPower:
			return b->OnPnpSetPower(*(PNDIS_DEVICE_POWER_STATE)NetPnPEvent->Buffer, NetPnPEvent);
		case NetEventQueryPower:
			return b->OnPnpQueryPower(*(PNDIS_DEVICE_POWER_STATE)NetPnPEvent->Buffer, NetPnPEvent);
		case NetEventQueryRemoveDevice:
			return b->OnPnpQueryRemoveDevice(NetPnPEvent);
		case NetEventCancelRemoveDevice:
			return b->OnPnpCancelRemoveDevice(NetPnPEvent);
		case NetEventReconfigure:
			return b->OnPnpReconfigure((PCWSTR)NetPnPEvent->Buffer, NetPnPEvent);
		case NetEventPnPCapabilities:
			return b->OnPnpCapabilityChange(*(PULONG)NetPnPEvent->Buffer, NetPnPEvent);
		default:
			break;
		}
	}
	else
	{	// system-wide event: call static
		switch (event)
		{
		case NetEventReconfigure:
			return B::OnPnpReconfigureGlobal((PCWSTR)NetPnPEvent->Buffer, NetPnPEvent);
		case NetEventBindList:
			return B::OnPnpBindListChange((PCWSTR)NetPnPEvent->Buffer, NetPnPEvent);
		case NetEventBindsComplete:
			return B::OnPnpBindListComplete(NetPnPEvent);
		default:
			break;
		}
	}

	ASSERT(!"NetEvent");
	return NDIS_STATUS_SUCCESS;
}
#endif // KNDIS_PNP_AWARE

template <class B> VOID KNdisProtocolWrapper<B>::Unload(
	VOID
	)
{
	// TODO: Need to do housekeeping. Destroy existing bindings? Shouldn't the
	//		 system do it first before unload? Have to walk trhu the list and
	//		 call Close() on each binding. Don't have to have Unload() method on 'B'.
}

#ifdef DO_CO_STUFF
// 5.0+
template <class B> VOID KNdisProtocolWrapper<B>::CoSendComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	)
{
}

template <class B> VOID KNdisProtocolWrapper<B>::CoStatus(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext	OPTIONAL,
	IN	NDIS_STATUS				GeneralStatus,
	IN	PVOID					StatusBuffer,
	IN	UINT					StatusBufferSize
	)
{
}

template <class B> UINT KNdisProtocolWrapper<B>::CoReceivePacket(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	NDIS_HANDLE				ProtocolVcContext,
	IN	PNDIS_PACKET			Packet
	)
{
}

template <class B> NDIS_STATUS KNdisProtocolWrapper<B>::CoRequest(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN OUT PNDIS_REQUEST		NdisRequest
	)
{
}

template <class B> VOID KNdisProtocolWrapper<B>::CoRequestComplete(
	IN	NDIS_STATUS				Status,
	IN	NDIS_HANDLE				ProtocolAfContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolVcContext		OPTIONAL,
	IN	NDIS_HANDLE				ProtocolPartyContext	OPTIONAL,
	IN	PNDIS_REQUEST			NdisRequest
	)
{
}

template <class B> NDIS_STATUS KNdisProtocolWrapper<B>::CoCreateVc(
	IN	NDIS_HANDLE				ProtocolAfContext,
	IN	NDIS_HANDLE				NdisVcHandle,
	OUT	PNDIS_HANDLE			ProtocolVcContext
	)
{
}

template <class B> NDIS_STATUS KNdisProtocolWrapper<B>::CoDeleteVc(
	IN	NDIS_HANDLE				ProtocolVcContext
	)
{
}

template <class B> VOID KNdisProtocolWrapper<B>::CoAfRegisterNotify(
	IN	NDIS_HANDLE				ProtocolBindingContext,
	IN	PCO_ADDRESS_FAMILY		AddressFamily
	)
{
}

#endif // DO_CO_STUFF

#endif // !defined(AFX_KNDISPROTOCOLWRAPPER_H__819D9676_9135_11D3_9001_00C04F7445B7__INCLUDED_)
