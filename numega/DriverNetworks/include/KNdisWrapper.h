// KNdisWrapper.h: interface for the KNdisWrapper class.
//=============================================================================
//
// Compuware Corporation
// NuMega Lab
// 9 Townsend West
// Nashua, NH 03063  USA
//
// Copyright (c) 2004 Compuware Corporation. All Rights Reserved.
// Unpublished - rights reserved under the Copyright laws of the
// United States.
//
//=============================================================================

#if !defined(AFX_KNDISWRAPPER_H__01CA4644_2339_11D3_8F9D_00C04F7445B7__INCLUDED_)
#define AFX_KNDISWRAPPER_H__01CA4644_2339_11D3_8F9D_00C04F7445B7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////
// KNdisWrapper
//
// A template class that maps native NDIS callbacks into method invokations
// on KNdisMiniAdapter-derived objects. This class has no dynamic instances;
// Its static methods are instantiated by means of references to them
// in Characteristics.h, which is generated by the Wizard.
//
// KNdisWrapper also acts as a factory of KNdisMiniAdapter-derived objects.
// The Initialize() method creates adapter objects and Halt() destroys them.
//
// Parameters
//
//		Adapter			KNdisMiniAdapter-derived class with appropriate
//						methods defined.
//
// NOTE Although the class declares ALL known NDIS 4 and 5 handlers, only those
//		referenced in Characteristics.h will get expanded into real code.
//
template<class Adapter>
class KNdisWrapper
{
public:
	// called directly from NDIS: miniport handlers
    static BOOLEAN CheckForHang(IN NDIS_HANDLE MiniportAdapterContext);
    static VOID DisableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);
    static VOID EnableInterrupt(IN NDIS_HANDLE MiniportAdapterContext);
    static VOID Halt(IN NDIS_HANDLE MiniportAdapterContext);
    static VOID HandleInterrupt(IN NDIS_HANDLE MiniportAdapterContext);
    static NDIS_STATUS Initialize(
			OUT PNDIS_STATUS			OpenErrorStatus,
			OUT PUINT					SelectedMediumIndex,
			IN	PNDIS_MEDIUM			MediumArray,
			IN	UINT					MediumArraySize,
			IN	NDIS_HANDLE				MiniportAdapterHandle,
			IN	NDIS_HANDLE				WrapperConfigurationContext
			);
    static VOID Isr(
			OUT PBOOLEAN				InterruptRecognized,
			OUT PBOOLEAN				QueueMiniportHandleInterrupt,
			IN	NDIS_HANDLE				MiniportAdapterContext
			);
    static NDIS_STATUS QueryInformation(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesWritten,
			OUT PULONG					BytesNeeded
			);
    static NDIS_STATUS Reconfigure(
			OUT PNDIS_STATUS			OpenErrorStatus,
			IN	NDIS_HANDLE				MiniportAdapterContext	OPTIONAL,
			IN	NDIS_HANDLE				WrapperConfigurationContext
			);
    static NDIS_STATUS Reset(
			OUT PBOOLEAN				AddressingReset,
			IN	NDIS_HANDLE				MiniportAdapterContext
			);
    static NDIS_STATUS Send(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PNDIS_PACKET			Packet,
			IN	UINT					Flags
			);
    static NDIS_STATUS SetInformation(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesRead,
			OUT PULONG					BytesNeeded
			);
    static NDIS_STATUS TransferData(
			OUT PNDIS_PACKET			Packet,
			OUT PUINT					BytesTransferred,
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				MiniportReceiveContext,
			IN	UINT					ByteOffset,
			IN	UINT					BytesToTransfer
			);

	// NOTE: In NDIS 5.0 this function is registered via NdisMRegisterAdapterShutdownHandler.
	//       In NDIS 5.1+ it's done via the characteristics table.
	static void Shutdown(
			PVOID ShutdownContext);


	// Miniports V4.0 or V5.0
    static VOID ReturnPacket(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PNDIS_PACKET			Packet
			);
    static VOID SendPackets(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PPNDIS_PACKET			PacketArray,
			IN	UINT					NumberOfPackets
			);
    static VOID AllocateComplete(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PVOID					VirtualAddress,
			IN	PNDIS_PHYSICAL_ADDRESS	PhysicalAddress,
			IN	ULONG					Length,
			IN	PVOID					Context
			);

#if NDIS_WDM
	// Default completion routines delegators for NDIS WDM drivers
	static NTSTATUS __stdcall WdmCompletionTxRoutine(PDEVICE_OBJECT, PIRP pIrp, PVOID context);
	static NTSTATUS __stdcall WdmCompletionRxRoutine(PDEVICE_OBJECT, PIRP pIrp, PVOID context);
#endif

	// WAN Miniports
	static NDIS_STATUS WanSend(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				NdisLinkHandle,
			IN	PNDIS_WAN_PACKET		Packet
			);
    static NDIS_STATUS WanTransferData(VOID);

	// Co Miniports (NDIS 5)
	// NOTE: Create and Delete are not called for miniport with an
	// integrated MCM, so they should not be supplied in characteristics.
    static NDIS_STATUS CoCreateVc(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				NdisVcHandle,
			OUT	PNDIS_HANDLE			MiniportVcContext
			);
    static NDIS_STATUS CoDeleteVc(
			IN	NDIS_HANDLE				MiniportVcContext
			);
    static NDIS_STATUS CoActivateVc(
			IN	NDIS_HANDLE				MiniportVcContext,
			IN OUT PCO_CALL_PARAMETERS	CallParameters
			);
    static NDIS_STATUS CoDeactivateVc(
			IN	NDIS_HANDLE				MiniportVcContext
			);
    static VOID CoSendPackets(
			IN	NDIS_HANDLE				MiniportVcContext,
			IN	PPNDIS_PACKET			PacketArray,
			IN	UINT					NumberOfPackets
			);
    static NDIS_STATUS CoRequest(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				MiniportVcContext	OPTIONAL,
			IN OUT PNDIS_REQUEST		NdisRequest
			);

#if (KNDIS_DDK_VERSION > 5)
	// V5.1
	static VOID PnPEventNotify(
			IN NDIS_HANDLE  MiniportAdapterContext,
			IN NDIS_DEVICE_PNP_EVENT  PnPEvent,
			IN PVOID  InformationBuffer,
			IN ULONG  InformationBufferLength
		    );
	static VOID CancelSendPackets(
			IN NDIS_HANDLE  MiniportAdapterContext,
			IN PVOID	CancelId
			);
#endif // (KNDIS_DDK_VERSION > 5)
};


//////////////////////////////////////////////////////////////////////
// KNdisWrapper Implementations
//#pragma code_seg("INIT")
template<class A>
NDIS_STATUS KNdisWrapper<A>::Initialize(
			OUT PNDIS_STATUS			OpenErrorStatus,
			OUT PUINT					SelectedMediumIndex,
			IN	PNDIS_MEDIUM			MediumArray,
			IN	UINT					MediumArraySize,
			IN	NDIS_HANDLE				MiniportAdapterHandle,
			IN	NDIS_HANDLE				WrapperConfigurationContext
			)
{
	// First NDIS callback for the adapter; time to create an instance
	// The "factory" is provided by the user framework:

	KNdisMedium Medium(MediumArray, MediumArraySize);
	KNdisConfig Config(WrapperConfigurationContext);
	KNdisMiniAdapter* adapter = KNdisAdapterTraits<A>::CreateInstance(Medium, Config);
	if (!adapter)
		return NDIS_STATUS_FAILURE;
	// assign the NDIS handle
	adapter->Assign(MiniportAdapterHandle);
	// make sure it's constructed properly
	ASSERT(_KNDIS::IsValid(adapter));
	// cast is safe here since A is a subclass of KNdisMiniAdapter
	NDIS_STATUS status = reinterpret_cast<A*>
		(adapter)->Initialize(Medium, Config);
	if (status != NDIS_STATUS_SUCCESS) {// problem in the user's initializer
		delete adapter;
		if (status != NDIS_STATUS_FAILURE) {
			*OpenErrorStatus = status;
			return NDIS_STATUS_OPEN_FAILED;
		}
		return NDIS_STATUS_FAILURE;
	}

	// OK! At this point we assume all the initialization (including SetAttributes())
	// has been performed by the client. The h/w is to be ready to roll.
	// Return the selected medium index to NDIS.

	ASSERT(Medium.Selected()!=UINT(-1));
	*SelectedMediumIndex = Medium.Selected();

	// Register the shutdown handler
#if defined (NDIS40_MINIPORT) || defined (NDIS41_MINIPORT) || defined (NDIS50_MINIPORT)
	NdisMRegisterAdapterShutdownHandler(
				*adapter,		// miniport handle.
				adapter,		// context
				Shutdown
				);
#else
	// 5.1+ Miniports register Shutdown() with Characteristics
#endif

	return NDIS_STATUS_SUCCESS;
}

//#pragma code_seg()

template<class A>
VOID KNdisWrapper<A>::Halt(IN NDIS_HANDLE MiniportAdapterContext)
{
	A* adapter = reinterpret_cast<A*>(MiniportAdapterContext);
	ASSERT(_KNDIS::IsValid(adapter));

#if defined (NDIS40_MINIPORT) || defined (NDIS41_MINIPORT) || defined (NDIS50_MINIPORT)
	// deregister the shutdown handler
	NdisMDeregisterAdapterShutdownHandler(*adapter);
#endif

	// call the client
	adapter->Halt();

	// destroy the adapter
	delete adapter;
}

template<class A>
BOOLEAN KNdisWrapper<A>::CheckForHang(IN NDIS_HANDLE MiniportAdapterContext)
{
	return
	reinterpret_cast<A*>(MiniportAdapterContext)->CheckForHang();
}

template<class A>
VOID KNdisWrapper<A>::DisableInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->DisableInterrupt();
}

template<class A>
VOID KNdisWrapper<A>::EnableInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->EnableInterrupt();
}

template<class A>
VOID KNdisWrapper<A>::HandleInterrupt(IN NDIS_HANDLE MiniportAdapterContext)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->HandleInterrupt();
}

template<class A>
void KNdisWrapper<A>::Isr(
			OUT PBOOLEAN				InterruptRecognized,
			OUT PBOOLEAN				QueueMiniportHandleInterrupt,
			IN	NDIS_HANDLE				MiniportAdapterContext
			)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->Isr(InterruptRecognized, QueueMiniportHandleInterrupt);
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::QueryInformation(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesWritten,
			OUT PULONG					BytesNeeded
			)
{
	ASSERT(reinterpret_cast<A*>(MiniportAdapterContext)->IsValid());
	return
	reinterpret_cast<A*>(MiniportAdapterContext)->QueryInformation(
			Oid,
			InformationBuffer,
			InformationBufferLength,
			BytesWritten,
			BytesNeeded);
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::SetInformation(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_OID				Oid,
			IN	PVOID					InformationBuffer,
			IN	ULONG					InformationBufferLength,
			OUT PULONG					BytesRead,
			OUT PULONG					BytesNeeded
			)
{
	ASSERT(reinterpret_cast<A*>(MiniportAdapterContext)->IsValid());
	return
	reinterpret_cast<A*>(MiniportAdapterContext)->SetInformation(
			Oid,
			InformationBuffer,
			InformationBufferLength,
			BytesRead,
			BytesNeeded);
}


template<class A>
NDIS_STATUS KNdisWrapper<A>::Reconfigure(
			OUT PNDIS_STATUS			OpenErrorStatus,
			IN	NDIS_HANDLE				MiniportAdapterContext	OPTIONAL,
			IN	NDIS_HANDLE				WrapperConfigurationContext
			)
{
	return NDIS_STATUS_NOT_SUPPORTED;
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::Reset(
			OUT PBOOLEAN				AddressingReset,
			IN	NDIS_HANDLE				MiniportAdapterContext
			)
{
	return
	reinterpret_cast<A*>(MiniportAdapterContext)->Reset(AddressingReset);
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::Send(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PNDIS_PACKET			Packet,
			IN	UINT					Flags
			)
{
	return
	reinterpret_cast<A*>(MiniportAdapterContext)->Send(Packet, Flags);
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::WanSend(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				NdisLinkHandle,
			IN	PNDIS_WAN_PACKET		Packet
			)
{
	// FIX THIS: *KNdisLink*
	reinterpret_cast<A*>(MiniportAdapterContext)->WanSend(Packet);
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::TransferData(
			OUT PNDIS_PACKET			Packet,
			OUT PUINT					BytesTransferred,
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				MiniportReceiveContext,
			IN	UINT					ByteOffset,
			IN	UINT					BytesToTransfer
			)
{
	return
	reinterpret_cast<A*>(MiniportAdapterContext)->TransferData(
			Packet,
			BytesTransferred,
			MiniportReceiveContext, /* See KNdisPartialFrame */
			ByteOffset,
			BytesToTransfer);
}

template<class A>
void KNdisWrapper<A>::Shutdown(
			PVOID ShutdownContext)
{
	reinterpret_cast<A*>(ShutdownContext)->Shutdown();
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::WanTransferData(VOID)
{
	return NDIS_STATUS_NOT_SUPPORTED;
}

template<class A>
VOID KNdisWrapper<A>::ReturnPacket(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PNDIS_PACKET			Packet
			)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->ReturnPacket(Packet);
}

template<class A>
VOID KNdisWrapper<A>::SendPackets(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PPNDIS_PACKET			PacketArray,
			IN	UINT					NumberOfPackets
			)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->SendPackets(
		PacketArray, NumberOfPackets);
}

template<class A>
VOID KNdisWrapper<A>::AllocateComplete(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	PVOID					VirtualAddress,
			IN	PNDIS_PHYSICAL_ADDRESS	PhysicalAddress,
			IN	ULONG					Length,
			IN	PVOID					Context
			)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->AllocateComplete(
		VirtualAddress,PhysicalAddress,Length,Context);
}

#if (KNDIS_DDK_VERSION > 5)
template<class A>
VOID KNdisWrapper<A>::PnPEventNotify(
			IN NDIS_HANDLE  MiniportAdapterContext,
			IN NDIS_DEVICE_PNP_EVENT  PnPEvent,
			IN PVOID  InformationBuffer,
			IN ULONG  InformationBufferLength
		    )
{
	reinterpret_cast<A*>(MiniportAdapterContext)->PnPEventNotify(
		PnPEvent, InformationBuffer, InformationBufferLength);
}

template<class A>
VOID KNdisWrapper<A>::CancelSendPackets(
			IN NDIS_HANDLE  MiniportAdapterContext,
			IN PVOID	CancelId
			)
{
	reinterpret_cast<A*>(MiniportAdapterContext)->CancelSendPackets(CancelId);
}
#endif // #if (KNDIS_DDK_VERSION > 5)


#ifdef KNDIS_SUPPORT_CO
//////////////////////////////////////////////////////////////////
// Co stuff
// 'A' should be a defined KNdisCoMiniAdapter<VC> class

template<class A>
NDIS_STATUS KNdisWrapper<A>::CoCreateVc(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				NdisVcHandle,
			OUT	PNDIS_HANDLE			MiniportVcContext
			)
{
	KVirtualConnection* vc;
	NDIS_STATUS status =
	reinterpret_cast<KNdisCoMiniAdapter*>
		(MiniportAdapterContext)->CreateVc(&vc);
	if (status == NDIS_STATUS_SUCCESS) {
		vc = NdisVcHandle;			// assign the NDIS handle
		if (vc->Initialize(reinterpret_cast<KNdisCoMiniAdapter*>
			(MiniportAdapterContext)) != NDIS_STATUS_SUCCESS) {
					delete vc;
					return NDIS_STATUS_RESOURCES;
		}
		*MiniportVcContext = vc;	// return this
	}
	return status;
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::CoDeleteVc(
			IN	NDIS_HANDLE				MiniportVcContext
			)
{
	return
	reinterpret_cast<KVirtualConnection*>
		(MiniportVcContext)->DeleteVc(reinterpret_cast<KVirtualConnection*>
			(MiniportVcContext));
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::CoActivateVc(
			IN	NDIS_HANDLE				MiniportVcContext,
			IN OUT PCO_CALL_PARAMETERS	CallParameters
			)
{
	return
	reinterpret_cast<KVirtualConnection*>
		(MiniportVcContext)->Activate(CallParameters);
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::CoDeactivateVc(
			IN	NDIS_HANDLE				MiniportVcContext
			)
{
	return
	reinterpret_cast<KVirtualConnection*>
		(MiniportVcContext)->Dectivate();
}

template<class A>
VOID KNdisWrapper<A>::CoSendPackets(
			IN	NDIS_HANDLE				MiniportVcContext,
			IN	PPNDIS_PACKET			PacketArray,
			IN	UINT					NumberOfPackets
			)
{
	reinterpret_cast<KVirtualConnection*>
		(MiniportVcContext)->SendPackets(PacketArray, NumberOfPackets);
}

template<class A>
NDIS_STATUS KNdisWrapper<A>::CoRequest(
			IN	NDIS_HANDLE				MiniportAdapterContext,
			IN	NDIS_HANDLE				MiniportVcContext	OPTIONAL,
			IN OUT PNDIS_REQUEST		NdisRequest
			)
{
	// delegate to an OID hanlder
	return
	reinterpret_cast<A*>->ProcessRequest
			(NdisRequest, reinterpret_cast<A*>(MiniportVcContext));
}
#endif // KNDIS_SUPPORT_CO

#if NDIS_WDM
template<class A> NTSTATUS __stdcall
KNdisWrapper<A>::WdmCompletionTxRoutine(PDEVICE_OBJECT pDevObj, PIRP pIrp, PVOID context)
{
	UNREFERENCED_PARAMETER(pDevObj);
	A* a = KNdisAdapterTraits<A>::GetAdapter(context);	// maps irp => owner
	ASSERT(a);										// assert context had been alloc correctly
	return a->CompletionTxRoutine(pIrp, reinterpret_cast<A::IRP_CONTEXT*>(context));
}
template<class A> NTSTATUS __stdcall
KNdisWrapper<A>::WdmCompletionRxRoutine(PDEVICE_OBJECT pDevObj, PIRP pIrp, PVOID context)
{
	UNREFERENCED_PARAMETER(pDevObj);
	A* a = KNdisAdapterTraits<A>::GetAdapter(context);	// maps irp => owner
	ASSERT(a);										// assert context had been alloc correctly
	return a->CompletionRxRoutine(pIrp, reinterpret_cast<A::IRP_CONTEXT*>(context));
}
#endif // NDIS_WDM


#endif // !defined(AFX_KNDISWRAPPER_H__01CA4644_2339_11D3_8F9D_00C04F7445B7__INCLUDED_)
