{\rtf1\ansi \deff4\deflang1033{\fonttbl{\f0\froman\fcharset0\fprq2 Tms Rmn;}{\f1\froman\fcharset2\fprq2 Symbol;}{\f2\fswiss\fcharset0\fprq2 Helv;}{\f3\fmodern\fcharset0\fprq1 Courier;}
{\f4\froman\fcharset0\fprq2 Times New Roman;}{\f5\fswiss\fcharset0\fprq2 Arial;}{\f6\froman\fcharset0\fprq2 MS Serif;}{\f7\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f8\froman\fcharset0\fprq2 Times;}{\f9\fswiss\fcharset0\fprq2 Helvetica;}
{\f10\fswiss\fcharset0\fprq2 System;}{\f11\fmodern\fcharset0\fprq1 Courier New;}{\f12\fnil\fcharset2\fprq2 Wingdings;}{\f13\fmodern\fcharset2\fprq1 MS LineDraw;}{\f14\fdecor\fcharset0\fprq2 Algerian;}{\f15\fswiss\fcharset0\fprq2 Arial Rounded MT Bold;}
{\f16\froman\fcharset0\fprq2 Bookman Old Style;}{\f17\fdecor\fcharset0\fprq2 Braggadocio;}{\f18\fswiss\fcharset0\fprq2 Britannic Bold;}{\f19\fscript\fcharset0\fprq2 Brush Script MT;}{\f20\fswiss\fcharset0\fprq2 Century Gothic;}
{\f21\fdecor\fcharset0\fprq2 Colonna MT;}{\f22\fdecor\fcharset0\fprq2 Desdemona;}{\f23\froman\fcharset0\fprq2 Footlight MT Light;}{\f24\fswiss\fcharset0\fprq2 Impact;}{\f25\fdecor\fcharset0\fprq2 Kino MT;}{\f26\froman\fcharset0\fprq2 Wide Latin;}
{\f27\fscript\fcharset0\fprq2 Matura MT Script Capitals;}{\f28\fdecor\fcharset0\fprq2 Playbill;}{\f29\fnil\fcharset2\fprq2 MSIcons;}{\f30\fswiss\fcharset0\fprq2 Arial Narrow;}{\f31\fmodern\fcharset0\fprq1 Lucida Sans Typewriter;}
{\f32\fswiss\fcharset0\fprq2 AvantGarde;}{\f33\froman\fcharset0\fprq2 Bookman;}{\f34\fswiss\fcharset0\fprq2 Helvetica-Narrow;}{\f35\froman\fcharset0\fprq2 NewCenturySchlbk;}{\f36\froman\fcharset0\fprq2 Palatino;}
{\f37\fscript\fcharset0\fprq2 ZapfChancery;}{\f38\fdecor\fcharset2\fprq2 ZapfDingbats;}{\f39\fmodern\fcharset0\fprq2 Letter Gothic MS;}{\f40\fdecor\fcharset0\fprq2 MSIcons2;}{\f41\fswiss\fcharset0\fprq2 GillSans;}
{\f42\froman\fcharset0\fprq2 TimesNewRomanPS;}{\f43\fswiss\fcharset0\fprq2 FrnkGothITC Hv BT;}{\f44\fswiss\fcharset0\fprq2 FrnkGothITC HvIt BT;}{\f45\fswiss\fcharset0\fprq2 FrnkGothITC Md BT;}{\f46\fswiss\fcharset0\fprq2 FrnkGothITC Bk BT;}
{\f47\froman\fcharset255\fprq2 Roman;}{\f48\fscript\fcharset255\fprq2 Script;}{\f49\fmodern\fcharset255\fprq2 Modern;}{\f50\fswiss\fcharset0\fprq1 MS Dialog;}{\f51\fswiss\fcharset0\fprq2 CB Univers 67 CondensedBold;}
{\f52\froman\fcharset0\fprq2 Times Roman{\*\falt Times New Roman};}{\f53\fnil\fcharset0\fprq1 Small Fonts;}{\f54\fswiss\fcharset0\fprq2 Univers{\*\falt Arial};}{\f55\fmodern\fcharset0\fprq1 LinePrinter;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;
\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;
\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\sa160\sl-240\slmult0 \f4\fs21 \snext0 Normal;}{\s1\li-1800\sb200\sa80\sl-440\slmult0\keepn \b\f30\fs40 \snext0 heading 1;}{\s2\li-1800\sb140\sa60\sl-380\slmult0\keepn 
\b\f30\fs34 \sbasedon1\snext0 heading 2;}{\s3\sb80\sa40\sl-340\slmult0\keepn \b\f30\fs30 \sbasedon1\snext0 heading 3;}{\s4\sb60\sa40\sl-280\slmult0\keepn \b\f30 \sbasedon1\snext0 heading 4;}{\s5\sb40\sa40\sl-240\slmult0\keepn \b\f30\fs21 
\sbasedon1\snext0 heading 5;}{\s6\sb40\sl-238\slmult0\keepn\pvpara\posy0\absh255\dxfrtext130\dfrmtxtx130\dfrmtxty0 \b\f30\fs21 \sbasedon1\snext15 heading 6;}{\*\cs10 \additive Default Paragraph Font;}{\s15\sb40\sa160\sl-240\slmult0 \f4\fs21 
\sbasedon0\snext0 H6p;}{\s16\sb40\sl-238\slmult0\keepn\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0 \b\f30\fs21\cf2 \sbasedon17\snext18 Wh;}{\s17\sb40\sl-238\slmult0\keepn\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0 \b\f30\fs21 
\snext18 Nh;}{\s18\sb40\sa80\sl-240\slmult0\keepn \f4\fs21 \sbasedon19\snext20 Np1;}{\s19\sa80\sl-240\slmult0\keepn \f4\fs21 \sbasedon0\snext20 Np2;}{\s20\li30\ri30\sa40\sl-140\slmult0\brdrt\brdrs\brdrw15\brsp20 \f4\fs12\cf8 \snext0 Ne;}{
\s21\li30\ri30\sb40\sl-80\slmult0\keepn\brdrb\brdrdb\brdrw15\brdrcf2 \f4\fs12\cf8 \snext16 Ws;}{\s22\li30\ri30\sl-200\slmult0\brdrt\brdrdb\brdrw15\brsp20\brdrcf2 \f4\fs16\cf8 \sbasedon0\snext0 We;}{\s23\li30\ri30\sl-80\slmult0\keepn\brdrb
\brdrs\brdrw15\brsp20 \f4\fs12\cf8 \snext17 Ns;}{\s24\li280\sb40\sl-238\slmult0\keepn\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0 \b\f30\fs21 \sbasedon17\snext25 Nhi;}{\s25\fi-280\li280\sb40\sa80\sl-240\slmult0\keepn \f4\fs21 
\sbasedon18\snext26 Np1i;}{\s26\li310\ri30\sl-140\slmult0\brdrt\brdrs\brdrw15\brsp20 \f4\fs12\cf8 \sbasedon20\snext27 Nei;}{\s27\fi-440\li280\sa80\sl-240\slmult0\tqr\tx160\tx280 \f4\fs21 \sbasedon0\snext27 Ln1;}{\s28\li310\ri30\sl-80\slmult0\keepn\brdrb
\brdrs\brdrw15\brsp20 \f4\fs12\cf8 \sbasedon23\snext24 Nsi;}{\s29\li310\ri30\sb40\sl-80\slmult0\keepn\brdrb\brdrdb\brdrw15\brdrcf2 \f4\fs12\cf8 \sbasedon21\snext30 Wsi;}{
\s30\li280\sb40\sl-238\slmult0\keepn\pvpara\posy0\absh235\dxfrtext130\dfrmtxtx130\dfrmtxty0 \b\f30\fs21\cf2 \sbasedon24\snext25 Whi;}{\s31\li-240\sl-300\slmult0 \f4\fs16 \snext0 Sbre;}{\s32\li310\ri30\sl-140\slmult0\brdrt\brdrdb\brdrw15\brsp20\brdrcf2 
\f4\fs12\cf8 \sbasedon22\snext27 Wei;}{\s33\li280\ri280\sb220\sa40\sl-280\slmult0\keepn \b\f30 \snext34 Sbrh;}{\s34\li280\ri280\sa160\sl-240\slmult0\keepn \f4\fs21 \snext34 Sbrp;}{\s35\sb20\sa60\sl-220\slmult0\keepn \b\f4\fs19 \snext36 Tt;}{
\s36\qr\sl-20\slmult0\keepn\brdrt\brdrs\brdrw15 \f4\fs8 \snext0 Tr;}{\s37\li240\sb20\sa60\sl-220\slmult0\keepn \b\f4\fs19 \sbasedon0\snext37 Th;}{\s38\li240\sb20\sa60\sl-220\slmult0\tx280\tx560 \f4\fs19 \sbasedon0\snext38 Tp;}{
\s39\qr\li30\ri30\sb80\sa80\sl-180\slmult0\brdrt\brdrs\brdrw15\brsp20 \f4\fs16 \sbasedon0\snext0 Te;}{\s40\qr\sl-160\slmult0 \f4\fs12 \sbasedon0\snext0 Le;}{\s41\li-1800\sb20\sa60\sl-220\slmult0\keepn \b\f4\fs19 \sbasedon35\snext36 Ttw;}{
\s42\li-1800\sa420\sl-600\slmult0\keepn\pagebb \b\f30\fs48 \snext0 Ih;}{\s43\sl-540\slmult0\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 \snext0 Ch;}{
\s44\sl-220\slmult0\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 \snext44 Ex;}{\s45\fi-280\li280\sa80\sl-240\slmult0\tx280 \f4\fs21 \sbasedon0\snext45 Lb1;}{
\s46\fi-360\sb80\sa80\sl-240\slmult0\keepn\tx280 \b\f4\fs21 \snext27 Proch;}{\s47\li-1800\sb200\sa80\sl-440\slmult0\keepn \b\f30\fs40 \sbasedon1\snext0 Hn1;}{\s48\li-1800\sb140\sa60\sl-380\slmult0\keepn \b\f30\fs34 \sbasedon2\snext0 Hn2;}{
\s49\sl-220\slmult0\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty0 \f30\fs19 \snext0 Mp;}{\s50\li280\sa80\sl-240\slmult0\tqr\tx160\tx280 \f4\fs21 \sbasedon27\snext50 Lp1;}{\s51\ri240\sb100\sa40\sl240\slmult0\keepn \b\f4\fs21 
\sbasedon0\snext52 Erm;}{\s52\sa100\sl-240\slmult0 \f4\fs21 \sbasedon0\snext52 Erp;}{\s53\li-1800\sa280\sl-240\slmult0\keepn \caps\f4\expnd24\expndtw120 \snext43 Cn;}{\s54\fi-280\li560\sa80\sl-240\slmult0\tx560 \f4\fs21 \sbasedon45\snext54 Lb2;}{
\s55\li280\sl-220\slmult0\tx670\tx1060\tx1450\tx1840\tx2230\tx2620\tx3010\tx3400\tx3790\tx4180\tx4570\tx4960\tx5350\tx5740\tx6130\tx6520\tx6910 \f31\fs16 \sbasedon44\snext55 Exl;}{\s56\sa240\sl-220\slmult0\tx280\tx560 \b\f4\fs19 \snext0 Cap;}{
\s57\fi-600\li560\sa80\sl-240\slmult0\tqr\tx440\tx560 \f4\fs21 \sbasedon27\snext57 Ln2;}{\s58\li560\sa80\sl-240\slmult0\tqr\tx160\tx280 \f4\fs21 \sbasedon50\snext58 Lp2;}{\s59\li-1770\ri30\sb50\sl-80\slmult0\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 \snext0 
header rule;}{\s60\li-1800\sa180\sl-440\slmult0\keepn\tx0 \b\f30\fs40\up6 \snext61 Rh1;}{\s61\sb20\sl-220\slmult0\keepn\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty240 \b\f30\fs21 \snext0 Rmh;}{\s62\ri240\sb20\sa60\sl240\slmult0\keepn 
\b\f4\fs21 \sbasedon51\snext62 Ermn;}{\s63\sb80\sa40\sl-340\slmult0\keepn \b\f30\fs30 \sbasedon3\snext0 Hn3;}{\s64\sl-240\slmult0\keepn \f4\fs21 \snext65 Term1;}{\s65\li280\sa80\sl-240\slmult0 \f4\fs21 \sbasedon0\snext64 Def1;}{
\s66\fi-280\li280\sa80\sl-240\slmult0\tx280 \f4\fs21 \sbasedon45\snext40 Lbp;}{\s67\li280\sa80\sl-240\slmult0\keepn \f4\fs21 \sbasedon19\snext26 Np2i;}{\s68\li280\sl-240\slmult0\keepn \f4\fs21 \sbasedon64\snext69 Term2;}{\s69\li560\sa80\sl-240\slmult0 
\f4\fs21 \sbasedon65\snext68 Def2;}{\s70\li-1800\sl-220\slmult0\tx-1410\tx-1020\tx-630\tx-240\tx150\tx540\tx930\tx1320\tx1710\tx2100\tx2490\tx2880\tx3270\tx3660\tx4050\tx4440\tx4830\tx5220\tx5610\tx6000\tx6390\tx6780 \f31\fs16 \sbasedon44\snext70 Exw;}{
\s71\li-1770\ri30\sb280\sa250\sl-120\slmult0\keepn\brdrb\brdrs\brdrw15\brdrcf2 \f4\fs8\cf8 \snext60 Rule;}{\s72\li-1800\sa160\sl-240\slmult0\tx-1520\tx-1240\tx-960\tx-680\tx-400\tx-120\tx160\tx440\tx720\tx1000 \f4\fs21 \sbasedon0\snext0 Synw;}{
\s73\sa160\sl-240\slmult0\tx280\tx560\tx840\tx1120\tx1400\tx1680\tx1960\tx2240\tx2520\tx2800\tx3080\tx3360\tx3640\tx3920\tx4200\tx4480\tx4760\tx5040\tx5320\tx5600\tx5880\tx6160\tx6440\tx6720 \f4\fs21 \sbasedon0\snext0 Syn;}{\s74\qr\sl-80\slmult0 \f4\fs12 
\sbasedon40\snext1 Leh;}{\s75\sa80\sl-240\slmult0 \f4\fs21 \sbasedon0\snext75 Lmc;}{\s76\li-280\sl-80\slmult0\keepn\pagebb\pvpara\phpg\posy0\dxfrtext180\dfrmtxtx180\dfrmtxty0 \f4\fs12 \snext0 Pb;}{\s77\sa80\sl-240\slmult0\keepn \f4\fs21 
\sbasedon0\snext27 Procp;}{\s78\fi-280\li520\sb20\sa60\sl-220\slmult0\tx520 \f4\fs19 \sbasedon38\snext78 Tpi;}{\s79\qr\li240\sb20\sa60\sl-220\slmult0 \f4\fs19 \sbasedon38\snext38 Tpr;}{
\s80\sb20\sa60\sl-220\slmult0\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 \sbasedon44\snext80 Texf;}{\s81\fi-140\li140\sb20\sa40\sl-200\slmult0\tx280 \f4\fs17 
\sbasedon38\snext81 Tf;}{\s82\sb20\sa60\sl-220\slmult0\tx280\tx560 \f4\fs19 \sbasedon38\snext82 Tpf;}{\s83\qr\li-1770\ri30\sb80\sa80\sl180\slmult0\brdrt\brdrs\brdrw15\brsp20 \f4\fs16 \sbasedon39\snext0 Tew;}{\s84\li-1800\sb80\sa240\tx0\tx280\tx560 
\f4\fs28 \snext0 Art;}{\s85\sb20\sa60\sl-220\slmult0\keepn \b\f4\fs19 \sbasedon37\snext37 Thf;}{\s86\fi-280\li280\sb20\sa60\sl-220\slmult0\tx280 \f4\fs19 \sbasedon78\snext86 Tpif;}{
\s87\sl-640\slmult0\keepn\pvpara\phmrg\posnegx-1801\posy2\absh-2460\absw6720\dxfrtext180\dfrmtxtx180\dfrmtxty0\nowrap \f4\fs60\cf2 \sbasedon43\snext0 Ph;}{\s88\sa80\sl-240\slmult0\keepn \v\f30\cf5 \sbasedon0\snext0 index;}{
\s89\sl-220\slmult0\tqr\tx1560\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty0 \b\f4\fs19 \sbasedon56\snext0 CapSd;}{\s90\sa240\keepn\tqr\tx1560\pvpara\phpg\posy0\absw1560\dxfrtext240\dfrmtxtx240\dfrmtxty0 \f4\fs28 \sbasedon84\snext0 ArtSd;}{
\s91\li240\sb20\sa60\sl-220\slmult0\tx630\tx1020\tx1410\tx1800\tx2190\tx2580\tx2970\tx3360\tx3750\tx4140\tx4530\tx4920\tx5310\tx5700\tx6090\tx6480\tx6870 \f31\fs16 \sbasedon80\snext91 Tex;}{\s92\ri120\sl-360\slmult0\keepn\box\brdrs\brdrw15\brsp80\brdrcf8 
\pvpara\phmrg\posxr\posy0\absh-390 \shading6000\cfpat2 \b\f30\cf8\up10 \sbasedon0\snext60 *hb2;}{\s93\qc\sl-360\slmult0\keepn\box\brdrs\brdrw15\brsp20\brdrcf8 \pvpara\phpg\posy0\absh-390\absw1460\dxfrtext220\dfrmtxtx220\dfrmtxty0 \shading6000\cfpat2 
\b\f30\cf8\up4 \sbasedon4\snext4 *hb1;}{\s94\sb20\sa60\tx240\tx280\tx560 \f4\fs19 \sbasedon38\snext94 Tart;}{\s95\qr\li310\ri30\sb80\sa80\sl180\slmult0\brdrt\brdrs\brdrw15\brsp20 \f4\fs16 \sbasedon0\snext27 Tei;}{
\s96\li280\ri280\sb40\sa40\sl-240\slmult0\keepn \b\f30\fs21 \snext34 Sbrh2;}{\s97\fi-280\li560\ri280\sa80\sl-240\slmult0\keepn\tx560 \f4\fs21 \sbasedon0\snext97 SbrLb;}{
\s98\li560\sl-220\slmult0\tx950\tx1340\tx1730\tx2120\tx2510\tx2900\tx3290\tx3680\tx4070\tx4460\tx4850\tx5240\tx5630\tx6020\tx6410\tx6800 \f31\fs16 \sbasedon55\snext98 Exl2;}{
\s99\li280\ri280\sl-220\slmult0\keepn\tx670\tx1060\tx1450\tx1840\tx2230\tx2620\tx3010\tx3400\tx3790\tx4180\tx4570\tx4960\tx5350\tx5740\tx6130\tx6520 \f31\fs16 \snext99 SbrEx;}{\s100\qr\sl-100\slmult0 \f4\fs12 \sbasedon74\snext1 Teh;}{
\s101\sb20\sa60\sl-220\slmult0\tx280\tx560\tx840\tx1120\tx1400\tx1680\tx1960\tx2240\tx2520\tx2800\tx3080\tx3360\tx3640\tx3920\tx4200\tx4480\tx4760\tx5040\tx5320\tx5600\tx5880\tx6160\tx6440\tx6720 \f4\fs19 \sbasedon73\snext101 Tsyn;}{
\s102\qr\li280\ri280\sl-160\slmult0\keepn \f4\fs12 \sbasedon0\snext34 SbrLe;}{\s103\qr\sl-140\slmult0 \f4\fs12 \sbasedon0\snext0 Tes;}{\s104\li-240\sl-100\slmult0\keepn \f4\fs16 \snext33 Sbrs;}{\s105\fi-300\li420\ri140\sb100\sl-210\slmult0\tx140\tx420 
\f30\fs19 \snext105 *Cbx;}{\s106\fi-300\li420\ri140\sb100\sa100\sl-210\slmult0\tx140\tx420 \f30\fs19 \sbasedon105\snext36 *Cbxe;}{\*\cs107 \additive\cf11 \sbasedon10 annotation reference;}{\s108\sa180\sl-240\slmult0 \f4\cf11 \sbasedon0\snext108 
annotation text;}{\s109\li560\sa40\sl-240\slmult0\tqr\tldot\tx6960 \f4\fs21 \sbasedon110\snext109 toc 3;}{\s110\sa40\sl-240\slmult0\tqr\tldot\tx6960 \f4\fs21 \sbasedon0\snext111 toc 1;}{\s111\li280\sa40\sl-240\slmult0\tqr\tldot\tx6960 \f4\fs21 
\sbasedon110\snext111 toc 2;}{\s112\sl140\slmult0\pvpg\phpg\posx1999\posy14702 \f4\fs10 \snext112 footer;}{\s113\li-1800\sl-210\slmult0\tqr\tx6960 \b\f30\fs19 \snext59 header;}{\s114\li280\sa160\sl-240\slmult0 \f4\fs21 \sbasedon0\snext114 Normal Indent;}{
\s115\fi-280\li560\ri280\sa80\sl-240\slmult0\keepn\tx560 \f4\fs21 \sbasedon97\snext97 SbrLp;}}{\info{\title --}{\author Microsoft Corp.}{\creatim\yr1995\mo10\dy17\hr5\min54}{\version1}{\edmins1}{\nofpages0}{\nofwords0}{\nofchars0}{\vern49203}}
\margl3330\margr1530\margt-2900\margb-2580\gutter420 \facingp\deftab274\widowctrl\ftnbj\aenddoc\noextrasprl\prcolbl\cvmme\sprsspbf\brkfrm\swpbdr\linkstyles\hyphcaps0 \fet0{\*\template C:\\WINWORD\\TEMPLATE\\10abody.dot}\sectd 
\binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 10}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 1 Virtual Machine Manager Overview{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 11}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\footerl \pard\plain \s112\sl140\slmult1\pvpg\phpg\posx1999\posy14702 \f4\fs10 Filename: {\field{\*\fldinst filename }{\fldrslt NORMAL.DOT}}     Project: {\field{\*\fldinst title }{\fldrslt --}}\line     Author: {\field{\*\fldinst author }{\fldrslt 
Microsoft Corp.}}     Last Saved By: {\field{\*\fldinst lastsavedby }{\fldrslt Microsoft Corp.}}
\par {\f8 
\par }}{\footerr \pard\plain \s112\sl140\slmult1\pvpg\phpg\posx1999\posy14702 \f4\fs10 Filename: {\field{\*\fldinst filename }{\fldrslt NORMAL.DOT}}     Project: {\field{\*\fldinst title }{\fldrslt --}}\line     Author: {\field{\*\fldinst author }{\fldrslt 
Microsoft Corp.}}     Last Saved By: {\field{\*\fldinst lastsavedby }{\fldrslt Microsoft Corp.}}
\par {\f8 
\par }}{\headerf \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab {\field{\*\fldinst PAGE}{\fldrslt 13}} 
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\footerf \pard\plain \s112\sl140\slmult1\pvpg\phpg\posx1999\posy14702 \f4\fs10 Filename: {\field{\*\fldinst filename }{\fldrslt NORMAL.DOT}}     Project: {\field{\*\fldinst title }{\fldrslt --}}\line     Author: {\field{\*\fldinst author }{\fldrslt 
Microsoft Corp.}}     Last Saved By: {\field{\*\fldinst lastsavedby }{\fldrslt Microsoft Corp.}}
\par {\f8 
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}
{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8
\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 1
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Virtual Machine Manager Overview 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Introduction 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The virtual machine manager (VMM) is the 32-bit protected-mode operating system at the core of Windows 95. Its primary responsibility is to create, run, monitor, and terminate virtual machines. The VMM provides services that manage memory, processes, inte
rrupts, and protection faults. The VMM works with virtual devices, 32-bit protected-mode DLLs, to allow the virtual devices to intercept interrupts and faults to control the access that an application has to hardware devices and installed software. 

\par Both the VMM and virtual devices run in a single, 32-bit, flat model address space at privilege level 0 (also called ring 0). The system creates two global descriptor table (GDT) selectors, one for code and the other for data, and uses these selectors in 
the CS, DS, SS, and ES segment registers. Both selectors have a base address of zero and a limit of 4 gigabytes (GBs), so all the segment registers point to the same address space. The VMM and virtual devices never change these registers. 
\par The VMM provides multiple-threaded, preemptive multitasking. It runs multiple applications simultaneously by sharing CPU (central processing unit) time between the threads in which the applications and virtual machines run. The VMM is also nonreentrant. T
his means that virtual devices must synchronize access to the VMM services. The VMM provides services, such as semaphores and events, to help virtual devices prevent reentering the VMM. 
\par The virtual machine manager provides a variety of services, messages, macros, and structures to help virtual devices manage their corresponding hardware devices and services. The following chapters introduce the services and provide details about how to c
all the individual services, messages, macros, and structures. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Paging Through MS-DOS 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When run on hardware for which 32-bit drivers are not available, Windows 95 may be forced to use MS-DOS and/or the BIOS fo
r access to the paging device. When paging through MS-DOS, the VMM changes its behavior in significant ways, and new rules apply to existing VxDs. Windows 95 will also page through MS-DOS if the system is running in safe mode. 
\par Make sure to test your VxD on a configuration which pages through MS-DOS. One way to accomplish this is to go to the Control Panel, and select System, Performance, File System, Troubleshooting, then 'Disable all 32-bit protect-mode disk drivers'. 
\par Special circumstances that apply to paging through MS-DOS will be noted as they arise. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Pageable VxDs 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This section describes how paging works using the Windows 3.1 model. Then, changes to the model for Windows 95 are described. 
\par Under Windows 3.1, VxD code segments are always locked. This implies that VxD code is normally not preempted, with the following exceptions: 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
If interrupts are enabled, hardware interrupts may be serviced. Therefore, any data structures that may be accessed by hardware interrupts 
must be protected by disabling interrupts during the access. (And obviously, any data structures accessed by a hardware interrupt must be locked.) 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Accessing swappable memory may result in the code being pre-empted, even if interrupts are disabled. (The VMM might need to wait for the page to arrive from the swap device.) Therefore, any data structures that exist in swappable memory must be protected
 by some sort of synchronization mechanism; merely disabling interrupts is not good enough. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Calling a service that adjusts execution priorities may result in the code being pre-empted if the result of the adjustment is that the current virtual machine no longer has the highest execution priority in the system. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Calling a service that allocates or frees memory from the system heap or pages from the page allocator may result in the code being pre-empted if the swap file needs to be adjusted to account for the memory being allocated or freed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The terms pageable and swappable are synonymous. The VMM uses paging as its form of memory management. It does not swap segments or tasks. Where you see the word swap or a derivative thereof, substitute the corresponding form of the word page. 
\par Windows 95 supports VxD with pageable code segments. While this has the benefits of allowing rarely-used code segments to get paged out, thus freeing up memory, it does come at the cost of adding more rules to follow. 
\par Here are additional rules that apply to Windows 95 pageable VxDs. They are in addition to the existing rules from Windows 3.1. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Pageable code and data may not be accessed by a hardware interrupt. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Code in pageable segments may be preempted at any time by the paging system, even if interrupts are disabled. Thus, care should be taken to protect data structures from corruption by unsynchronized access. Consider the following code fragment: 
\par \pard\plain \s55\li280\sl-220\slmult1\tx670\tx1060\tx1450\tx1840\tx2230\tx2620\tx3010\tx3400\tx3790\tx4180\tx4570\tx4960\tx5350\tx5740\tx6130\tx6520\tx6910 \f31\fs16 pushfd\tab \tab ; Disable interrupts to protect a global
\par     cli\tab \tab \tab ; variable, so that the update is atomic
\par     mov eax, pHead \tab ; Get the head of the list
\par     mov ecx, [eax].pNext\tab ; And delete it from the list
\par     mov     pHead, ecx
\par     popfd\tab \tab \tab ; End of critical section
\par 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 If this code fragment resides in pageable memory, then it may be possible for code to in
terrupt this sequence and corrupt the linked list. Using standard synchronization techniques such as semaphores, you can serialize access to the data structure, but since there are hidden possibilities for deadlocks, the safest way to guarantee the correc
tness of the code is to keep it in locked memory. Furthermore, the data in which the linked list resides should also reside in locked memory. 
\par If Windows 95 is paging through MS-DOS, allowing VxD code segments to be paged out would be catastrophic. In such situations, the VMM automatically locks all VxD code segments (and VxDLdr does the same for dynamically-loaded VxDs). 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Bitness 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Some services alter their behavior depending on whether the virtual machine is running in 16-bit or 32-bit protected mode. The VMM determines whether a virtual machine is in 16-bit or 32-bit protected mode by recording whether the virtual machine entered 
protected mode (via the DPMI services) as a 16-bit or 32-bit application. It does not check whether the current CS is a 16-bit o
r 32-bit code segment. This means that if a 16-bit DPMI client happens to create a 32-bit code segment and switch to it, the VMM will still treat it like a 16-bit application and use only the low word of the extended registers. 
\par For compatibility reasons, the Windows 95 system virtual machine executes as a 16-bit DPMI client. That implies that every Win32 application is considered a 16-bit application by the VMM. As a result, Win32 applications cannot communicate with VxDs by the
 same means that 16-bit Windows applications can (software interrupts, callbacks, VxD services, etc). Win32 applications must use the DeviceIOControl interface to communicate with VxDs that support device I/O calls. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Deadlocks 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
With the greater degree of multi-tasking available in Windows 95, the opportunity for deadlocking the system grows enormously. Moreover, some operations, while not deadlocking the system, effectively shut off multi-tasking until the operation completes. T
he section on events will discuss various deadlock issues related to events. Here are some other issues: 
\par Remember that there are two components in the system which together control whether a thread may run. VxDs interact with the ring 0 scheduler and time slicer, whose rules for choosing which thread may run can be oversimplified to 'run the highest priority
 thread not blocked on a ring 0 synchronization object'. Meanwhile, there is also a ring 3 scheduler implemented in Kernel32 which has its own rules for which thread may run, based on things applications do, such as {\b WaitForSingleObject} or {\b 
GetMessage}. In order for a thread to run at ring 3, both schedulers must agree that the thread is runnable. 
\par For example, a common scenario is for a VxD to block thread A at ring 0 and wait until thread B does some work at ring 3. If thread A owns some resource at ring 3 which thread B requires, then the system grinds to a halt because thread B cannot run until 
thread A releases the resource, but thread A is waiting for thread B to do something. 
\par Another common scenario is for
 a VxD to attempt to acquire a resource at event or timeout time which the current thread already owns. This results in even shorter deadlock chain, where a thread ends up waiting for itself. Examples of this will be given in the chapter on events, but th
e general rule is not to block inside an event or timeout. Even if you don't deadlock the system, you will almost certainly cause multi-tasking to halt until the thread unblocks. 
\par Another scenario is to call {\b Begin_Critical_Section}, followed by some other op
eration which blocks on a synchronization object. 'Blocking with the critical section' usually deadlocks the system because large numbers of important system operations require the critical section in order to proceed. By holding onto the critical section
 while waiting for something else, those other important system operations cannot be carried out. 
\par Yet another situation is for thread A to go into a {\b Resume_Exec} loop, waiting for some operation to be performed by thread B. {\b Resume_Exec} does not block but me
rely processes events, so if thread B does not have sufficiently high priority, it will never run and thus thread A will wait forever. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Hook procedures 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Windows 95 provides additional services which allow a virtual device to unhook various services that it had previously hooked. This has become increasingly important with the introduction of dynamically-loaded VxDs. In order to support this feature, new r
equirements have been imposed on VxDs which hook device services or faults. 
\par The hook procedure passed in the ESI register to {\b Hook_Device_Service}, {\b Hook_V86_Fault}, {\b Hook_PM_Fault}, and {\b Hook_VMM_Fault}
 must be one declared with the BeginProc macro (defined in vmm.h) with the HOOK_PROC attribute. You are required to pass a new-style hook procedure even if you never plan to unhook the service. Failure to comply will prevent other devices from unhooking t
he service. Windows 95 supports old-style hook procedures solely for backwards-compatibility. Support for old-style hook procedures may be removed in a future versio
n of Windows, so it is imperative that you convert all your hook procedures to the new style when building for Windows 95. (New-style hook procedures are downward-compatible with Windows 3.1, so there is no loss of amenity there.) 
\par Here is a sample hook procedure, and the code that installs and removes it. 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 VxD_LOCKED_DATA_SEG
\par pPrevHook dd 0
\par VxD_LOCKED_DATA_ENDS
\par 
\par BeginProc MyHook, HOOK_PROC, pPrevHook, LOCKED
\par 
\par     pushfd                  ; Remember, hooks must preserve all regs
\par     pushad                  ;
\par     Trace_Out  "An MS-DOS app is starting"
\par     popad
\par     popfd
\par     jmp        [pPrevHook]  ; Chain to previous hook
\par 
\par EndProc MyHook
\par 
\par     ...
\par     ; Install the hook to watch for MS-DOS apps starting
\par     mov      esi, offset32 MyHook
\par     GetDeviceServiceOrdinal eax, DOSMGR_Begin_V86_App
\par     VMMCall  Hook_Device_Service
\par     jc       Error
\par IFDEF    WIN31COMPAT
\par     mov  pPrevHook, esi    ; Windows 3.1 requires this
\par                            ; Optional in Windows 95 provided
\par                            ; MyHook is a HOOK_PROC
\par ENDIF
\par 
\par     ...
\par     ; Remove the hook that watches for MS-DOS apps starting
\par     mov      esi, offset32 MyHook
\par     GetDeviceServiceOrdinal eax, DOSMGR_Begin_V86_App
\par     VMMCall  Unhook_Device_Service
\par     jc       Error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Observe that the value returned in ESI need not be stored into pPrevHook under Windows 95; the VMM automatically does this. (This also closes race conditions that occur if you hook an asynchronous service and a hardware interrupt arrives befor
e you can save the answer.) Moreover, you should never attempt to modify the value in pPrevHook yourself; VMM assumes that it is the only code which will modify the value, because it uses that value to walk the hook chain. Furthermore, you must never atte
mpt to 'unhook' the service by passing pPrevHook as the ESI to a {\b Hook_Device_Service} or {\b Hook_XX_Fault} call, for that too will mess up the bookkeeping. 
\par For fault hooks, there is another twist. If there was no previous fault hook, zero is returned in ESI, fo
r compatibility with Windows 3.1, but the address of the system default fault handler is returned in pPrevHook anyway. This allows you to pass a fault through instead of being forced to handle it. Sample code to install the hook procedure would then look 
like 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16     mov      esi, offset32 MyHook
\par     mov      eax, 6                 ; Invalid opcode fault
\par     VMMCall  Hook_VMM_Fault
\par     jc       Error
\par IFDEF\tab WIN31COMPAT
\par     mov      pPrevHook, esi\tab ; DO NOT DO THIS FOR WINDOWS 95
\par ENDIF
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The hook itself would look like this 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 BeginProc MyHook, HOOK_PROC, pPrevHook, LOCKED
\par 
\par     pushfd                    ; Remember, hooks must preserve all regs
\par     pushad                    ;
\par     Trace_Out  "An invalid opcode fault"
\par     popad
\par IFDEF  WIN31COMPAT            ; THIS IS NOT NECESSARY FOR WINDOWS 95
\par     cmp        [pPrevHook], 0 ; Was there a previous hook
\par     jnz        @F             ; Yes, chain to it
\par     popfd                     ; No, just return (nothing better to do)
\par     retd
\par @@:
\par ENDIF
\par     popfd
\par     jmp    [pPrevHook]        ; Chain to previous hook
\par 
\par EndProc MyHook
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Observe how the Windows 95 hook mechanism removes the need to alter behavior depending on whether there was a previous fault handler. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Tips and Traps 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This section describes common problems that VxD writers encounter and suggests ways to avoid them. 
\par {\b Tip:} To avoid cancelling a timeout after it has been dispatched, ensure that the timeout callback procedure immediately set the variable that holds the timeout handle to zero. 
\par {\b Tip:} To avoid cancelling a timeout twice by mistake, use the following method: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16     xor     esi, esi
\par     xchg    [hTimeOut], esi
\par     VMMCall Cancel_Time_Out
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If this code is executed twice by mistake, the second time will not cause any harm. Note, however, that there is still an opportunity for a race condition to occur between the {\b xchg}
 instruction and the call to the {\b Cancel_Time_Out} service. To be extra sure that you don't cancel the wrong timeout by mistake, put the routine in locked code. If the timeout bein
g cancelled is an asynchronous timeout, you also need to disable interrupts. 
\par {\b Tip:} To enumerate all of the threads in the System VM, you can't just call {\b Get_Initial_Thread_Handle} to retrieve the System VM (or {\b Get_Sys_Thread_Handle}), and then call {\b Get_Next_Thread_Handle}
 until you retrieve the handle of a VM whose parent is not the System VM (or until you get back where you started). The reason is that the initial thread handle happens to be the {\i last} thread in the list, so the next time you call {\b Get_Next_Thre
ad_Handle}, you will be bumped into the next VM and think the game is over. Instead, call {\b Get_Sys_Thread_Handle}, and then call {\b Get_Next_Thread_Handle}
 repeatedly until you get back to the system thread handle. For each thread along the way, skip it if the parent VM is not the System VM. 
\par {\b Trap:} Forgetting to zero-initialize the thread data slot. Remember that thread data slots are not zero-initialized. When one is allocated, you have to go through every thread in the system and initialize each one. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Traps 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following are all real problems that were encountered by virtual device developers: 
\par {\b Trap:} Forgetting to free memory associated with a thread data slot when a thread terminates. When a thread terminates, don't forget to free the contents of the thread data slot while you still can; otherwise, the memory will be leaked. 
\par {\b Trap:} Scheduling too many events. The VMM has only a limited amount of space to record events. The space does not grow until the next time the VMM processes events with the critical sect
ion free. Scheduling thousands of events in rapid succession will crash the machine. Coalesce duplicate events to reduce the demand on the event heap. 
\par {\b Trap:}
 Allocating too many list elements. As with events, the VMM has a limited amount of space for allocating list elements (unless the list uses the heap, in which case list elements come from the heap and this remark does not apply). Also, as with events, th
e space for list elements grows only the next time the VMM processes events with the critical sectio
n free. Allocating thousands of list elements in rapid succession will crash the machine. If you need thousands of list elements, you should reconsider your data structure. 
\par {\b Trap:} Forgetting to pass a priority value in the EAX register to {\b Call_Restricted_Event} or {\b Call_Priority_VM_Event}
. The result is that the thread or virtual machine gets boosted by a random amount, and the system seems to freeze for extended periods of time. (The debugging version of Windows 95 reports this problem.) 
\par {\b Trap:} Calling the re
gistry at unrestricted event time. Unless you set the PEF_WAIT_NOT_NEST_EXEC restriction when scheduling the event, it is possible that the event may be dispatched on a thread that is already in the registry. This deadlocks the system. (The debugging vers
ion of Windows 95 reports this problem.) 
\par {\b Trap:} Leaving events outstanding when you unload. Dynamically-loaded device drivers must remove all hooks and cancel all events, timeouts, and callbacks before they unload. Otherwise, the hook, event, timeout, or ca
llback causes a jump to an invalid location when the appropriate condition is met. If you need to leave a hook or callback in place (for example, because the unhook failed, or there is no way to cancel the callback), put the hook or callback in a static c
ode segment so that it remains loaded even after your VxD unloads. Of course, the stub in the static code segment shouldn't do anything unless the rest of the VxD is already loaded. (The debugging version of Windows 95 reports many cases of this problem, 
but not all of them.) 
\par {\b Trap:} Looping without blocking. Remember that going into a {\b Resume_Exec}
 loop does not actually block the current thread; it merely processes events. If the current thread is the highest-priority thread, nothing happens until the loop ends. For additional discussion of this problem, see {\i Events}. 
\par {\b Trap:} Assuming registers don't change across a call. This typically happens when calling a service whose name begins with an underscore (which in most cases indicates that the service uses the C c
alling and register convention) and assuming that the EAX, ECX, or EDX registers are be preserved across the call. (The debugging version of Windows 95 often intentionally modifies those registers in an attempt to catch code that relies on this non-featur
e.) 
\par {\b Trap:} Assuming stack parameters don't change across a call. The C calling convention permits the called function to modify the input parameters, so don't rely on their values being preserved across a call. The following example is wrong: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 push    0              ; flags
\par push    nPages         ; number of pages to lock
\par push    page           ; first page to lock
\par VMMCall _LinPageLock   ; Lock them
\par ; do stuff 
\par VMMCall _LinPageUnlock ; Unlock them
\par add     esp, 12
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b LinPageLock} service is allowed to damage the top three double-words on the stack, resulting in garbage being passed to {\b LinPageUnlock}
. (The debugging version of Windows 95 often intentionally modifies input parameters, in an attempt to catch code that relies on this non-feature.) 
\par {\b Trap:} Confusing VMSTAT_PM_Exec with VMSTAT_PM_Use32Mask. When deciding whether to use 16-bit or 32-bit offsets from the client, the rule is that you should use a 32-bit offset if the VMSTAT_PM_Exec bit is set, {\i and}
 if one of the VMSTAT_PM_Use32Mask bits is set. If a VxD checks only the VMSTAT_PM_Use32Mask bits, it may end up using 32-bit offsets even though the virtual machine is not in protected mode. 
\par {\b Trap:} Leaving files open. If a virtual device opens files, it should close them before giving control back to the virtual
 machine. Since open files are tracked on a per-VM and per-PSP basis, the application on which you opened the file might create another file or might exit, causing the PSP to change, at which point the file handle becomes invalid. Also, having files open 
causes the virtual IFS Manager device to have problems when it attempts to transition to the protected-mode file system. 
\par {\b Trap:} Changing the DS or ES selectors. The CS, DS, ES, and SS selectors must remain as flat selectors at all times. Do not load any other values into those registers, even temporarily. Doing so will crash the system. 
\par {\b Trap:}
 Setting the direction flag. The direction flag must remain clear (up) whenever control passes to the VMM or another virtual device. You can set the direction flag to the 'down' state, but you must clear the flag before yielding control. (The debugging ve
rsion of Windows 95 attempts to catch this error.) 
\par {\b Trap:} Cancelling events the wrong way. If an event is scheduled as a VM Event, it must be cancelled with the {\b Cancel_VM_Event} service. Similarly, global events must be cancelled with {\b Cancel_Global_Event}, thread events must be cancelled with 
{\b Cancel_Thread_Event}, and restricted events must be cancelled with {\b Cancel_Restricted_Events}. Failing to observe these rules results in corrupted memory. (The debugging version of Windows 95 attempts to catch this error.) 
\par {\b Trap:} Race conditions between timeouts, events, and hardware interrupts. VxD's often initiate an operation and then schedule a timeout that cancels the operation if it 
takes too long. A race condition can occur if the timeout is dispatched just as the operation completes. This is particularly true if the user is running high-speed communications software at the same time, because communication interrupts will be streami
ng in, causing the VxD to schedule and cancel many timeouts. If the VxD cancels a timeout after it has been dispatched, and the system has already recycled the handle and given it to another VxD, . the first VxD would end up cancelling the other VxD's tim
eout by mistake. 
\par {\b Trap:} Assuming that {\b MapPhysToLinear}({\i N}, 1, 0) = {\b MapPhysToLinear}(0, 1, 0) + {\i N}. This was never guaranteed, but it happened to be true under Windows 3.1 by accident. This is not true under Windows 95. 
\par {\b Trap:} Passing the wrong number of arguments to a service. This happens most often with the {\b HeapFree}
 service because the VxD writer forgets that there is a second parameter of flags (which must be zero). In general, VxD writers tend to forget to pass flags to services that accept a bitmask of flags
 as the last parameter. This results in the service picking up stack garbage as the flags parameter. (The debugging version of Windows 95 attempts to catch this error.) 
\par {\b Trap:}
 Assuming that the high word is always zero. Many VxDs that interface to DLLs at ring 3 pass a function code in the AX register to the VxD's protected-mode entry point, but the VxD looks at the entire EAX register to parse the function code. This code ten
ded to work by accident under Windows 3.1 because the high words of extended registers were usually zero. This is no longer true under Windows 95. 
\par {\b Trap:}
 Forgetting to disable interrupts when hooking an asynchronous service. Remember that asynchronous services can be called at hardware interrupt time. If a hardware interrupt occurs after a hook is installed, but before the pointer is saved in a place wher
e the hook procedure can get to it, the interrupt can result in a call to the service before the hook is ready. 
\par {\b Trap:} Using {\b Begin_Nest_Exec}
 inappropriately. Any protected-mode procedure called from a nested execution block must be in a nondiscardable segment, must access only data in nondiscardable segments, and may not switch to a 32-bit stack. (This means, in particular, that only interrup
t-safe Windows functions can be called, because anything else might thunk to Win32.) Although these restrictions existed in Windows 3.1 as well, Windows 3.1 almost never spent any time on a 32-bit stack, unless a WINMEM32 or Win32s application was running
. 
But now that Windows 95 has Win32 support built-in, the system spends a large percentage of its time on a 32-bit stack, so the window of opportunity for error is much greater. If you need to call functions that do not respect these restrictions, use an ap
plication time event, coupled with the {\b _SHELL_CallDll} service, passing {\i lpszDll} = 0 and {\i lpszProcName} equal to the 16:16 address. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 14}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 2 Breakpoints and Callbacks{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 19}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 2
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Breakpoints and Callbacks 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Breakpoints and Callbacks 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Breakpoints and callbacks provide a mechanism for transferring control from ring 3 to ring 0 in a controlled manner. 
\par Callbacks are typically given by VxDs to applications so that the application can call back into the VxD as part of a service request. The application performs a far call indirect to the callback address. VMM will perform a Simulate_Far_Return before disp
atching the callback to the VxD that installed it. The VxD typically inspects and/or modifies client registers, then returns. Execution then resumes in the application at the instruction following the "call far". 
\par Breakpoints are typically installed by a VxD into existing V86-mode code that needs to be patched. When execution reaches the breakpoint, VMM dispatches the breakpoint directly to the VxD that installed it. The VxD typically inspects and/or modifies clien
t registers, then moves the client (E)IP register past the breakpoint so as to resume execution. Note that, unlike callbacks, it is the 
VxD's responsibility to adjust the client (E)IP register to point to the location where execution should resume when servicing of the breakpoint is complete. If you forget to do this, the breakpoint will merely be hit again immediately. 
\par Since there are no facilities for freeing breakpoints or callbacks, they should be treated as scarce resources. Dynamically-loaded VxDs which allocate callbacks should save the callback in a static data segment so a new callback is not allocated each time
 the VxD is loaded. 
\par \pard\plain \s23\li30\ri30\sl-80\slmult1\keepn\brdrb\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Note 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Breakpoints are supported only for V86-mode code. Moreover, protected-mode callbacks are not supported from a Win32 application. If a Win32 application needs to communicate with a VxD, it must use the DeviceIoControl mechanism. 
\par \pard\plain \s20\li30\ri30\sa40\sl-140\slmult1\brdrt\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following break point and callback services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Allocate_V86_Call_Back}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocates a V86-mode callback. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Allocate_PM_Call_Back}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocates a protected-mode callback. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Call_When_VM_Returns}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a return-from-interrupt callback. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Install_V86_Break_Point}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a breakpoint callback. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Remove_V86_Break_Point}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes a V86 breakpoint. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Allocate_PM_Call_Back 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, RefData            ; reference data (any doubleword)
\par mov     esi, OFFSET32 Callback  ; callback function to call
\par VMMcall Allocate_PM_Call_Back
\par 
\par jc      error
\par mov     [CallbackAddr], eax     ; selector:offset for callback
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Registers a callback function that 16-bit protected-mode applications can call. Virtual devices use this service to provide an interface that is available to device drivers and applications in a VM. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, or set otherwise. If successful, the EAX register contains a selector:offset address that can be called (far call) from within a protected-mode VM. Note that the selector:offset is not callable from a Win3
2 program. A Win32 program must use the DeviceIoControl function to communicate with a VxD. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the callback procedure. Can be any 32-bit value, but is typically the address of a driver-defined structure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the callback procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     edi, hCurThread     ; current thread handle
\par mov     edx, RefData        ; reference data
\par mov     ebp, OFFSET32 crs   ; points to Client_Reg_Struc
\par call    [Callback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine. The {\i RefData} parameter is the value supplied when the callback procedure was installed, and {\i crs} points to a {\b Client_Reg_Struc
} structure containing the register values for the virtual machine at the time it called the PM callback address. The callback may read and modify the client registers; any changes made will be seen by the calling application when control returns to it. 

\par {\b Allocate_V86_Call_Back}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Allocate_V86_Call_Back 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, RefData            ; reference data (any doubleword)
\par mov     esi, OFFSET32 Callback  ; callback function to call
\par VMMcall Allocate_V86_Call_Back
\par 
\par jc      error
\par mov     [CallbackAddr], eax     ; segment:offset for callback
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Registers a callback function that V86 mode applications can call. Virtual devices use this service to provide an interface that is available to software in a VM. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, or set otherwise. If successful, the EAX register contains a segment:offset address that can be called (far call) from within a V86-mode VM. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the callback procedure. Can be any 32-bit value, but is typically the address of a driver-defined structure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the callback procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     edi, hCurThread     ; current thread handle
\par mov     edx, RefData        ; reference data
\par mov     ebp, OFFSET32 crs   ; points to Client_Reg_Struc
\par call    [Callback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine. The {\i RefData} parameter is the value supplied when the callback procedure was installed, and {\i crs} points to a {\b Client_Reg_Struc
} structure containing the register values for the virtual machine. 
\par {\b Allocate_PM_Call_Back}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_When_VM_Returns 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, TimeOut            ; milliseconds until time out
\par mov     edx, RefData            ; reference data
\par mov     esi, OFFSET32 Callback  ; address of callback function
\par VMMcall Call_When_VM_Returns
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a callback function that receives control when a virtual machine executes the {\b iret} instruction for the current interrupt. Uses Client_CS, Client_EIP, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of milliseconds to wait before calling the callback procedure. The time out occurs only if the {\b iret} instruction is not executed before the specified time elapses. If this parameter is posi
tive, the system calls the callback when time elapses. If this parameter is negative, the system calls the callback when time elapses and calls it again when the {\b iret}
 instruction is executed. If this parameter is zero, the system ignores the time out. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the callback procedure. Can be any 32-bit value, but is typically the address of a driver-defined structure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device typically uses this service in a callback procedure that it installed using the {\b Hook_V86_Int_Chain}
 service. This service directs the system to replace the return address for the interrupt with the address of the callback procedure. That is, the system pushes the callback procedure address on the stack when it creates the stack frame for the interrupt.
 The system then passes the interrupt to the virtual machine. 
\par When the virtual machine executes the {\b iret} instruction, the callback procedure rec
eives control and can carry out tasks. After the callback procedure returns, the system restores the original interrupt return address and execution continues as if returning from the interrupt. 
\par \pard\plain \s23\li30\ri30\sl-80\slmult1\keepn\brdrb\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Note 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The preceding description implies that the only meaningful place to use Call_When_VM_Returns is when a Simulate_Far_Call or Build_Int_Stack_Frame is going to happen soon. (As noted, this is typically done inside the callback installed by Hook_V86_Int_Chai
n.) In particular, in order to hook the back end of a 
simulated interrupt, you must call Call_When_VM_Returns before the interrupt itself is simulated. If the interrupt or far call has already been simulated, Call_When_VM_Returns will not do what you want. (The name of the service is rather unfortunate. It r
eally means "Call when the VM returns to where it is now", and not "Call when the VM executes a return instruction".) 
\par \pard\plain \s20\li30\ri30\sa40\sl-140\slmult1\brdrt\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls this callback procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     edi, hCurThread     ; current thread handle
\par mov     edx, RefData        ; reference data
\par mov     ebp, OFFSET32 crs   ; points to a Client_Reg_Struc
\par call    [Callback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine. The {\i RefData} parameter is the value supplied when the callback procedure was installed, and the {\i crs} parameter points to a {\b 
Client_Reg_Struc} structure containing the register values for the virtual machine. 
\par If the system calls the callback procedure as a result of a time out, it sets the carry flag before calling the procedure. If the system calls the callback a second time (once for a time out and once for the {\b iret}
 instruction), the system sets the zero flag before calling the procedure a second time. The value of the zero flag is indeterminate unless the {\i TimeOut} parameter specifies a negative value. 
\par In other words, 
\par (1) If you passed TimeOut = 0, then the callback is called when the VM returns and at no other time. 
\par (2) If you passed TimeOut > 0, then the callback should begin like this: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 jc      timed_out;  Timeout notification
\par                  ;  Otherwise, the VM returned
\par                  ;  before the timeout expired
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 (3) If you passed TimeOut < 0, then the callback should begin like this: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 jc      timed_out    ;  Timeout notification
\par                      ;  Otherwise, the VM returned
\par jnz     \tab normal_return;  VM returned with no timeout
\par                      ; Else, VM returned with timeout
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Hook_V86_Int_Chain}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Install_V86_Break_Point 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, BreakAddr           ; break point address
\par mov     edx, RefData             ; reference data
\par mov     esi, OFFSET32 Callback   ; address of callback procedure
\par VMMcall Install_V86_Break_Point
\par 
\par jc      not_installed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Inserts a break point in V86 memory of the current virtual machine, and installs a break-point callback procedure to receive control when the break point occurs. A virtual device, such as the virtual MS-DOS manager, can use this service to place patches i
n the BIOS. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, or set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BreakAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the V86 address to place the break point. The address must be specified as a segment:offset pair, and must specify RAM. Once installed, the break point must not be moved. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the callback procedure. Can be any 32-bit value, but is typically the address of a driver-defined structure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Virtual devices typically place V86 break points in global virtual device memory during device initialization. For example, the XMS driver in the virtual V86MMGR device inserts a breakpoint in the real-mode XMS driver during device initialization. Thereaf
ter, all calls to the real-mode XMS driver are intercepted by the virtual XMS driver. 
\par The segment address specified when installing a V86 break point must be the segment address in the CS register when the virtual machin
e executes the break point. For example, if the break point is placed at 0100:0000 but the virtual machine executes the break point at the address 00FF:0010h, an error occurs even though the virtual machine executed a valid break point. 
\par When the virtual machine executes the break point, the system calls the callback procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     eax, BreakAddr          ; address of breakpoint
\par mov     ebx, VM                 ; current VM handle
\par mov     edx, OFFSET32 RefData   ; reference data
\par mov     esi, BreakLinAddr       ; linear address of break point
\par mov     ebp, OFFSET32 crs       ; points to a Client_Reg_Struc
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i BreakAddr} parameter is the V86 address of the break point. The {\i VM} parameter is a handle identifying the current virtual machine and the {\i RefData}
 parameter is the value specified when the callback procedure was installed. The {\i BreakLinAddr} parameter specified the linear address of the break point and the {\i crs} parameter points to a {\b Client_Reg_Struc}
 structure containing the register values for the specified virtual machine. 
\par The {\b Client_CS} and {\b Client_IP}
 registers contain the address of the break point. The virtual device must change these registers to prevent the break point from being executed again when the virtual machine resumes. A virtual device can change the register by simulating the instruction
 that was patched, incrementing the {\b Client_IP} register past the patch, jumping to another address using the {\b Simulate_Far_Jmp} service, or returning from an interrupt handler using the {\b Simulate_Iret} service. 
\par When the virtual device receives the {\b System_Exit} message, it must remove any break point that it placed in global V86 code, that is, code loaded before Windows was loaded. The virtual device can remove a V86 break point using the {\b 
Remove_V86_Break_Point} service. 
\par {\b Remove_V86_Break_Point}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Remove_V86_Break_Point 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, BreakAddr        ; V86 address of break point
\par VMMcall Remove_V86_Break_Point
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes a V86 break point that was installed using the {\b Install_V86_Break_Point} service. It restores the original contents of the memory automatically. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BreakAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the break point to remove. The address must be a segment:offset pair. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 In Windows 95, removing a breakpoint does not free the resources associated with it. Thus, repeatedly installing and removing the same breakpoint will slowly leak resources. 
\par {\b Install_V86_Break_Point}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 38}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 3 Debugging{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 37}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 3
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Debugging 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Debugging 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following debugging services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Assert_Range}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Validates a pointer to any structure \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Clear_Mono_Screen}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Clears the secondary display. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Debug_Convert_Hex_Binary}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts hexadecimal to binary. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Debug_Convert_Hex_Decimal}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts a number to decimal. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Debug_Flags_Service}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Asserts various conditions. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Debug_Out_Service}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Sends a null-terminated ASCII string to the debugging device and stops the debugger if one is running. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Debug_Printf_Service}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Prints a C-style formatted string to the debugging device. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Debug_Test_Cur_VM}
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Asserts that EBX is the current VM handle. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
Debug_Test_Valid_Handle}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Asserts that EBX is a valid VM handle. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {
\b Disable_Touch_1st_Meg}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Disables the first megabyte of memory. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {
\b Enable_Touch_1st_Meg}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables the first megabyte of memory. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
Get_Debug_Options}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Checks for command-line debugging options. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
Get_Mono_Chr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Gets the character/attribute from the secondary display. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 {\b Get_Mono_Cur_Pos}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Gets the cursor position from the secondary display. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b In_Debug_Chr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reads one character from the debugging device. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Is_Debug_Chr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Checks if a character is ready on the debugging device. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Log_Proc_Call}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Logs the caller of the current procedure. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Out_Debug_Chr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Writes one character to the debugging device. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Out_Debug_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Writes a string to the debugging device. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Out_Mono_Chr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Writes one character to the secondary display. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Out_Mono_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Writes a string to the secondary display. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Queue_Debug_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Queues a debugging string. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_Mono_Cur_Pos}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets the cursor position for the secondary display. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Test_Reenter}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Asserts that VMM has not been re-entered. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Trace_Out_Service}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Writes a null-terminated ASCII string to the debugging device. \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Validate_Client_Ptr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Validates the client register pointer. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Assert_Range 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include vmm.h 
\par 
\par _Assert_Range(DWORD pStruc, DWORD ulSize, DWORD sSignature, 
\par               DWORD lSignatureOffset, DWORD ulFlags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Verifies that a pointer to any structure is valid. Uses the C calling convention. 
\par  Returns nonzero in the EAX register if the structure is valid; otherwise, returns zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pStruc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Structure pointer to validate. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ulSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size of the structure in bytes. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i sSignature}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A DWORD value to validate. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lSignatureOffset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset in bytes to {\i sSignature}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ulFlags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Validation flags. May be one or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ASSERT_RANGE_NULL_BAD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Return failure for NULL pointers. May not be combined with ASSERT_RANGE_NULL_OK. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ASSERT_RANGE_NULL_OK \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Return success for NULL pointers. May not be combined with ASSERT_RANGE_NULL_BAD. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ASSERT_RANGE_NO_DEBUG \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Do not output a debugging message on failure when debugger is present. This flag is ignored if no debugger is installed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following validation steps are taken. 
\par \pard\plain \s27\fi-440\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 \tab 1\tab If pStruc is a null pointer, its validity is determined by which of the ASSERT_RANGE_NULL_BAD or ASSERT_RANGE_NULL_OK flags is passed. 
\par \tab 2\tab Otherwise, pStruc must be a pointer to valid data of length ulSize bytes. 
\par \tab 3\tab Furthermore, if sSignature is nonzero, then the DWORD at pStruc + lSignatureOffset must be equal to sSignature. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For example, suppose you have a structure defined as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 struct ABC \{
\par \tab DWORD member1;
\par \tab BYTE  member2[20];
\par \tab DWORD dwSignature;
\par \};
\par 
\par // Every valid ABC has ABCSIGNATURE stored in the dwSignature field.
\par 
\par #define ABCSIGNATURE 0x31415926
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21  If you want to check whether some pointer variable p is a valid pointer to a ABC, except that null pointers are okay, then you would write 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 if (!_Assert_Range(p, sizeof(SAMPLE), ABCSIGNATURE, 
\par     offsetof( SAMPLE, dwSignature), ASSERT_RANGE_NULL_OK)) \{
\par        return ERROR_INVALID_PARAMETER;
\par     \}
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This service can be called only at a time when page faults can safely be handled. It cannot be called at hardware interrupt time, nor at any other time when paging is not allowed. Since this service touches the memory at {\i pStruc}
 as part of the validation (even if {\i sSignature} is zero), if {\i pStruc} points to a phys/linear region owned by memory-mapped hardware, there may be unusual side-effects. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Clear_Mono_Screen 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Clear_Mono_Screen
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Clears the secondary display screen by filling it with spaces, and setting character attributes to normal. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Out_Mono_Chr}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Convert_Hex_Binary 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     al, Number              ; number to convert
\par VMMcall Debug_Convert_Hex_Binary
\par 
\par mov     [BinNum], eax           ; binary number
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts an 8-bit value to a 32-bit value representing a binary number. The new value consists of eight 4-bit values, each of which is either 0 or 1. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the converted number in the EAX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Number}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to convert. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is typically used in conjunction with the {\b Trace_Out} macro to display values in binary notation. 
\par The following example prints, "The converted value is 01011001". 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     al, 01011001b 
\par VMMcall Debug_Convert_Hex_Binary
\par Trace_Out 'Converted value is #EAX'
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Debug_Convert_Hex_Decimal}, {\b Trace_Out}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Convert_Hex_Decimal 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Number              ; number to convert
\par VMMcall Debug_Convert_Hex_Decimal
\par 
\par mov     [BinNum], eax           ; binary number
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts an 8-bit value to a 32-bit value representing a decimal number. The new value consists of eight 4-bit values, each in the range 0 through 9. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the converted number in the EAX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Number}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the number to convert. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is typically used in conjunction with the {\b Trace_Out} macro to display values in decimal notation. 
\par The following example prints, "The converted value is 00003141". 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     eax, 3141
\par VMMcall Debug_Convert_Hex_Decimal
\par Trace_Out 'Converted value is #EAX'
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Debug_Convert_Hex_Binary}, {\b Trace_Out}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Debug_Flags_Service 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par push    flags
\par VMMcall _Debug_Out_Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts various conditions. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the debug flags. It can be a combination of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_NEVER_REENTER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMM has not been re-entered (see below). \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_TEST_REENTER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMM has not been re-entered (see below). \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_NOT_SWAPPING \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The current thread is not in the middle of a paging operation. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_TEST_CLD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert that the processor direction flag is cleared. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_TEST_BLOCK \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Asssert that NoBlock_Count is set to zero. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_LOG \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Log this procedure (if requested). \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_PROFILE \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Increment profile count and validate the segment registers. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_ENTER_NOBLOCK \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Increment the NoBlock_Count. \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DFS_EXIT_NOBLOCK \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Decrement the NoBlock_Count. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The DFS_NEVER_REENTER and DFS_TEST_REENTER bits differ in their interaction with the Begin_Reent
rant_Execution service. When the Begin_Reentrant_Execution service is called, the VMM re-entry count is reset to zero, even though the VMM has mostly like actually been re-entered. The DFS_TEST_REENTER bit checks this fake re-entry count, whereas the DFS_
NEVER_REENTER bit checks the true re-entry count (which is unaffected by Begin_Reentrant_Execution). 
\par The DFS_ENTER_NOBLOCK and DFS_EXIT_NOBLOCK flags increment and decrement a counter which is checked by the DFS_TEST_BLOCK bit. If the DFS_TEST_BLOCK bit is set when this internal counter is nonzero, the debugger will be notified if it is installed. 

\par The DFS_LOG bit calls the Log_Proc_Call service on behalf of the caller. 
\par The DFS_PROFILE bit causes the service to increment a DWORD variable generated by the BeginProc macro. Do not set this bit manually; let the BeginProc macro do it for you. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par As a rule, you should never call this service directly. It is generated automatically by macros in vmm.h and debug.h. 
\par The BeginProc macro automatically calls this service with the DFS_LOG bit, as well as the DFS_TEST_REENTER if the procedure being declared is not an asynchronous service, and the DFS_TEST_BLOCK flag if the procedure is in pageable code. In the case of an 
exported service, the BeginProc macro also generates a DWORD profiling count and sets the DFS_PROFILE bit. 
\par The ENTER_NOBLOCK, EXIT_NOBLOCK, and ASSERT_MIGHT_BLOCK macros in debug.h should be used to manipulate the block-related DFS bits. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Debug_Out_Service 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par push    OFFSET32 String
\par VMMcall _Debug_Out_Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sends a null-terminated ASCII string to the debugging device and stops the debugger if one is running. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 String to display for debugging purposes. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See the documentation of the {\b Out_Debug_String} service for a list of supported placeholders. The {\b Debug_Out_Service} will do the requisite pushfd and pushad operations. 
\par This service preserves all registers and flags. 
\par You should not call this service directly. Use the {\b Debug_Out} macro instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Debug_Printf_Service 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par push    pArgs
\par push    pFormat
\par VMMCall _Debug_Printf_Service
\par add     esp, 8
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Prints debug output. This is an asynchronous service. Uses the C calling convention. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pFormat}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 C-style "printf" format string. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pArgs}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the array of substitution arguments. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The %-escapes understood by {\b _Debug_Printf_Service} are the same ones supported by wdeb386. (_{\b Debug_Printf_Service} merely calls the debugger to display the string.) 
\par The total size of the output cannot exceed 256 bytes. 
\par {\i pArgs} is a pointer to the substitution arguments, rather than being the first substitution itself. This service would more accurately have been been named {\b _Debug_Vprintf_Service}. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Test_Cur_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM         ; VM handle to check
\par VMMcall Debug_Test_Cur_VM
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that the specified virtual machine is also the current virtual machine. The service crashes the current virtual machine if the {\i VM}
 parameter does not identify the current virtual machine handle. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. This service does not return if the handle is not valid. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to check. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Do not call this service directly. Use the {\b Assert_Cur_VM_Handle} macro instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Crash_Cur_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Test_Valid_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM       ; VM handle to validate
\par VMMcall Debug_Test_Valid_Handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the specified virtual machine handle is valid. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. This service does not return if the handle is not valid. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the virtual machine handle to check. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Do not call this service directly. Use the {\b Assert_VM_Handle} macro instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Assert_VM_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Disable_Touch_1st_Meg 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Disable_Touch_1st_Meg
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Disables the first 1 megabyte of memory for the current virtual machine. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See the description of {\b Enable_Touch_1st_Meg} for more information. 
\par Do not call this service directly. Use the {\b End_Touch_1st_Meg} macro instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Enable_Touch_1st_Meg}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Enable_Touch_1st_Meg 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Enable_Touch_1st_Meg
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Enables the first 1 megabyte of memory for the current virtual machine. The service sets the present bit for the first page directory allowing a virtual device to access addresses in the range. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
In the debugging version of Windows, VxDs are normally not permitted to access memory below the 1MB boundary, so as to help catch null pointer errors. If you need to access memory below the 1MB boundary, you should normally acce
ss it at the high linear address instead. However, in the rare cases where you need to access to memory at its low linear address, this service temporarily grants access to the first megabyte of memory. You should then re-disable the first megabyte of mem
ory when you are finished, as demonstrated in the following example: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16     Begin_Touch_1st_Meg
\par     mov eax, ds:[40h]           ; get int 10h vector
\par     End_Touch_1st_Meg
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 (Note that this is not the recommended way of getting a VM's interrupt vector. The proper way is to use the {\b Get_Instanced_V86_Int_Vector} service.) 
\par Do not call this service directly. Use the {\b Begin_Touch_1st_Meg} macro instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Begin_Touch_1st_Meg}, {\b Disable_Touch_1st_Meg}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Debug_Options 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     al, Char            ; debugging option
\par VMMcall Get_Debug_Options
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the given character was specified as a command-line debugging option when Windows was started. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the zero flag set if the character was specified as a debugging option, clear otherwise. 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Char}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Debugging option to check for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is available only during initialization. This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Test_Debug_Installed}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Mono_Chr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Mono_Chr
\par mov     byte ptr [Char], al         ; character value
\par mov     byte ptr [Attr], ah         ; character attribute
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the character and attribute value at the current cursor position. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the character in the AL register and the attribute in the AH register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Out_Mono_Chr}, {\b Set_Mono_Cur_Pos}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Mono_Cur_Pos 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Mono_Cur_Pos
\par mov     byte ptr [Column], dl         ; current column position
\par mov     byte ptr [Row], dh            ; current row position
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the current cursor position for the secondary display. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the column in the DL register, and the row in the AH register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Set_Mono_Cur_Pos}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 In_Debug_Chr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall In_Debug_Chr
\par mov     byte ptr [Char], al     ; character from debug device
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Reads a character from the debugging device. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the character read in the AL register. If the ESCAPE key or CTRL+C key combination was pressed, the service sets the zero flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Is_Debug_Chr}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Is_Debug_Chr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Is_Debug_Chr
\par jz      no_character            ; zero flag set if no character available
\par 
\par mov     byte ptr [Char], al     ; character from debugging device
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Checks for a character from the debugging device. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the zero flag clear if a character is available, set otherwise. If a character is available, it is returned in the AL register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b In_Debug_Chr}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Log_Proc_Call 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Log_Proc_Call
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates a debugging message that identifies which service or virtual device called the service that called {\b Log_Proc_Call}
. This service is intended to be used only for debugging, and it creates the message only if the user has turned on call logging. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When the {\b BeginProc} macro creates a new service, the macro generates a call to {\b Log_Proc_Call} if the DEBUG symbol is defined and the NO_LOG attribute is {\i not} specified as a parameter to {\b BeginProc}
. 
\par The service adds the message to the debugging queue using the {\b Queue_Out} macro. 
\par Do not call this service directly. Use the BeginProc macro instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b BeginProc}, {\b Queue_Out}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Out_Debug_Chr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     al, Char        ; character to write
\par VMMcall Out_Debug_Chr
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes a character to the debugging device. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Char}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the character to write to the debugging device. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Out_Debug_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Out_Debug_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par pushfd                              ; save flags on stack
\par pushad                              ; save registers on stack
\par mov     esi, OFFSET32 String        ; points to string to write
\par VMMcall Out_Debug_String
\par popad
\par popfd
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes a null-terminated string to the debugging device (typically the COM1 serial port). If the string contains register placeholders, {\b Out_Debug_String}
 replaces these with the actual register values in hexadecimal, or the symbolic label nearest to the specified addresses. Uses all registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Points to a null-terminated string specifying the message to write to the debugging device. {\b Out_Debug_String} uses the {\b lods} instruction to proces
s characters in the string, so the DS register must specify the correct segment selector for the string. 
\par The string can contain one or more placeholders having the following forms: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Placeholder \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 #register \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Displays the current value of the specified register. For example, the service replaces #AX with the value of the AX register. The {\i register} must not be the name of a segment register. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ?register \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Displays the label nearest the address specified by the registers. For example, the service re
places ?EAX with the VMM code segment label nearest the address in the EAX register. The {\i register} must not be the name of a segment register. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ?register:register \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Displays the label nearest the address specified by the registers. For example, the service replaces ?AX:EBX with the label in the segment specified by the AX register that is nearest to the address in the EBX register. The {\i register}
 must not be the name of a segment register. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par If the string contains placeholders, {\b Out_Debug_String} requires the caller to use the {\b pushfd} and {\b pushad} instructions before carrying out a near call to this service. 
\par {\b Trace_Out}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Out_Mono_Chr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     al, Char        ; character to write
\par VMMcall Out_Mono_Chr
\par 
\par mov     eax, 0          ; write character and attribute
\par mov     bl, Char        ; character to write
\par mov     bh, Attr        ; attribute to write
\par VMMcall Out_Mono_Chr
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes a character to the current position on the secondary display. 
\par If the EAX register is not zero, the service writes the character in the AL register and applies the normal attribute. Otherwise, it writes the character and attribute pair in the BX register. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Char}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the character to write to the secondary display. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Attr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the attribute to apply to the character when written. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the linefeed or carriage return character is written, the service automatically adjusts the cursor position, scrolling the screen if necessary. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Out_Mono_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Out_Mono_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 String        ; points to string to write
\par VMMcall Out_Mono_String
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes the specified null-terminated string to the secondary display. If the string contains register placeholders, {\b Out_Mono_String} replaces these with t
he actual register values (in hexadecimal), or the symbolic label nearest to the specified addresses. Uses all registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Points to a null-terminated string specifying the message to write to the debugging device. {\b Out_Mono_String} uses the {\b lods}
 instruction to process characters in the string, so the DS register must specify the correct segment selector for the string. 
\par The string can contain one or more placeholders having the following forms: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Placeholder \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 #register \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Displays the current value of the specified register. For example, the service replaces #AX with the value of the AX register. The {\i register} must not be the name of a segment register. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ?register \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Displays the label nearest the address specified by the registers. For example, the service replaces ?EAX with the VMM code segment label nearest the address in the EAX register. The {\i register} must not be the name of a segment register. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ?register:register \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Displays the label nearest the address specified by the registers. For example, the service replaces ?AX:EBX with the label in the segment specified by the AX register that is nearest to the address in the EBX register. The {\i register}
 must not be the name of a segment register. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Mono_Out}, {\b Out_Debug_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Queue_Debug_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par puse    Value1             ; will be used as #EAX or ?EAX
\par push    Value2             ; will be used as #EBX or ?EBX
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Queues a string and corresponding values for display at a later time. The message remains queued until the user enters the .lq command using the debugger. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Value1}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to queue with the string. If the string contains the #EAX or ?EAX placeholder, this value is used when the string is displayed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Value2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to queue with the string. If the string contains the #EBX or ?EBX placeholder, this value is used when the string is displayed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the null-terminated string to queue. It can contain one or more of the following register placeholders: #AX, #EAX, ?EAX, #BX, #EBX, ?EBX, ?AX:EBX, ?BX:EAX. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Do not call this service directly. Use the {\b Queue_Out macro} instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Out_Debug_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Mono_Cur_Pos 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     dl, Column      ; current column position
\par mov     dh, Row         ; current row position
\par VMMcall Set_Mono_Cur_Pos
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the current cursor position for the secondary display. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Column}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Column position. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Row}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Row position. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par {\b Get_Mono_Cur_Pos}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_Reenter 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Test_Reenter
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Checks the re-entry count for the VMM and values of the DS, ES, and SS registers. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
If the re-entry count is not zero or the segment registers are not equal to the VMM data segment selector, the service displays an error message at the debugging terminal. This service is intended to be used only for debugging. 
\par When the {\b BeginProc} macro creates a new service, the macro generates a call to {\b Test_Reenter} if the SERVICE attribute is specified with {\b BeginProc} and the DEBUG symbol is defined. 
\par {\b BeginProc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Trace_Out_Service 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 String
\par VMMcall _Trace_Out_Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sends a null-terminated ASCII string to the debugging device. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 String to display for debugging purposes. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See the documentation of the {\b Out_Debug_String} service for a list of supported placeholders. {\b _Trace_Out_Service} will do the requisite pushfd and pushad oeprations. 
\par You should not call this service directly. Use the {\b Trace_Out} macro instead. 
\par Example: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Trace_Out 'The value of EAX is #EAX'
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Validate_Client_Ptr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebp, OFFSET32 crs       ; points to a Client_Reg_Struc
\par VMMcall Validate_Client_Ptr
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that the address in the EBP register points to the {\b Client_Reg_Struc} structure for the current virtual machine. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
No return value. If the address is not correct, the service crashes the current virtual machine and does not return. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the current re-entry count for the VMM is not zero, this service returns immediately without checking the client register pointer. 
\par You should not call this service directly. Use the {\b Assert_Client_Ptr} macro instead. 
\par This service has no effect in the retail version of Windows. It is intended to be used with the debugging version. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 40}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 4 Error Conditions{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 41}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 4
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Error Conditions 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Error Condition Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following error condition services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Crash_Cur_VM}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Terminates the current VM. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Fatal_Error_Handler}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Terminates Windows. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Fatal_Memory_Error}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Terminates Windows. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Crash_Cur_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Crash_Cur_VM
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Terminates the current VM. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This service does not return. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A virtual device should call this service when a catastrophic error has occurred in the VM, such as executing an illegal instruction or attempting to program a piece of hardware in a way incompatible with the device virtualization. 
\par If the system VM is the current VM, Windows quits with a fatal error without explicitly crashing the other VMs. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Fatal_Error_Handler 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, <MsgPtr>       ; points to message to display
\par mov     eax, <ErrFlags>     ; exit flags
\par VMMcall Fatal_Error_Handler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Terminates Windows by informing all initialized virtual devices that an unrecoverable error has occurred and should return to real mode (optionally printing an error message). A virtual device should call this service when it detects a fatal error. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This service does not return. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i MsgPtr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying the message to display. If this parameter is 0, no message is displayed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ErrFlags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Exit flags. Can be the following value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EF_Hang_On_Exit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Hangs the system on a fatal exit. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service should not be called directly. Use the Fatal_Error macro instead. 
\par {\b Fatal_Error}, {\b Fatal_Memory_Error}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Fatal_Memory_Error 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Fatal_Memory_Error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Terminates Windows, and displays an error message indicating that there was not enough memory to initialize one or more virtual devices. A virtual device should call this service during init
ialization if there is not enough memory to initialize. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This service does not return. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service uses the {\b Fatal_Error_Handler} service to terminate Windows. {\b Fatal_Memory_Error} sets the exit flags to zero before calling the {\b Fatal_Error_Handler}. 
\par {\b Fatal_Error_Handler}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 66}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 5 Events{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 67}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 5
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Events 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Events 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Introduction 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The Windows 95 virtual machine manager (VMM) is a multiple threaded, non-reentrant operating system. Because it is non-reentrant, virtual devices (VxDs) that process hardware interrupts must have some method of synchronizing their calls to the VMM. For th
is reason, Windows 95 has the concept of "event" processing. 
\par Events are requests from VxDs that a callback procedure be called at a more propitious time. An event is made of the following pieces of information: 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The procedure to be called (the event callback procedure), 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab An arbitrary 32-bit reference data to pass to the event callback procedure, 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Information describing the conditions under which the event callback procedure may be called, 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab An optional priority boost associated with the event, 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab An optional timeout associated with the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If one of the prerequisites for an 
event is that it be called when the current virtual machine or current thread is a particular thread, it is said that the event is scheduled 'for' that thread or virtual machine. The act of calling the event callback procedure is referred to as 'processin
g' the event. 
\par When a VxD is entered because of an asynchronous interrupt such as a hardware interrupt, the VxD can call only a small subset of services. The VxD can: 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Call any Virtual PIC Device (VPICD) service. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Call any asynchronous VMM service. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Schedule events. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Devices that service hardware interrupts often need to use services other than those referred to above. When this is the case, the VxD must schedule an event. That is, the VxD calls an event service such as {\b 
Schedule_VM_Event}, specifying a callback function that the VMM calls when it is safe to call synchronous services. 
\par You can schedule global events or events that a specific to a VM o
r thread. The callback function for a global event may be called at any time. However, a VM event callback function is always called with the specified VM as the current VM. Similarly a thread event callback function is always called with the specified th
read as the current thread. 
\par Certain services can only be called if no VM owns the critical section. To schedule an event such that the callback function is only called when the critical section is not owned, you can use the {\b Call_Restricted_Event} service wi
th the PEF_WAIT_NOT_CRIT flag. Alternatively, you can schedule a critical section callback function by using the {\b Call_When_Not_Critical} service. For more information about critical sections, see {\i Synchronization}. 
\par VM events are often useful for virtual devices that do not service hardware interrupts and can be scheduled at any time except during a Non-Maskable Interrupt (NMI). 
\par Restricted events, which are the most general type of event, are new for Windows 95. When scheduling a restricted event, you can specify a number of "restrictions", or conditions that must be met before the event callback will be called. 
\par Services whose names are of the form Call_XX_Event have the option either to schedule an event or to call the event callback procedure immediately without scheduling an event. The event will be scheduled if the VMM is processing a hardware interrupt that 
interrupted the VM
M, or if the event is virtual machine-specific or thread-specific and the requested virtual machine or thread is not the current virtual machine or thread. The event will also be scheduled if the PEF_ALWAYS_SCHED bit is set, assuming the service supports 
such a bit. (Not all do.) This list of conditions is intended to be informative and not comprehensive. The VMM reserves the right to choose to schedule the event under conditions not explicitly listed above. 
\par See also {\b Call_Priority_VM_Event}, {\b Call_When_Not_Critical}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Cancelling Events 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Services whose names are of the form Cancel_XX_Event must be used only to cancel events scheduled by the corresponding Schedule_XX_Event or Call_XX_Event service. It is an error to pass (for example) a thread event handle to Cancel_VM_Event. 
\par Services which cancel events also allow zero to be passed as the event handle, which is simply ignored. The standard paradigm for scheduling, processing, and cancelling events is as follows: 
\par Scheduling the event: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     \tab esi, OFFSET32 MyEvent
\par VMMcall Schedule_Global_Event
\par mov     hMyEvent, esi            ; Save handle for cancellation
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Processing the event: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 BeginProc MyEvent
\par mov     hMyEvent, 0   ; VERY FIRST THING is
\par                       ; to zero out the handle
\par ;   .
\par ;   .                   Do other event stuff
\par ;   .
\par ret                   ; Finished with the event
\par EndProc MyEvent
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancelling the event: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 xor      esi, esi             ; Atomically set hMyEvent to 0
\par xchg     hMyEvent, esi        ; and retrieve previous value
\par VMMcall  Cancel_Global_Event  ; Cancel if still outstanding
\par 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Event Processing 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Events are processed whenever the VMM is about to transfer control from ring 0 to ring 3. One common example of this is returning from ring 0 back to an application running inside a virtual machine. A second example is when a nested execution service like
 {\b Resume_Exec} or {\b Exec_Int} is about to transfer control to ring 3 code.. 
\par Events are also processed when a thread is blocked on a synchronization object, provided that the Blk_Svc_
Ints flag was passed to the corresponding synchronization service. (Such a thread is known as 'blocked servicing events'.) That a thread which is ostensibly blocked on a synchronization object can be called upon to do work while waiting for that synchroni
zation object is a common source of confusion (or horror) for developers familiar with other operating systems. Failure to consider this is a common source of system deadlocks, so this document will attempt to highlight frequently-encountered scenarios wh
ere particular caution must be exercised. 
\par Note also that event processing is secondary to the scheduler. An event scheduled for a thread or virtual machine may meet all its restrictions, but will nevertheless not be processed if the scheduler does not choose to run that thread or virtual machine.
 In simplified terms, the scheduler chooses the the highest-priority thread in the system which satisfies the following criterion: 
\par (Not suspended) and ((Is not blocked) or ((Is blocked servicing events) and (contains events which have met the restrictions))) 
\par This has some subtle consequences. 
\par Spinning in a Resume_Exec loop is not the same as being blocked on a synchronization object, although it does process events. This has not been an uncommon source of deadlocks. Thread A initiates an asynchronous operation, then goes into a Resume_Exec loo
p, processing events and checking for the asynchronous operation to complete, which breaks the loop. Meanwhile, the code that completes the operation resides in an event callba
ck procedure whose event was scheduled for thread B. If the priority of thread B does not exceed that of thread A, the event will never be processed, because the scheduler only pays attention to the highest-priority unblocked thread. 
\par Note also that unless otherwise explicitly noted, there is no guarantee on the order in which events are processed. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Event Callbacks 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When the VMM calls an event callback function, it enters the function with the following registers set: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Contents \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EBX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Current VM handle \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Programmer-defined reference data specified when the event service routine was installed \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Current thread handle. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EBP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Client register structure \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Interrupts \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enabled \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Direction \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Clear (up) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s23\li30\ri30\sl-80\slmult1\keepn\brdrb\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Note 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Some types of events can pass additional information in other registers, and other types of events do not always pass all the information listed above. Exceptions are noted. 
\par \pard\plain \s20\li30\ri30\sa40\sl-140\slmult1\brdrt\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The event callback procedure can modify EAX, EBX, ECX, EDX, ESI, and EDI. It must return with interrupts enabled and the direction flag cleared. 
\par Since events are not synchronized with the virtual machine, the contents of the client registers are unpredictable. Altering the contents of the client registers can cause the virtual machine to get very confused. You must save the client state before mod
ifying the client registers, then restore them before returning from the event. 
\par Since event callbacks can be called while the current 
thread is blocked on a semaphore or other synchronization object, events should be extremely careful not to create deadlocks by attempting to claim a resource that may already be owned by the current thread. For example, consider a thread which takes a re
source, then blocks waiting for some other operation to complete, with the intention of releasing the resource after the other operation has completed. While waiting for the semaphore to be signalled, that thread is used to perform an event callback is wh
ich attempts to take the same resource. The system is now deadlocked, because the event will wait indefinitely for the resource, which cannot be released until the event returns. 
\par There are many important examples of this deadlock risk which are common sources of problems, so they will be given explicit attention. 
\par Event callbacks may not touch pageable data or otherwise cause paging unless it can be ensured that the thread processing the event callback is not in the middle of its own swapping operation. One 
way to ensure this is to schedule the event as PEF_Wait_Not_Crit, because the critical section is held during paging. Another way to is to check explicitly whether paging is allowed now (e.g., {\b PAGESWAP_Test_IO_Valid}
). Note that allocating memory from the VMM page manager or heap manager may result in paging, so services like {\b _PageAllocate} and {\b _HeapFree}
 are also forbidden unless it has already been determined that the thread is not paging. List management functions like {\b List_Allocate} are safe to call, provided the list was not created with the LF_HEAP or LF_SWAP bits. 
\par Event callbacks may not access the registry unless it can be ensured that the thread processing the event callback is itself not active in the registry. This can be done by using the PEF_Wait_Not_Nested_Exec restriction on the event. 
\par Even if you have ensured that blocking on a semaphore or other synchronization object will not cause a deadlock, bear in mind that blocking at event time seriously impacts the system's ability to multitask smoothly
. The thread that got selected to service an event might own resources at ring 3, such as the Win16Mutex, for which other threads are waiting. (Indeed, the fact that the thread is running at all makes it much more likely that it owns such a resource.) Whi
le the event is in progress, those resources remain held by the thread even though the thread isn't doing anything with them. 
\par Thus, as a general rule, you should not block at event time. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following groups of event services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Group \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Elements \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Global event services \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Call_Global_Event}, {\b Cancel_Global_Event}, {\b GlobalEventCallback}, {\b 
Schedule_Global_Event}\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VM and thread event services \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
Call_VM_Event}, {\b Cancel_Thread_Event}, {\b Cancel_VM_Event}, {\b EventCallback}, {\b Schedule_Thread_Event}, {\b Schedule_VM_Event}\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Priority event services \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Call_Priority_VM_Event}, {\b Cancel_Priority_VM_Event}, {\b PriorityEventCallback}\cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Restricted event services \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Call_Restricted_Event}, {\b Cancel_Restricted_Event, RetrictedEventCallback}\cell 
\pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Miscellaneous event services \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
_AtEventTime, Register_PEF_Provider}\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Global Event Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Global events are the least restrictive events. They can be processed by any thread or virtual machine. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_Global_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 GlobalEventCallback
\par mov     edx, RefData
\par VMMcall Call_Global_Event
\par mov     [EventHandle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Calls the specified event callback function immediately or schedules a global event. This is an asynchronous service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns zero in ESI zero if the service calls the callback function. Otherwise, returns the event handle in ESI. The event handle can be used in subsequent calls to the Cancel_Global_Event service to cancel the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of reference data to pass to the event callback function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Any virtual machine can process the event, so the system does not switch tasks before calling the function. The callback function can carry out any actions, 
and use any VMM services. For a description of the callback function, see {\b GlobalEventCallback}. For information about event callback functions, see {\i Event Callbacks}. 
\par {\b Cancel_Global_Event}, {\b GlobalEventCallback}, {\b Schedule_Global_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Global_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, EventHandle
\par VMMcall Cancel_Global_Event
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancels an event that was previously scheduled using the {\b Schedule_Global_Event} or {\b Call_Global_Event} service. A virtual device must {\i not} attempt to cancel an event if the callback function for
 the event has already been called. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the event to cancel. This parameter can be zero to indicate that no event should be canceled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The event callback function typically sets the event handle to zero so that subsequent calls by the virtual machine to this service do not cause errors. 
\par {\b Call_Global_Event}, {\b Schedule_Global_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 GlobalEventCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VMHandle
\par mov     edx, RefData
\par mov     ebp, OFFSET32 Client_Reg_Struc
\par call    [GlobalEventCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing of a global event. {\b GlobalEventCallback} is a programmer-defined callback function installed by the {\b Call_Global_Event} or {\b Schedule_Global_Event}
 service. The callback function can modify the EAX, EBX, ECX, EDX, ESI, and EDI registers. It must return with interrupts enabled and the direction flag clear (up). 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data supplied when the event was scheduled. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the contents of the virtual machine's registers. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Call_Global_Event}, {\b Cancel_Global_Event}, {\b Client_Reg_Struc}, {\b Schedule_Global_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Schedule_Global_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 GlobalEventCallback
\par mov     edx, RefData
\par VMMcall Schedule_Global_Event
\par mov     [EventHandle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Schedules a global event, which is an event that does not require a specific virtual machine to process it. Since any virtual machine can process the event, the system does not switch tasks before calling the function. This is an asynchronous service. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the event handle in ESI. The handle can be used in a subsequent call to the Cancel_Global_Event service to cancel the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i GlobalEventCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function. For more information about the callback function, see {\b GlobalEventCallback}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the event callback function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The callback function can carry out any actions and use any VMM services, subject to the remarks in {\b GlobalEventCallback}. 
\par {\b Call_Global_Event}, {\b Cancel_Global_Event}, {\b GlobalEventCallback}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 VM and Thread Event Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_VM_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     esi, OFFSET32 EventCallback
\par mov     edx, RefData
\par VMMcall Call_VM_Event
\par mov     [EventHandle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Calls the event callback function immediately or schedules an event for the specified virtual machine. This is an asynchronous service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns zero in ESI f the service calls the callback function. Otherwise, returns the event handle in ESI. The event handle can be used in subsequent calls to the Cancel_VM_Event service to cancel the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to process the event. This value must be a valid VM handle. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. For more information about the callback function, see {\b EventCallback}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to pass to the event callback function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Since the specified virtual machine must process the event, the system carries out a task switch if necessary before calling the function. The callback function can carry out any actions and use any VMM services. 
\par For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Cancel_VM_Event}, {\b EventCallback}, {\b Schedule_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Thread_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     esi, EventHandle
\par VMMcall Cancel_Thread_Event
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancels an event that was previously scheduled using the {\b Schedule_Thread_Event} service. A virtual device must {\i not}
 attempt to cancel an event if the callback function for the event has already been called. This is an asynchronous service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread for which the event is to be canceled. This value must be a valid thread handle and it must equal the thread handle used when the event was originally scheduled. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the event to cancel. This parameter can be zero to indicate that no event should be canceled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The event callback function typically sets the event handle to zero so that subsequent calls by the thread to this service do not cause errors. 
\par {\b Schedule_Thread_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_VM_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     esi, EventHandle
\par VMMcall Cancel_VM_Event
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancels an event that was previously scheduled using the {\b Schedule_VM_Event} or {\b Call_VM_Event} service. A virtual device must {\i not}
 attempt to cancel an event if the callback function for the event has already been called. This is an asynchronous service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which the event is to be canceled. This value must be a valid thread handle and it must equal the thread handle used when the event was originally scheduled. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the event to cancel. This parameter can be zero to indicate that no event should be canceled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The event callback function typically sets the event handle to zero so that subsequent calls by the virtual machine to this service do not cause errors. 
\par Do {\i not} use this service to cancel events scheduled using the {\b Call_Priority_VM_Event}, {\b Call_Thread_Event}, or {\b Call_Restricted_Event} service. You must cancel priority events using the {\b Cancel_Priority_VM_Event} service. 
\par {\b Call_Priority_VM_Event}, {\b Call_VM_Event}, {\b Cancel_Priority_VM_Event}, {\b Schedule_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 EventCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VMHandle
\par mov     edi, ThreadHandle
\par mov     edx, RefData
\par mov     ebp, OFFSET32 Client_Reg_Struc
\par call    [EventCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing of a event for a virtual machine. {\b EventCallback} is a programmer-defined callback function installed by the {\b Call_VM_Event}, {\b Schedule_Thread_Event}, or {\b 
Schedule_VM_Event }service. The callback function can modify the EAX, EBX, ECX, EDX, ESI, and EDI registers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data supplied when the event was originally scheduled. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the contents of the virtual machine's registers. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Call_VM_Event}, {\b Cancel_VM_Event}, {\b Client_Reg_Struc}, {\b Schedule_Thread_Event}, {\b Schedule_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Schedule_Thread_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     esi, OFFSET32 EventCallback
\par mov     edx, RefData
\par VMMcall Schedule_Thread_Event
\par mov     [EventHandle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Schedules an event for the specified thread. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the event handle in ESI. The event handle can be used in subsequent calls to the Cancel_Thread_Event service to cancel the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to process the event. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function. For more information about the callback function, see {\b EventCallback}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to pass to the callback function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Since the specified thread must process the event, the system carries out a task switch (if necessary) before calling the function. The callback function can carry out any actions, and use any VMM services. The system completes the event processing before
 the VMM returns from the current interrupt. For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Cancel_Thread_Event}, {\b EventCallback}, {\b Schedule_Global_Event}, {\b Schedule_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Schedule_VM_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     esi, OFFSET32 EventCallback
\par mov     edx, RefData
\par VMMcall Schedule_VM_Event
\par mov     [EventHandle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Schedules an event for the specified virtual machine. This is an asynchronous service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the event handle in ESI. The event handle can be used in subsequent calls to the Cancel_VM_Event service to cancel the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to process the event. This value must be a valid VM handle. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function. For more information about the callback function, see {\b EventCallback}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to pass to the callback function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Since the specified virtual machine must process the event, the system carries out a task switch (if necessary) before calling the callback function. The function can carry out any actions and use any VMM services. The system completes the event processin
g before the VMM returns from the current interrupt. 
\par For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Call_VM_Event}, {\b Cancel_VM_Event}, {\b EventCallback}, {\b Schedule_Global_Event}, {\b Schedule_Thread_Event}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Priority Event Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_Priority_VM_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, PriorityBoost
\par mov     ebx, VMHandle
\par mov     ecx, Flags
\par mov     edx, RefData
\par mov     esi, OFFSET32 PriorityEventCallback
\par mov     edi, TimeOut
\par VMMcall Call_Priority_VM_Event
\par mov     [EventHandle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Calls the callback function immediately or schedules a priority event for the specified virtual machine. This is an asynchronous service. Uses Flags and ESI. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns zero in ESI if the callback function was called immediately. Otherw
ise, returns the event handle in ESI. The handle can be used in a subsequent call to the Cancel_Priority_VM_Event service to cancel the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PriorityBoost}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Priority boost for the virtual machine. This parameter must be a value such that when added to the current execution priority, the result is within the range Reserved_Low_Boost to Reserved_High_Boost. This parameter can be 0 if no boost is necessary. Comm
on priority boost values, from lowest to highest, are as follows: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_Low_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Cur_Run_VM_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use to boost the priority of each virtual machine, in turn, forcing them to run for their allotted time slices. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Low_Pri_Device_Boost \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use for operations that need timely processing but are not time critical. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 High_Pri_Device_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use for time-critical operations that should not circumvent the critical section boost. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Critical_Section_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use to boost the priority of the virtual machine whenever it enters a critical section (calls 
{\b Begin_Critical_Section)}. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Time_Critical_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use for operations that require immediate processing, even when another virtual machine is in a critical section. For example, VPICD uses this when simulating hardware interrupts. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_High_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Forgetting to pass a priority value in the EAX register is a common error. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to process the event. This value must be a valid VM handle. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A combination of these action flags: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Always_Sched \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Event is always scheduled, meaning the callback function is never called immediately. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Dont_Unboost \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Priority of the virtual machine is not reduced after return from callback function. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
PEF_Time_Out \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Specifies that time-out value in the EDI register should be used. Available in Windows version 3.1 or later. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_For_STI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callback function is not called until the virtual machine enables interrupts in all threads. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_Not_Crit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Callback function is not called until the virtual machine is not in a critical section or time-critical operation. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 PEF_Wait_Not_Time_Crit, PEF_Wait_Not_HW_Int \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Callback function is not called until the thread priority is below TIME_CRITICAL_BOOST. Useful to prevent an event from occurring while an interrupt is being simulated into a VM. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 
\f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to pass to the callback function. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. For more information about the callback function, see {\b PriorityEventCallback}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of milliseconds until the event times out. The service uses this parameter only if the PEF_Time_Out value is specified by {\i Flags}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system carries out a task switch to the specified virtual machine if it is not the current virtual machine. If {\i PriorityBoost}
 is not zero, the service boosts the priority of the virtual machine before calling the callback function. 
\par If the amount of time specified by {\i TimeOut} elapses before the system can
 switch to the virtual machine, the system sets the carry flag and calls the callback function immediately regardless of which virtual machine is currently running. In this case, any requested priority boost is canceled even if {\i Flags}
 specified the PEF_Dont_Unboost value. The callback function should always check the carry flag to determine whether a time out occurred. 
\par For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Adjust_Exec_Priority}, {\b Begin_Critical_Section}, {\b Call_When_Not_Critical}, {\b Call_VM_Event}, {\b Cancel_Priority_VM_Event}, {\b PriorityEventCallback}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Priority_VM_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, EventHandle
\par VMMcall Cancel_Priority_VM_Event
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancels an event that was previously scheduled using the {\b Call_Priority_VM_Event} service. A virtual device must {\i not}
 attempt to cancel an event if the callback function for the event has already been called. Uses ESI, Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the event to cancel. This parameter can be zero to indicate that no event should be canceled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The event callback function typically sets the event handle to zero so that subsequent calls by the virtual machine to this service do not cause errors. 
\par This service cancels any priority boost associated with the event, even if the PEF_Dont_Unboost value was specified when the event was scheduled. 
\par Do {\i not} use this service to cancel events scheduled using the {\b Call_VM_Event} or {\b Schedule_VM_Event} services. You must cancel virtual machine events using the {\b Cancel_VM_Event} service. 
\par {\b Call_Priority_VM_Event}, {\b Call_VM_Event}, {\b Cancel_VM_Event}, {\b Schedule_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 PriorityEventCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VMHandle
\par mov     edi, ThreadHandle
\par mov     edx, RefData
\par mov     ebp, OFFSET32 Client_Reg_Struc
\par ;set up CY flag if appropriate
\par call    [PriorityEventCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing of a priority event for a virtual machine or thread. {\b PriorityEventCallback} is a programmer-defined callback function installed by the {\b Call_Priority_VM_Event}
 service. The callback function can modify the EAX, EBX, ECX, EDX, ESI, EDI, and Flags registers. It must return with interrupts enabled and the direction flag clear (up). 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the event did not time out; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. If a timeout occurs, this handle may not be valid. In such cases, the callback function should use the {\b Get_Cur_VM_Handle}
 service to get the handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current thread. If a timeout occurs, this handle may not be valid. In such cases, the callback function should use the {\b Get_Cur_Thread_Handle}
 service to get the handle of the current thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data supplied when the event was scheduled. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the contents of the virtual machine's registers. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the PEF_Time_Out bit was set when the event was scheduled, additional information is given in the
 flags register, as described in Call_Priority_VM_Event. Such an event callback procedure should begin as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     \tab hThisEvent, 0    ; (See 'Cancelling Events')
\par                          ; (Must preserve carry!)
\par jc      \tab Event_Timed_Out  ; Carry set means event timed out
\par                          ; Else event processed normally
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If a timeout occurs, any priority boost is automatically canceled, even if the the PEF_Dont_Unboost flag was specified in the Call_Priority_VM_Event function that initiated the event. 
\par For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Call_Priority_VM_Event}, {\b Client_Reg_Struc}, {\b Get_Cur_Thread_Handle}, {\b Get_Cur_VM_Handle}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Restricted Event Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_Restricted_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, PriorityBoost
\par mov     ebx, Handle
\par mov     ecx, Flags
\par mov     edx, RefData
\par mov     esi, OFFSET32 RestrictedProc
\par mov     edi, Timeout
\par VMMcall Call_Restricted_Event
\par mov     [EventHandle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Combines the functionality of the {\b Call_VM_Event}, {\b Call_When_VM_Ints_Enabled}, {\b Call_When_Not_Critical}, and {\b Adjust_Exec_Priority} services into one service. 
\par The service allows a VxD to specify flags which place restrictions on when the VMM can call the event callback function. Restrictions include such things as the event callback function can be called only when interrupts are enabled, only when the critical
 section is unowned, and so on. 
\par As with all event services, this service can be called from an interrupt handler. This is an asynchronous service. Uses ESI and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns zero in ESI if the callback function was called immediately. Otherwise, returns the event handle in ESI. The handle can be used in a subsequent call to the Cancel_Restricted_Event service to cancel the event. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PriorityBoost}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Priority boost for the virtual machine. This parameter must be a value such that when added to the current execution priority, the result is within the range Reserved_Low_Boost to Reserved_High_Boost. This parameter can be 0 if no boost is necessary. 
Common priority boost values, from lowest to highest, are as follows: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_Low_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Low_Pri_Device_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use for operations that need timely processing but are not time critical. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 High_Pri_Device_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use for time-critical operations that should not circumvent the critical section boost. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Critical_Section_Boost \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use to boost the priority of the virtual machine whenever it enters a critical section (calls {\b Begin_Critical_Section)}. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Time_Critical_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use for operations that require immediate processing, even when another virtual machine is in a critical section. For example, VPICD uses this when simulating hardware interrupts. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_High_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
For global events, the priority boost only goes into effect after restrictions have been met; that is, just before the VMM calls the event callback function. For VM events, the priority boost is originally applied to the whole VM, but will be moved to the
 thread that the event is called on unless {\i Flags} specifies the PEF_Dont_Unboost flag. 
\par Forgetting to pass a priority value in the EAX register is a common error. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Handle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
If the PEF_Thread_Event flag is specified, this parameter contains the handle of the thread for which the event callback is requested; Otherwise, the value of this parameter is zero when the event is a global event or the handle of the virtual machine for
 which the VM event callback is requested. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A combination of these action flags: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Always_Sched \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Event is always scheduled, meaning the callback function is never called immediately. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Dont_Unboost \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Priority of the virtual machine or thread is not reduced after return from callback function. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Thread_Event \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i Handle}
 is the handle of the thread for which the event is requested. The callback function is called only in the context of the thread. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Time_Out 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The time-out value in the EDI register should be used. Available in Windows version 3.1 or later. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_For_STI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callback function is not called until the virtual machine enables interrupts in all threads. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_Not_HW_Int \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Callback function is not called while the VPICD is simulating a hardware interrupt. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_In_PM \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callback function is not called until the virtual machine or thread is executing in protected mode. Use this flag with caution \emdash 
 it may never happen for VM other than the system VM unless an MS-DOS Protected Mode Interface (DPMI) application is running. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_Not_Crit 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callback function is not called until the virtual machine is not in a critical section or time-critical operation. See remarks below. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_Not_Nested_Exec \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Callback function is not called while the virtual machine is in a nested execution block. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_For_Thread_STI \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callback function is not called until interrupts are enabled at ring 3 in the current thead. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 PEF_Ring0_Event \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callback function completes at ring 0. See remarks below. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Wait_Crit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Callback function is not called until (1) the critical section is free, or (2) the critical section is owned by the current thread. See remarks below. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 PEF_Wait_Crit_VM \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callback function is called when critical section not owned by other thread in VM. See remarks below. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PEF_Process_Last \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 See description below. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to pass to the callback function. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. For more information about the callback function, see {\b RestrictedEventCallback}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of milliseconds until the event times out. The service uses this parameter only if the PEF_Time_Out value is specified by {\i Flags}. 
\par If a timeout occurs before the restrictions are met, the event callback will be called with carry set. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A VxD uses the {\b Call_Restricted_Event} service for purposes that include the following: 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab To wait until a virtual machine enables interrupts and the critical section is free so the VxD can call
 MS-DOS or some other non-reentrant code. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
To boost a virtual machine's priority and wait until the virtual machine enables interrupts to simulate an interrupt type event. For example, the VNETBIOS uses this service for asynchronous network request POST call-backs. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab To force an event to be processed in another virtual machine by boosting the virtual machines execution priority. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Global restricted events can happen in any VM that meet
s the restriction. VM-restricted events can only happen in the specified VM; and now that multiple threads are supported in the system VM, restricted thread events can be specified to only happen in the one thread context (although specifying that interru
pts must be enabled for a thread event will only happen when interrupts are enabled in all threads of that VM.) 
\par The PEF_Wait_Not_Crit flag will delay the processing of the event until the critical section is free and the priority of the current thread or v
irtual machine is less than Critical_Section_Boost. One should be careful not to pass too large a PriorityBoost when this flag is set. (In particular, passing a PriorityBoost greater than or equal to Critical_Section_Boost will prevent the event from ever
 satisfying its own restrictions.) 
\par The PEF_Wait_For_Thread_STI flag differs from the PEF_Wait_For_STI flag in that the former checks the status of only the current thread, whereas the latter checks the status of all threads in the virtual machine. The two flags may not be combined. 
\par The PEF_Ring0_Event flag indicates that the event can complete entirely at ring 0 without faulting. The requirements for 'ring 0' events are very strict, and apply to the event callback procedure and anything it calls, directly or indirectly. Although som
e rules in the system are relaxed if 32-bit disk access is enabled, these rules remain in full force. Ring 0 events must restrict memory accesses to locked code and locked data. They must not call Begin_Nest_Exec, Resume_Exec, Ex
ec_VxD_Int, Exec_Int, or any service or procedure that in turn calls one of those services. They must not block on any synchronization objects. They must not adjust any thread's execution priority. In brief, they must guarantee that they will carry out th
eir work to completion without running any code at ring 3, and without causing a task switch. In exchange for these guarantees, ring 0 events can be processed even if a thread has specifically requested that events not be processed. Ring 0 events are very
 dangerous. It is strongly recommended that they be avoided entirely. The flag is listed here for completeness. 
\par The PEF_Wait_Crit flag indicates that the event may be processed only if the current thread owns the critical section, or if the critical section is unowned. This restriction may be applied only to global events (Handle = 0). The event callback can then b
e assured that it can call Begin_Critical_Section without blocking. PEF_Wait_Crit events allow you to ensure that a section of code be executed as
 soon as possible under the protection of the critical scetion. In Windows 3.1, this was done by a chain of events which repeatedly determine the critical section owner, then either perform the requested action or reschedule the same event for the current
 critical section owner and trying again. Since the ownership of the critical section can change between the time the event is scheduled and the time the event is processed, this chain of events may continue for several iterations before finally completin
g. (If you draw a picture, you can see why this is informally known as 'chasing the critical section'.) Starting with Windows 95, the PEF_Wait_Crit flag is the recommended way of accomplishing this. 
\par The PEF_Wait_Crit_VM flag may be set only if Handle is equal to the System VM handle. It indicates that the event may be processed when the current thread is a thread in the System VM, and one of the following conditions is also met: (1) The critical sect
ion is unowned. (2) The critical section is owned by the cu
rrent thread. (3) The critical section is owned by a thread not in the System VM. Writers of virtual device drivers should not normally have need for this flag. It is documented here for completeness. 
\par The PEF_Process_Last allows a limited degree of control over the order in which events are processed. Normally, global events are processed first, then VM events, then thread events. This flag causes the event to be removed from consideration during the i
nitial check for processable events. If the initial che
ck fails to find any events, then a second pass is made during which this event can be selected. The only time this flag should be set is on a VM event (Handle is a valid VM handle), to indicate that the current thread should have no thread events when th
e VM event is processed. It does not add the event to the end of a list. Writers of virtual device drivers should not normally have need for this flag. It is documented here for completeness. 
\par {\b Adjust_Exec_Priority}, {\b Begin_Critical_Section}, {\b Call_VM_Event}, {\b Call_When_Not_Critical}, {\b Call_When_VM_Ints_Enabled}, {\b Cancel_Restricted_Event}, {\b RestrictedEventCallback}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Restricted_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, EventHandle
\par VMMcall Cancel_Restricted_Event
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancels an event that was previously scheduled using the {\b Call_Restricted_Event} service. A virtual device must {\i not}
 attempt to cancel an event if the callback function for the event has already been called. Uses ESI, Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the event to cancel. This parameter can be zero to indicate that no event should be canceled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The event callback function typically sets the event handle to zero so that subsequent calls by the virtual machine to this service do not cause errors. 
\par This service cancels any priority boost associated with the event, even if the PEF_Dont_Unboost value was specified when the event was scheduled. 
\par Do {\i not} use this service to cancel events scheduled using the {\b Call_VM_Event} or {\b Schedule_VM_Event} services. You must cancel virtual machine events using the {\b Cancel_VM_Event} service. 
\par {\b Call_Restricted_Event}, {\b Call_VM_Event}, {\b Cancel_VM_Event}, {\b RestrictedEventCallback}, {\b Schedule_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 RestrictedEventCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edi, ThreadHandle
\par mov     edx, RefData
\par mov     ebp, OFFSET32 Client_Reg_Struc
\par call    [RestrictedEventCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing of a restricted event for a virtual machine or thread. {\b RestrictedEventCallback} is a programmer-defined callback function installed by the {\b Call_Restricted_Event}
 service. The callback function can modify the EAX, EBX, ECX, EDX, ESI, EDI, and Flags registers. The callback function must return with interrupts enabled and the direction flag clear (up). 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. If a timeout occurs, this handle may not be valid. In such cases, the callback function should use the {\b Get_Cur_VM_Handle}
 service to get the handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current thread. If a timeout occurs, this handle may not be valid. In such cases, the callback function should use the {\b Get_Cur_Thread_Handle}
 service to get the handle of the current thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data supplied by the virtual machine that initiated the priority event. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the contents of the virtual machine's registers. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If a timeout occurs, any priority boost is automatically canceled, even if the the PEF_Dont_Unboost flag was specified in the Call_Restricted_Event function that initiated the event. 
\par If the PEF_Time_Out bit was set when the event was scheduled, additional information is given in the flags register, as described in Call_Restricted_Event. Such an event callback procedure should begin as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov  hThisEvent, 0  \tab    ; (See 'Cancelling Events')
\par                        ; (Must preserve carry!)
\par jc   Event_Timed_Out\tab    ; Carry set means event timed out
\par                        ; Else event processed normally
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For additional information about event callbacks, see {\i Event Callbacks}. 
\par {\b Call_Restricted_Event}, {\b Cancel_Restricted_Event}, {\b Client_Reg_Struc}, {\b Get_Cur_Thread_Handle}, {\b Get_Cur_VM_Handle}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Miscellaneous Event Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _AtEventTime 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _AtEventTime
\par mov     fEvent, eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Tests whether the current thread is processing an event. Uses EAX, ECX, EDX, and Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns non-zero in EAX if the thread is processing an event, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Register_PEF_Provider 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, PEFFlag
\par mov     ecx, 0 ; reserved, must be zero
\par VMMCall Register_PEF_Provider
\par jc      Error_Handler
\par mov     [VM_State_Off], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the offset of the restricted-event flags in a virtual machine's control block. An external component can set the flags to indicating whether a restricted condition is met. Uses EAX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the offset of the restricted-event flags (a double-word value). An external component can toggle flag bits at this offset. Setting a bit means the corresponding restriction is not met. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PEFFlag}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Flag bit to set or clear. Currently, the only valid flag is PEF_WAIT_NOT_HW_INT_BIT. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The VPICD uses this service to indicate whether it is simulating a hardware interrupt into a VM. It sets the PEF_WAIT_NOT_HW_INT_BIT bit when it is about to simulate an interrupt into a virtual machine, and clears the bit when it finishes simulating the i
nterrupt. 
\par This service is intended to be used by only by internal Windows components, it is not for general use. 
\par {\b Call_Restricted_Event}, {\b Cancel_Restricted_Event}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 74}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 6 Free Physical Page Management{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 73}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 6
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Free Physical Page Management 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Free Physical Page Management 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Free physical pages are unused physical addresses that the VMM can assign to
 committed pages when they are paged in. The Windows loader initializes the list of free physical pages. If the loader does not find certain pages that are actually available, virtual devices can use VMM services to add these to the free list. 
\par The {\b _AddFreePhysPage} service notifies the memory manager of additional physical pages. The {\b _PageResetHandlePAddr}
 service also makes new physical pages available to the memory manager. However, this service simultaneously maps a range of pages in the specified memory block to the new physical pages. 
\par Virtual devices must not attempt to add physical pages that are already under the control of the memory manager. You can determine whether physical pages exist and are recognized by the memory manager by using the {\b _GetPhysPageInfo} service. 
\par The system creates linear address aliases for physical memory only when requested through the {\b _MapPhysToLinear} service. This is different from Windows 3.1, which created a giant linear address region to alias all of physical memory. (The
 change is required in order to support machines with more than 16MB of memory.) Therefore, it is imperative that linear address aliases for physical memory always be obtained through calls to {\b _MapPhysToLinear}. Do not assume that {\b _MapPhysToLinear
}({\i N}, 1, 0) is the same as _{\b MapPhysToLinear}(0, 1, 0) + {\i N} for all values of {\i N}. When you create a linear address alias, the second parameter indicates the number of bytes for which an alias is
 required; it is only for this number of bytes that the mapping of linear addresses to physical addresses remains contiguous. Linear address aliases are valid until the system is shut down. 
\par See also {\b _AddFreePhysPage}, {\b _GetPhysPageInfo}, {\b _MapPhysToLinear}, {\b _PageResetHandlePAddr}
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _AddFreePhysPage 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _AddFreePhysPage, <PhysPgNum, nPages, flags>
\par 
\par mov     [PagesAdded], eax       ; 0 = none, 1 = some, 2 = all
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Adds one or more physical pages to the free memory pool. Virtual devices
 use this service to add pages that the Windows loader could not find, but that the virtual device did find. For example, the V86MMGR device adds any unused physical pages it finds when using the Global EMM Import function of a 386 LIMulator. Uses EAX, EC
X, EDX, and Flags. 
\par This service is only available during initialization, and only in Windows version 3.1 and later. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with one of these values in the EAX register: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 None of the specified physical pages were added to the free pool. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 1 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Some, but not all, of the specified physical pages were added. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 2 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
All of the specified physical pages were added. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PhysPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Physical page number of the first page to add. The page number must be greater than or equal to 110h; only extended memory pages may be added to the pool. The specified pages must be read/write physical memory pages, and must be available for use at any t
ime. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of physical pages to add. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or the following value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 AFPP_RECEXIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The physical memory being added will be automatically restored to its original state (original contents, and in an unused and unmapped state) immediately before System_Exit. No more than 32 pages can be added per call using this feature; to add more than 
32 pages, make multiple calls. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device must {\i not} attempt to use pages once it has added them to the free pool, or attempt to add pages that are already available to the system. 
\par This service returns an error if the number of pages to add exceeds the limit of the internal data structure the system uses to manage the free pool. The internal data structure is allocated during initialization and cannot be modified. 
\par Most virtual devices do not need to use this service. 
\par {\b _GetFreePageCount}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetPhysPageInfo 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL GetPhysPageInfo(ULONG iPage, ULONG nPages, ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Indicates whether any, all, or none of the specified physical pages exist.
 This service is available even after initialization, but is pageable, meaning that if it is called after initialization, it may block and/or cause a task-switch before returning. Uses EAX, ECX, EDX, and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns PHYSINFO_NONE (0) if the pages are nonexistent, PHYSINFO_SOME (1) if the some of the pages exist, and PHYSINFO_ALL (2) if the all the pages exist. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i iPage} and {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Page number of the first physical page in the range, and the number of physical pages in the range. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Must be zero. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _MapPhysToLinear 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _MapPhysToLinear, <PhysAddr, nBytes, flags>
\par 
\par cmp     eax, 0FFFFFFFFh     ; 0FFFFFFFFh if not addressable
\par je      not_addressable
\par mov     [Address], eax      ; address of first byte
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the linear address of the first byte in the specified range of physical addresses. Uses EAX, ECX, EDX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the ring-0 linear address of the first byte of the physical region,
 if successful. The EAX register contains 0FFFFFFFFh if the specified range is not addressable. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PhysAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 32-bit physical address of the start of the region to examine. Physical addresses start at 0, thus the address of physical page 0A0h is 0A0000h. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nBytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Length of the physical region, in bytes. The service uses this parameter to verify that the entire range is addressable. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is intended to be used to examine device-specific physical memory. Virtual devices must {\i not} use this service for any other purpose. 
\par Because physical addresses do not move, the linear address returned by this service remains valid until the system is shut down. Virtual devices should be careful not to use this service in a manner that wastes linear address space. 
\par The following example returns a linear address for 64 kilobytes of memory starting at the physical page 0A0h: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 VMMcall _MapPhysToLinear,<0A0000h,10000h,0>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Since physical memory is mapped contiguously, the linear address for
 page 0A1h is 4096 bytes beyond the return linear address. Note, however, that no information can be concluded about the linear addresses for physical pages 9Fh or 0B0h, because they lie outside the 64KB range requested. If a virtual device needs linear a
ddress aliases for those pages, it must call {\b _MapPhysToLinear} separately for those pages. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageResetHandlePAddr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _PageResetHandlePAddr, <hMem, PgOff, nPages, PhysPgNum, flags>
\par 
\par or      eax, eax                ; nonzero if substituted, zero if error
\par jz      not_substituted
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Substitutes one or more pages in a memory block with physical pages not previously available to the system. This service is similar to the {\b _AddFreePhysPage}
 service, but allows memory to be used in a slightly different way. Uses EAX, ECX, EDX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hMem}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle (base linear address) of a memory block. This handle must have been previously created using the {\b _PageAllocate} or {\b _PageReAllocate} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PgOff}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset in pages from the start of the memory block to the first page to be substituted. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to substitute. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PhysPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Number of the first physical page to substitute into the memory block. The page number must be greater than or equal to 110h; only extended memory pages may be added to the block. The specified pages must be read/write ph
ysical memory pages, and must be available for use at any time. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is only available for Windows version 3.1 and later. 
\par This service returns an error if the sum of the {\i PgOff} and {\i nPages} parameters is greater than the size of the memory block. 
\par A virtual device must {\i not} attempt to use pages once it has added them to the free pool, or attempt to add pages that are already available to the system. 
\par This service returns an error if the number of pages to add exceeds the limit of the internal data structure the system uses the manage the free pool. The internal data structure is allocated during initialization and cannot be modified. 
\par This service converts pages that are substituted into the block to fixed pages. These pages are always locked, and cannot be unlocked. 
\par This service maps a new physical page in at the specified locations and puts the existing physical memory in the free list. The contents of the freed pages are not preserved. 
\par Most virtual devices do not need to use this service. 
\par {\b _AddFreePhysPage}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 80}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 7 Information Services{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 81}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 7
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Information Services 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Information Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following information services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Cur_VM_Handle}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns current virtual machine handle. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Next_VM_Handle}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the next valid virtual machine handle. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Sys_VM_Handle}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the system virtual machine handle. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_VMM_Reenter_Count}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns number of time VMM re-entered. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_VMM_Version}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the VMM version number. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b GetSet_HMA_Info}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns or sets HMA information. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Test_Cur_VM_Handle}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Tests for current virtual machine handle. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Test_DBCS_Lead_Byte}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Tests for legal DBCS lead byte. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Test_Debug_Installed}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Tests for debugger. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Test_Sys_VM_Handle}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Test for system virtual machine handle. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Validate_VM_Handle}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Validates a virtual machine handle. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Cur_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Cur_VM_Handle
\par 
\par mov     [VM], ebx         ; current VM handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets the handle of the currently running virtual machine. This is an asynchronous service. Uses EBX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the current virtual machine in the EBX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Sys_VM_Handle}, {\b Test_Cur_VM_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Next_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM           ; VM handle
\par VMMcall Get_Next_VM_Handle
\par 
\par mov     [NextVM], ebx     ; next VM handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the handle of the next virtual machine in the virtual machine list maintained by the system. Uses EBX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the next virtual machine in the EBX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of a virtual machine. The return value identifies the next virtual machine after the specified virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Although each virtual machine appears only once in the list, the order of the handles is not guaranteed. The list is circular, so a virtual device scanning the list should stop scanning when the latest handle returned is eq
ual to the first handle returned. 
\par The following example modifies the state of every virtual machine by using the {\b Get_Next_VM_Handle} service to retrieve handles of all valid virtual machines: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16     VMMcall Get_Cur_VM_Handle
\par 
\par Scan_Loop:
\par 
\par     ; modify the VM state
\par 
\par     VMMcall Get_Next_VM_Handle
\par     VMMcall Test_Cur_VM_Handle
\par     jne     Scan_Loop
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Cur_VM_Handle}, {\b Test_Cur_VM_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 GetSet_HMA_Info 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, Action         ; zero to get, nonzero to set
\par mov     dx, A20Enable       ; A20 enable count (if ecx is nonzero)
\par VMMcall GetSet_HMA_Info
\par 
\par mov     [NoGlobalHMA], eax  ; nonzero if no global HMA user
\par mov     [XMSCallAddr], ecx  ; loader XMS call address
\par mov     [A20Enable], edx    ; A20 enable count before Windows started
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets and sets information related to the high-memory area (HMA) region. This service is always valid (not restricted to initialization). Uses EAX, ECX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the following information in the following registers: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Specifies whether a global HMA user is present. If this register is 0, Windows did not allocate the HMA meaning either there is a global HMA user or there is no HMA. If this register is nonzero, Windows has allocated the HMA, meaning there is no global HM
A user. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Specifies the V86-mode address (segment:offset) that Windows used to call the XMS driver when loading. The segment address is in the high 16 bits of the register. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Specifies the A20 enable count before Windows started. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Action}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying whether to get or set information. If zero, the service gets the HMA information; otherwise it sets the information. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i A20Enable}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A20 enable count to set for the Windows VMM loader. The service uses this parameter only if the {\i Action} parameter is nonzero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service lets the XMS driver (in the V86MMGR device) determine whether a global HMA user existed before Windows started and gives the driver access to the HMA enable count. Other devic
es should not call this service. 
\par The global HMA flag and loader XMS call address cannot be set. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Sys_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Sys_VM_Handle
\par 
\par mov     [SysVM], ebx            ; system VM handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the handle of the system virtual machine. This is an asynchronous service. Uses EBX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the system virtual machine in the EBX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Cur_VM_Handle}, {\b Test_Sys_VM_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_VMM_Reenter_Count 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_VMM_Reenter_Count
\par 
\par jecxz   not_reentered           ; ecx is zero if VMM not re-entered
\par mov     [Count], ecx            ; otherwise, number of times re-entered
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Returns the number of times the VMM has been re-entered as a result of a hardware interrupt, page fault, or other processor exception. Virtual devices typically use this service to determine whether they can call VMM services that do not re-enter. Uses Fl
ags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the number of times the VMM has be
en reentered in the ECX register (zero if the VMM has not been reentered). 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
If this service returns a nonzero value, a virtual device may call only VMM services that are asynchronous. If a virtual device must call other VMM services, the virtual device can schedule an event using a service such as {\b Schedule_Global_Event}
. The system calls the event's callback procedure when all VMM services are available. 
\par The {\b Call_Global_Event} and {\b Call_VM_Event} services call this service to determine whether the event callback procedure should be called immediately. 
\par {\b Call_Global_Event}, {\b Call_VM_Event}, {\b Schedule_Global_Event}, {\b Schedule_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_VMM_Version 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_VMM_Version
\par 
\par mov     [Major], ah         ; major version number
\par mov     [Minor], al         ; minor version number
\par mov     [Debug], ecx        ; debug development revision number
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the version number for the Windows virtual machine manager (VMM). Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear and the following values in the following registers: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 AH \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Specifies the major version number. For Windows version 95, this number is 4. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 AL \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Specifies the minor version number. For Windows version 95, this number is 0. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Specifies the debug development revision number. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_Cur_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM             ; VM handle to test
\par VMMcall Test_Cur_VM_Handle
\par 
\par je      is_current          ; zero flag set if current VM handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the given virtual machine handle is the handle of the currently running virtual machine. This is an asynchronous service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the zero flag set if the given handle identifies the current virtual machine, clear otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Virtual machine handle to test. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Cur_VM_Handle}, {\b Test_Sys_VM_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_DBCS_Lead_Byte 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Value   ; value to test
\par VMMcall Test_DBCS_Lead_Byte
\par 
\par jc      not_valid    ; carry flag set if not legal DBCS lead byte
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the given value is in the legal range for a DBCS lead byte. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if the specified value is in the legal range for DBCS lead bytes, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Value}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to test. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For non-DBCS versions of Windows, this service always sets the carry flag. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_Debug_Installed 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Test_Debug_Installed
\par 
\par je      not_installed       ; zero flag set if not installed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether a debugger is currently connected. is running. This is not the same as checking whether the debugging version of the Windows VMM is running. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the zero flag set if a debugger is not installed, clear otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_Sys_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM             ; VM handle to test
\par VMMcall Test_Sys_VM_Handle
\par 
\par je      is_system           ; zero flag set if system VM handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the given virtual machine handle is the handle of the system virtual machine. This is an asynchronous service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the zero flag set if the given handle identifies the system virtual machine, clear otherwise. 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Virtual machine handle to test. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Sys_VM_Handle}, {\b Test_Cur_VM_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Validate_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM             ; VM handle to test
\par VMMcall Validate_VM_Handle
\par 
\par jc      not_valid           ; carry flag set if VM handle not valid
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the specified virtual machine handle is valid. This is an asynchronous service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag set if the handle is not valid, clear otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Virtual machine handle to test. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Test_Cur_VM_Handle}, {\b Test_Sys_VM_Handle}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 100}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 8 Initialization Information{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 101}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 8
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Initialization Information 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Initialization Information 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following initialization information services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Convert_Boolean_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts string to a Boolean value. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Convert_Decimal_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts a string to a decimal value. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Convert_Fixed_Point_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts a string to a fixed-point value. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Convert_Hex_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts a string to a hexadecimal value. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Config_Directory}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns to the WINDOWS directory. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Environment_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the value of an environment variable. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Exec_Path}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the full path of Windows VMM. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Machine_Info}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns machine information. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Name_Of_Ugly_TSR}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the name of uncooperative TSR. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Next_Arena}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns information about the MS-DOS arena. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Next_Profile_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the value of the next profile string. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Profile_Boolean}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the value of a Boolean entry. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Profile_Decimal_Int}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the value of a decimal entry. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Profile_Fixed_Point}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the value of a fixed-point entry. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Profile_Hex_Int}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the value of a hexadecimal entry. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Profile_String}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns value of a profile string. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_PSP_Segment}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the segment address of a PSP. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Set_Real_DOS_PSP}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Gets or sets the PSP for the specified VM \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b GetDOSVectors}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns original interrupt handler addresses. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Locate_Byte_In_ROM}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Locates a byte value in system ROM. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b OpenFile}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Opens a file and returns an MS-DOS file handle. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VMM_GetSystemInitState}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Retrieves the current system initialization state. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Convert_Boolean_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, OFFSET32 String    ; address of Boolean string
\par VMMcall Convert_Boolean_String
\par 
\par jc      not_valid               ; carry set if invalid string
\par mov     [Result], eax           ; 0 if false, -1 if true
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts a string representing a Boolean value, and returns either \endash  1 or 0 to indicate that the string is true or false. This service is available during initialization only. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag is clear if the string r
epresents a valid Boolean value, set otherwise. If the carry flag is clear, the EAX register contains either 0 (false) or \endash  1 (true). 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string representing a Boolean value. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Valid boolean strings that signify false are {\i 0, False, N, No,} and {\i Off}. Valid boolean strings that signify true are {\i 1, On, True, Y,} and {\i Yes}
. Non-English versions of Windows may have language-specific additions to this list. 
\par {\b Convert_Decimal_String}, {\b Convert_Fixed_Point_String}, {\b Convert_Hex_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Convert_Decimal_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, OFFSET32 String  ; address of decimal string
\par VMMcall Convert_Decimal_String
\par 
\par mov     [Value], eax          ; decimal value of string
\par mov     [TermChar], edx       ; address of terminating character
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Converts a string representing a decimal number into a value. The service also returns a pointer to the character in the string that marked the end of the decimal number. This service is only valid during initialization. Uses EAX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the value of the decimal string in the EAX register, and the address of the terminating character (first unparseable character) in the EDX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the null-terminated string to convert. The string can be any combination of decimal digits and may preceded by a plus sign (+) or minus sign (-) to indicate a positive or negative value. 

\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the string is empty or does not contain a valid decimal integer, the service returns zero in the EAX register and the address of the first character in the EDX register. 
\par {\b Convert_Boolean_String}, {\b Convert_Fixed_Point_String}, {\b Convert_Hex_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Convert_Fixed_Point_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, Places      ; number of decimal places
\par mov     edx, String      ; address of fixed-point string
\par VMMcall Convert_Fixed_Point_String
\par 
\par mov     [Value], eax     ; fixed-point value
\par mov     [TermChar], edx  ; address of terminating character
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts a string representing a fixed-point number into a fixed-point value. The service also 
returns a pointer to the character in the string that marked the end of the number. This service is only valid during initialization. Uses EAX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the normalized value of the fixed-point number in the EAX register, and the address of the terminating character in the EDX register. The actual value is equal to . 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Places}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of digits after the decimal point to convert. The service skips over any extra digits without calculating them into the fixed-point value. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the null-terminated string to convert. For more information about the format of the string, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A fixed-point number is a decimal number that consists of an integer, a fraction, or a combination of integer and fraction. The integer can be any combination of decimal digits and may be preceded by a plus sign (+) or a minus sign (-) to indicate a posit
ive or negative fixed-point value. The fraction can be any combination of decimal digits but must be preceded with a decimal point (.). 
\par {\b Convert_Boolean_String}, {\b Convert_Decimal_String}, {\b Convert_Hex_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Convert_Hex_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, OFFSET32 String  ; address of hexadecimal string
\par VMMcall Convert_Hex_String
\par 
\par mov     [Value], eax          ; value of string
\par mov     [TermChar], edx       ; address of terminating character
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts a string representing a hexadecimal number into a value. 
The service also returns a pointer to the character in the string that marked the end of the hexadecimal number. This service is only valid during initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the value of the hexadecimal string in the EAX register, and the address of the terminating character in the EDX register. If the letter H terminates the number, EDX contains the address the character after the H. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the null-terminated string to convert. The string can be any combination of hexadecimal digits (0\endash 9, A-F), and may terminated with an uppercase or lowercase letter {\i H}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Convert_Boolean_String}, {\b Convert_Decimal_String}, {\b Convert_Fixed_Point_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Config_Directory 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Config_Directory
\par 
\par mov     [WinDir], edx  ; address of the directory name
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets the name of the directory containing the Windows configuration files, such as SYSTEM.INI. For Windows 95, this service is available following initialization. Uses EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns, in the EDX register, the address of a null-terminated string containing the fully qualified path of the configuration directory. The string always ends with a backslash (\\). 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the WINDIR environment variable is defined when Windows starts, the string associated with WINDIR is returned, regardless of whether it specifies the actual directory where SYSTEM.INI is located. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 GetDOSVectors 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall GetDOSVectors
\par 
\par mov     [Int23], eax  ; V86 address of original Int 23 handler
\par mov     [Int24], edx  ; V86 address of original Int 24 handler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the Interrupt 23h and Interrupt 24h vectors originally set by MS-DOS for the Windows virtual machine manager (VMM). This service is valid only during initialization. Uses EAX, EDX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the Interrupt 23h vector in the EAX register and the Interrupt 24h vector in the EDX register. Each register contains a V86-mode address, with the segment in the high-order word, and the offset in the low-order word. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices must {\i not} use this service; this service is reserved for exclusive use by the virtual MS-DOS manager. 
\par When Windows starts, the VMM changes the original Interrupt 23h and 24h vectors to the addresses of its own handlers. When a virtual machine starts, the virtual MS-DOS manager resets these vectors to the original handlers using this service to retrieve th
e original addresses. 
\par {\b Get_PSP_Segment}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Environment_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 Variable  ; environment variable name
\par VMMcall Get_Environment_String
\par 
\par jc      not_found               ; carry set if variable not found
\par mov     [Value], edx            ; addr. of null-terminated string
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the value of the specified environment variable. For Windows 95, this service is available following initialization. Uses EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear
, the EDX register contains the address of a null-terminated string specifying the value of the environment variable. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Variable}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Address of a null-terminated string specifying the name of an MS-DOS environment variable. This service is not sensitive to case, so the name may be given in any combination of uppercase and lowercase letters. If zero is passed, the service returns a poin
ter to the environment block. Additional information about the environment block follows the environment variables comment. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Environment variables, set using the MS-DOS {\b set}
 command, are a limited resource. Although some virtual devices use environment variables as a way to set operating parameters, this is not recommended unless the variable is used by a set of programs, MS-DOS device drivers, and virtual devices. 
\par When zero is passed as the name of the environment variable, a pointer to the 'global environment' is returned in the EDX register. The global environment has the same format as in MS-DOS: A packed array of zero-terminate
d ASCII strings, each of the form '<variable>=<value>', all terminated by an extra null byte. The VMM also creates a fake 16-byte MS-DOS arena header in front of the environment block so that you can determine its size: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 GLOBAL_ENVIRONMENT_HEADER struc
\par \tab \tab db\tab \tab 'M'
\par \tab \tab dw\tab \tab 0FFFFh
\par \tab \tab dw\tab \tab paraSize\tab \tab \tab ; Size in paragraphs, not incl. header
\par \tab \tab db\tab \tab 11 dup (?)\tab \tab ; Padding
\par GLOBAL_ENVIRONMENT_HEADER ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Do not attempt to resize the environment. You may, however, edit the environment, provided you do so during system initi
alization. Changes to the global environment after system initialization will not take effect the way you expect. 
\par Do not keep pointers into the global environment. The global environment moves around during the running of the system, so any pointer you keep into it may be stale by the time you use it. If you need to retain the value of an environment variable, make a
 private copy. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Exec_Path 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Exec_Path
\par 
\par mov     [Path], edx     ; address of full path of VMM32.VXD
\par mov     [Length], ecx   ; count of chars up to and including the
\par                         ;   last backslash (\\).
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets the fully qualified path of the Windows virtual machine manager (VMM). For Windows 95, this service is available following initialization. Uses ECX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns, in the EDX register, the address of a null-terminated string containing the fully qualified path of the VMM (VMM32.VXD). The ECX register contains the length of the directory portion of the string, up to and including the last backslash (\\). 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Machine_Info 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Machine_Info
\par mov     [Major], AH     ; MS-DOS major version number
\par mov     [Minor], AL     ; MS-DOS minor version number
\par mov     [OEM], BH       ; MS-DOS OEM serial number
\par mov     [Model], BL     ; machine model byte
\par shr     EBX, 16         ; machine type flags returned in the
\par mov     [Type], BX      ;   high-order word of EBX
\par mov     [SysConf], ECX  ; address of System Config. Parameters
\par mov     [Equip], EDX    ; equipment flags
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns information about the computer system that Windows is running on. Uses EAX, EBX, ECX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the following information in the following registers: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 AH \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MS-DOS major version number \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 AL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MS-DOS minor version number \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BH \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MS-DOS OEM serial number \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Machine model byte (from address F000:FFFE in system ROM) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EBX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Machine type flags, in the high-order word. For a list of possible values, see below. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Ring 0 linear address to System Configuration Parameters (as returned from BIOS service Interrupt 15h, AH=C0h). Applies only to PS/2 or computers with extended BIOS. See the PS/2 BIOS documentation for details. \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Equipment flags (as returned from Interrupt 11h) \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The machine type flags, returned in the high-order word of the EBX register, can include zero or more of these values: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GMIF_80486 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 80486 processor or higher \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GMIF_PCXT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PCXT accelerator \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GMIF_MCA \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Micro Channel \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GMIF_EISA \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EISA \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GMIF_CPUID \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 CPUID instruction supported by this processor \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The address returned in the ECX register points to a {\i copy} of the system configuration parameters because the actual parameters may have been moved into a buffer which is subject to page remapping. 
\par \pard\plain \s23\li30\ri30\sl-80\slmult1\keepn\brdrb\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Note 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The CPUID instruction is supported by the Intel\'ae Pentium\'99 processor and other non-Pentium processors. CPU support of the CPUID instruction does not guarantee that the CPU is a Pentium processor. 
\par \pard\plain \s20\li30\ri30\sa40\sl-140\slmult1\brdrt\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Name_Of_Ugly_TSR 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Name_Of_Ugly_TSR
\par 
\par jz      no_ugly_TSR         ; zero flag set if no ugly TSRs present
\par mov     [Name], eax         ; first 4 characters of TSR name
\par mov     [Name+4], ebx       ; last 4 characters of TSR name
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the name of an uncooperative TSR. This service is available only during initialization, and only for Windows version 3.1 and later. Uses EAX, EBX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the zero flag clear if any uncooperative TSRs are present, set otherwise. If the zero flag is clear, the EAX and EBX registers contain the first four and last four characters of the TSR name. Otherwise both registers are zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 During its real-mode initialization, the virtual MS-DOS manager checks for and records the names of any TSRs that may prevent other MS-DOS programs from running. {\b Get_Name_Of_Ugly_TSR}
 checks the list and returns one of the TSR names (if any) so that virtual devices can determine whether they can successfully operate. Although more than one ugly TSR may be present in the list, the service chooses only one name to return. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Next_Arena 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, 0              ; must be zero
\par VMMcall Get_Next_Arena
\par 
\par mov     [Data], eax         ; data value
\par mov     [Flags], ecx        ; high MS-DOS memory flags
\par mov     [Memory], edx       ; points to array of Common_Memory_struc
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns a pointer to an MS-DOS data structure. Uses EAX, ECX, EDX, Flags. 
\par Virtual devices must {\i not} use this service; it is intended for exclusive use by the virtual MS-DOS manager. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the following values in the following registers: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Contains a data value. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Contains the high MS-DOS flags. For more information, see below. \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Contains the address of an array of {\b 
Common_Memory_struc} structures. For more information, see below. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The high MS-DOS flags, returned in the ECX register, can be zero or more of these values: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GNA_HiDOSLinked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Set if high MS-DOS arenas were linked in when Windows was started. \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GNA_IsHighDOS \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Set if high MS-DOS arenas exist. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The EDX register contains the address of an array of {\b Common_Memory_Struc}
 structures, each specifying the address and size of a high MS-DOS memory segment. The last element in the array contains zero. The structure has the following form: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Common_Memory_struc struc
\par   CM_seg    dw  ?   ; segment address of start
\par   CM_size   dw  ?   ; size in paragraphs
\par Common_Memory_struc ends
\par 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Next_Profile_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, Profile    ; points to the previous entry value
\par mov     edi, Keyname    ; points to the keyname for the entry
\par VMMcall Get_Next_Profile_String
\par 
\par jc      no_next         ; carry flag set if no more entries
\par mov     [Next], edx     ; address of next profile string
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Searches the SYSTEM.INI file for the next entry with a given keyname following the specified entry. Virtual devices typically use this service if they have more than one entry with the same keyname. This service is available only during initialization. Us
es EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if an entry is found, set otherwise. If the carry flag is clear, the EDX register contains the address of the next string with the specified keyname. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Profile}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying the value of the previous entry. The string must have been previously returned using the {\b Get_Profile_String} or {\b Get_Next_Profile_String} service. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Keyname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Points to a null-terminated string identifying the keyname for the entry. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device retrieves the first string using the {\b Get_Profile_String} service, then uses {\b Get_Next_Profile_String}
 to retrieve all subsequent entries. In all cases, the virtual device must not modify the returned string. 
\par {\b Get_Profile_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Profile_Boolean 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Default            ; default value
\par mov     esi, OFFSET32 Profile   ; points to section name
\par mov     edi, OFFSET32 Keyname   ; points to entry name
\par VMMcall Get_Profile_Boolean
\par 
\par jc      not_found               ; carry set if entry not found
\par jz      no_value                ; zero set if entry has no value
\par 
\par mov     [Value], eax            ; 0 or -1 returned in EAX
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the value of a Boolean entry in the SYSTEM.INI file. This service is only available during initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry and zero flags clear if the entry is found. In this case, the EAX register contains 
\endash  1 or 0 indicating that the entry value evaluates to true or false, respectively. 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 
If the carry flag is clear and the zero flag is set, the entry exists but has no corresponding value. If the carry flag is set, the entry does not exist or is not a valid boolean string. In these cases, the EAX register contains the value of the Default p
arameter. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Default}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Default value to return if the entry has no corresponding value, does not exist, or is not a valid boolean string. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Profile}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string identifying the section in the SYSTEM.INI file to search. Can be zero, in which case the service searches the [386Enh] section. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Keyname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying keyname to search for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Valid boolean strings that signify false are {\i 0, False, N, No,} and {\i Off}. Valid boolean strings that signify true are {\i 1, On, True, Y,} and {\i Yes}
. Non-English versions of Windows may have language-specific additions to this list. 
\par {\b Get_Profile_Decimal_Int}, {\b Get_Profile_Fixed_Point}, {\b Get_Profile_Hex_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Profile_Decimal_Int 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Default            ; default value
\par mov     esi, OFFSET32 Profile   ; points to section name
\par mov     edi, OFFSET32 Keyname   ; points to entry name
\par VMMcall Get_Profile_Decimal_Int
\par 
\par jc      not_found               ; carry set if entry not found
\par jz      no_value                ; zero set if entry has no value
\par 
\par mov     [Value], eax            ; entry value
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the value of a decimal-number entry in the SYSTEM.INI file. This service is only available during initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry and zero flags clear if the entry is found. In this case, the EAX register contains the value of the decimal number. 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 If the carry flag is clear and the zero flag is set, the entry exists but has no corresponding value. If the carry flag 
is set, the entry does not exist or does not represent a decimal number. In these cases, the EAX register contains the value of the Default parameter. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Default}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Default value to return if the entry has no corresponding value, does not exist, or does not represent a decimal number. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Profile}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string identifying the section in the SYSTEM.INI file to search. Can be zero, in which case the service searches the [386Enh] section. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Keyname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying keyname to search for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A valid decimal number consists of one or more decimal digits and contains no embedded spaces or decimal points. The decimal number can be preceded with a plus sign (+) or minus sign (-) to indicate a positive or negative number, respectively. 
\par {\b Get_Profile_Boolean}, {\b Get_Profile_Fixed_Point}, {\b Get_Profile_Hex_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Profile_Fixed_Point 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Default            ; default value
\par mov     ecx, Places             ; number of digits after decimal point
\par mov     esi, OFFSET32 Profile   ; points to section name
\par mov     edi, OFFSET32 Keyname   ; points to entry name
\par VMMcall Get_Profile_Fixed_Point
\par 
\par jc      not_found               ; carry flag set if entry not found
\par jz      no_value                ; zero flag set if entry has no value
\par 
\par mov     [Value], eax            ; entry value
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the value of a fixed-point-number entry in the SYSTEM.INI file. This service is only available during initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Retur
ns with the carry and zero flags clear if the entry is found. In this case, the EAX register contains the normalized value of the fixed-point number. The actual value is equal to 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 
If the carry flag is clear and the zero flag is set, the entry exists but has no corresponding value. If the carry flag is set, the entry does not exist or does not represent a fixed-point number. In these cases, the EAX register contains the value of the
 Default parameter. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Default}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Default value to return if the entry has no corresponding value, does not exist, or does not represent a fixed-point number. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Places}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of digits after the decimal point to convert. The service skips over any extra digits without calculating them into the fixed-point value. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Profile}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string identifying the section in the SYSTEM.INI file to search. Can be zero, in which case the service searches the [386Enh] section. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Keyname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying keyname to search for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A fixed-point number is a d
ecimal number that consists of an integer, a fraction, or a combination of integer and fraction. The integer can be any combination of decimal digits and may be preceded by a plus sign (+) or a minus sign (-) to indicate a positive or negative fixed-point
 value. The fraction can be any combination of decimal digits but must be preceded with a decimal point (.). 
\par {\b Get_Profile_Boolean}, {\b Get_Profile_Decimal_Int}, {\b Get_Profile_Hex_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Profile_Hex_Int 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Default            ; default value
\par mov     esi, OFFSET32 Profile   ; points to section name
\par mov     edi, OFFSET32 Keyname   ; points to entry name
\par VMMcall Get_Profile_Hex_Int
\par 
\par jc      not_found               ; carry set if entry not found
\par jz      no_value                ; zero set if entry has no value
\par 
\par mov     [Value], eax            ; entry value
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the value of a hexadecimal-number entry in the SYSTEM.INI file. This service is only available during initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns 
with the carry and zero flags clear if the entry is found. In this case, the EAX register contains the value of the hexadecimal number. 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 
If the carry flag is clear and the zero flag is set, the entry exists but has no corresponding value. If the carry flag is set, the entry does not exist or does not represent a hexadecimal number. In these cases, the EAX register contains the value of the
 Default parameter. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Default}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Default value to return if the entry has no corresponding value, does not exist, or does not represent a hexadecimal number. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Profile}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string identifying the section in the SYSTEM.INI file to search. Can be zero, in which case the service searches the [386Enh] section. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Keyname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying keyname to search for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A valid hexadecimal number consist of any combination of hexadecimal digits (0\endash 9, A-F), and can be terminated with the uppercase or lowercase letter {\i H}. 
\par {\b Get_Profile_Boolean}, {\b Get_Profile_Decimal_Int}, {\b Get_Profile_Fixed_Point}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Profile_String 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, OFFSET32 Default   ; optional default string
\par mov     esi, OFFSET32 Profile   ; section name
\par mov     edi, OFFSET32 Keyname   ; entry name
\par VMMcall Get_Profile_String
\par 
\par jc      not_found               ; carry set if entry not found
\par mov     [Value], edx            ; address of profile string
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Searches the SYSTEM.INI file for a specified entry, and returns a pointer to a null-terminated string representing the entry value. This service is only available during initialization. Uses EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if the entry is found, set otherwise. If the carry flag is clear, the EDX register contains the address of the null-terminated string representing the entry value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Default}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string to be returned if the entry is not found, or has no current value. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Profile}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string identifying the section in the SYSTEM.INI file to search. Can be zero, in which case the service searches the [386Enh] section. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Keyname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying keyname to search for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device must {\i not} modify the string pointed to by the EDX register. If modification is required, copy the string and modify the copy. 
\par {\b Get_Next_Profile_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_PSP_Segment 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_PSP_Segment
\par 
\par mov     [PSP], eax          ; segment address of PSP
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the segment address of program segment prefix (PSP) for the Windows virtual machine manager (VMM32.VSD). This service is only available during initialization. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the PSP segment address in the EAX register. The high-order word is zero. To convert the segment address to a linear address, shift it left by 4 bits. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices typically use this service to retrieve values from the PSP that can not be retrieved using the {\b Get_Exec_Path} and {\b Get_Environment_String} services. 
\par {\b Get_Environment_String}, {\b Get_Exec_Path}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Set_Real_DOS_PSP 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc 
\par 
\par mov ebx, VMHandle
\par mov ax, NewPSP
\par mov ecx, dwFlags
\par VMMCall Get_Set_Real_DOS_PSP
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets or sets the PSP for the specified VM. Uses the EAX, ECX, and EDX registers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
If performing a set operation, returns the previous PSP value in the AX register. If performing a get operation, returns the the current PSP value in the AX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle to the VM. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NewPSP}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 New PSP to set if {\i dwFlags }is GSRDP_Set. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 dwFlags 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specify GSRDP_Set to set the PSP to a new value. Or, specify zero to retrieve the current PSP value. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Locate_Byte_In_ROM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     al, Byte            ; byte to locate
\par VMMcall Locate_Byte_In_ROM
\par 
\par jc      not_found           ; carry flag set if byte not found
\par mov     [Location], eax     ; linear address of byte
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Scans the system ROM for a specified byte. Virtual devices use this service to locate single-byte instructions, such as the {\b iret}
 instruction, that must be protected from modification by programs running in a virtual machine. This service is only available during initialization. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the carry flag clear if the byte was found. The EAX register contains the linear address of the byte. The carry flag is set if the byte was not found or the user disabled the service. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Byte}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Byte value to search for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Users can disable this service by setting to false the SystemROMBreakpoint setting in the [386Enh] section of the SYSTEM.INI file. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 OpenFile 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, OFFSET32 Filename  ; address of name of file to open
\par mov     edi, OFFSET32 Buffer    ; buffer to receive full path
\par VMMcall OpenFile
\par 
\par jc      not_found               ; carry set if file not found
\par mov     [Handle], eax           ; MS-DOS file handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Opens the specified file for reading (in compatibility mode). For Windows 95, this service can be called during or following initialization. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, the EAX register contains an MS-DOS file handle. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Filename}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string specifying the name of the file to open. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Buffer}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a buffer that receives the full path of the file, if found. If this service is called during initialization, the buffer must be at least 128 bytes. If this se
rvice is called following initialization, the buffer size, in bytes, must be at least VMM_OPENFILE_BUF_SIZE. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
If the specified filename includes a drive letter or path, the service looks for the file only in the specified drive and directory. Otherwise, the service searches for the file in the directories specified by the following: 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab WINDIR environment variable 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab First command-line argument (argv[0]) of Windows 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Current working directory 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab PATH environment variable 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Otherwise, the service does not search for the file. In either case, the service attempts to opens the file for reading (in compatibility mode), and returns the MS-DOS file handle if it is successful. 
\par If WINDIR and PATH environment variables are not well formed, this service cannot guarantee that the full path copied to the {\i Buffer} parameter will be well formed. 
\par This service fails if the current virtual machine cannot support a call to the {\b Exec_Int} service. 
\par This service fails during initialization if the virtual machine has already used the {\b _Allocate_Temp_V86_Data_Area} service to allocate the temporary buffer. 
\par {\b _Allocate_Temp_V86_Data_Area}, {\b Exec_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMM_GetSystemInitState 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall VMM_GetSystemInitState
\par 
\par mov [InitState], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the current system initialization state. Uses EAX, ECX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the current system initialization state in the EAX register. 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 
The following table identifies initialization milestones and return values for VMM_GetSystemInitState. Milestones are listed in the table in chronological order. When a milestone completes, this service returns the value (one of the values) listed to the 
right of the milestone. The first value is returned if the first milestone has not been completed. 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Milestone \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 VMM_GetSystemInitState return value \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard \sa160\sl-240\slmult1\intbl \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSSTATE_PRESYSCRITINIT (00000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYS_CRITICAL_Init is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSSTATE_PREDEVICEINIT (10000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DEVICE_INIT is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSSTATE_PREINITCOMPLETE (20000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 INIT_COMPLETE is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSSTATE_VXDINITCOMPLETED (40000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 KERNEL32_INITIALIZED is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSSTATE_KERNEL32INITED (50000000h) \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 KERNEL32_SHUTDOWN is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSSTATE_KERNEL32TERMINATED (A0000000h) 
\par STATE_PRESYSVMTERMINATE (B0000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYS_VM_TERMINATE is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
SYSSTATE_PRESYSTEMEXIT (E0000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSTEM_EXIT is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
SYSSTATE_PRESYSTEMEXIT2 (E4000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSTEM_EXIT2 is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
SYSSTATE_PRESYSCRITEXIT (F0000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYS_CRITICAL_EXIT is broadcast \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 SYSSTATE_PRESYSCRITEXIT2 (F4000000h) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYS_CRITICAL_EXIT2 is broadcast \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Return to real mode \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SYSSTATE_POSTSYSCRITEXIT2 (FFF00000h) \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Future versions of Windows may have additional initialization states with values between the ones defined here, which implies that you should use a relational comparison to test the initialized state. Currently, this service returns zero in ECX, but addit
ional information may be returned in this register in the future. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 112}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 9 I/O Trapping{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 111}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 9
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 I/O Trapping 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About I/O Trapping 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The VMM provides the {\b Install_IO_Handler} service to install a callback procedure to handle protection faults for a given port. When a virtual device calls {\b Install_IO_Handler}
, the VMM sets the appropriate bit in the I/O permission map (IOPM) and registers the procedure. When a virtual machine executes an inst
ruction that reads or writes data from an I/O port, the 80386 looks up the port number in the I/O permission map. If the corresponding bit in the IOPM is set, then the instruction will cause a protection fault that results in calling the registered proced
ure. 
\par There are the following I/O services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Disable_Global_Trapping}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Disables global I/O trapping. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Disable_Local_Trapping}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Disables local I/O trapping. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Enable_Global_Trapping}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables global I/O trapping. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Enable_Local_Trapping}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables local I/O trapping. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Install_IO_Handler}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Install an I/O callback procedure. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Install_Mult_IO_Handlers}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Install I/O handlers for multiple ports. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Remove_IO_Handler}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Removes the I/O handler for the specified port and disables trapping for that port. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Remove_Mult_IO_Handlers}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Repeatedly calls the {\b Remove_IO_Handler} service for each entry in the VxD_IO_Table, removing the specified IO handlers. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_IO}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates input and output. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Simulate_VM_IO}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reduces complex I/O instructions to simpler I/O operations. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Disable_Global_Trapping 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, Port           ; I/O port number
\par VMMcall Disable_Global_Trapping
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Disables I/O port trapping for the specified I/O port. This applies to every virtual machine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Port}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the I/O port for which global trapping is to be disabled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service must not be used unless an I/O callback procedure has been installed for the given port using the {\b Install_IO_Handler} or {\b Install_Mult_IO_Handlers}
 service during initialization. In particular, you should not attempt to alter the port trapping state of a port for which you did not personally install an I/O handler. Altering the port trapping state of a port owned by another virtual device driver may
 cause that other driver to get confused. 
\par The system applies the current global trapping state for each new virtual machine as it is created. When the system first starts, global trapping is enabled by default. 
\par {\b Enable_Global_Trapping}, {\b Install_IO_Handler}, {\b Install_Mult_IO_Handlers}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Disable_Local_Trapping 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM         ; VM handle
\par mov     edx, Port       ; I/O port number
\par VMMcall Disable_Local_Trapping
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Disables I/O port trapping for the specified I/O port. This applies only to the specified virtual machine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which to disable I/O trapping. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Port}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the I/O port for which trapping is disabled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service must not be used unless an I/O callback procedure has been installed for the given port using the {\b Install_IO_Handler} or {\b Install_Mult_IO_Handlers}
 service during initialization. In particular, you should not attempt to alter the port trapping state of a port for which you did not personally install an I/O handler. Altering the port trapping state of a port owned by another virtual device driver may
 cause that other driver to get confused. 
\par {\b Enable_Local_Trapping}, {\b Install_IO_Handler}, {\b Install_Mult_IO_Handlers}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Enable_Global_Trapping 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, Port           ; I/O port number
\par VMMcall Enable_Global_Trapping
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Enables I/O port trapping for the specified port. This applies to every virtual machine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Port}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the I/O port for which global trapping is to be enabled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service must not be used unless an I/O callback procedure has been installed for the given port using the {\b Install_IO_Handler} or {\b Install_Mult_IO_Handlers}
 service during initialization. In particular, you should not attempt to alter the port trapping state of a port for which you did not personally install an I/O handler. Altering the port trapping state of a port owned by another virtual device driver may
 cause that other driver to get confused. 
\par The system applies to current global trapping state to each new virtual machine as it is created. When the system first starts, global trapping is enabled by default. 
\par {\b Disable_Global_Trapping}, {\b Install_IO_Handler}, {\b Install_Mult_IO_Handlers}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Enable_Local_Trapping 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM         ; VM handle
\par mov     edx, Port       ; I/O port number
\par VMMcall Enable_Local_Trapping
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Enables I/O port trapping for the specified port. This applies to the specified virtual machine only. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which to enable I/O trapping. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Port}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the I/O port for which trapping is enabled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service must not be used unless an I/O callback procedure has been installed for the given port using the {\b Install_IO_Handler} or {\b Install_Mult_IO_Handlers}
 service during initialization. In particular, you should not attempt to alter the port trapping state of a port for which you did not personally install an I/O handler. Altering the port trapping state of a port owned by another virtual device driver may
 cause that other driver to get confused. 
\par {\b Disable_Local_Trapping}, {\b Install_IO_Handler}, {\b Install_Mult_IO_Handlers}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Install_IO_Handler 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, IOCallback     ; points to callback procedure
\par mov     edx, Port           ; I/O port number
\par VMMcall Install_IO_Handler
\par 
\par jc      not_installed       ; carry flag set if procedure not installed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a callback procedure for I/O port trapping, and enables trapping for the specified port. Only one procedure may be installed for a given port. For Windows 95, this service can be called follow
ing initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IOCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure. For more information about the callback procedure, see below. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Port}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the I/O port trap. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The service returns an error if a callback procedure is already installed for the specified port or the system limit for I/O callback procedures has been reached. 
\par The system calls the callback procedure whenever a program in a virtual machine attempts to access the specified I/O port, and I/O trapping is enabled. The system calls the procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     ecx, IOType         ; type of I/O
\par mov     edx, Port           ; port number
\par mov     ebp, OFFSET32 crs   ; points to a Client_Reg_Struc
\par mov     eax, Data           ; output data (if I/O type is output)
\par call    [IOCallback]
\par 
\par mov     [Data], eax         ; input data (if I/O type is input)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter specifies the current virtual machine, the {\i Port} parameter specifies the I/O port, and the {\i crs} parameter points to a {\b Client_Reg_Struc}
 structure containing the register contents for the current virtual machine. 
\par The {\i IOType} parameter specifies the type of input or output operation requested and determines whether the callback procedure receives data in the EAX register or must return data in the EAX register. The {\i IOType}
 parameter can be a combination of the following values: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Addr_32_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use 32-bit address offsets for input or output string operations. If this value is not given, the 16-bit offsets are used. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Byte_Input \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Input a single byte; place in AL if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Byte_Output 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Output a single byte from AL if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dword_Input 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Input a double word; place in EAX if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Dword_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Output a double word from EAX if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Rep_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Repeat the input or output string operation the number of times specified by the {\b Client_CX} field in the {\b Client_Reg_Struc}
 structure. (The number of repetitions is stored in the {\b Client_ECX} field if Addr_32_IO is also set.) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reverse_IO \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Decrement string address on each input or output operation. If this value is not given, the string address is incremented on each operation. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 String_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Input or output a string. The high 16-bits specifies segment address of buffer containing the string to output or to receive the string input. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Word_Input \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Input a word; place in AX if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Word_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Output a word from AX if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i Data} parameter is used only for when I/O type is for output. 
\par A virtual machine can disable trapping of a port for every or for specific virtual machines by using the {\b Disable_Global_Trapping} and {\b Disable_Local_Trapping} services. 
\par {\b Disable_Global_Trapping}, {\b Disable_Local_Trapping}, {\b Install_Mult_IO_Handlers}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Install_Mult_IO_Handlers 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, OFFSET32 IOTable   ; points to an I/O table
\par VMMcall Install_Mult_IO_Handlers
\par 
\par jnc     installed               ; carry flag clear if all procedures installed
\par mov     [BadPort], edx          ; I/O port number that failed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs I/O callback procedures for one or more I/O ports. For Windows 95, this service can be called following initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if all callback procedures were installed, set otherwise. If the carry flag is set, the EDX register contains the number of the I/O port for which the procedure could not be installed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IOTable}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an I/O table created using the {\b Begin_Vxd_IO_Table}, {\b End_Vxd_IO_Table}, and {\b Vxd_IO} macros. For more information about the table, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service repeatedly calls the {\b Install_IO_Handler} service until all entries in the specified I/O table have been installed. 
\par A virtual device can create an I/O table using the {\b Begin_Vxd_IO_Table}, {\b End_Vxd_IO_Table}, and {\b Vxd_IO} macros. The following example shows a table containing three entries for ports 30, 31, and 32: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Begin_Vxd_IO_Table  My_IO_Table
\par Vxd_IO              30,IO_Handler_1
\par Vxd_IO              31,IO_Handler_2
\par Vxd_IO              32,IO_Handler_1
\par End_Vxd_IO_Table    My_IO_Table
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_Vxd_IO_Table}, {\b End_Vxd_IO_Table}, {\b Install_IO_Handler}, {\b Vxd_IO}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Remove_Mult_IO_Handlers 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, OFFSET32 VxD_IO_Table
\par VMMCall Remove_Mult_IO_Handlers
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Repeatedly calls the {\b Remove_IO_Handler} service for each entry in the VxD_IO_Table, removing the specified IO handlers. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VxD_IO_Table}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A table of IO port numbers and associated procedure names. This table should have the following format: 
\par \pard\plain \s55\li280\sl-220\slmult1\tx670\tx1060\tx1450\tx1840\tx2230\tx2620\tx3010\tx3400\tx3790\tx4180\tx4570\tx4960\tx5350\tx5740\tx6130\tx6520\tx6910 \f31\fs16 Begin_Vxd_IO_Table  Table_Name
\par Vxd_IO       <port #>,<procedure name>
\par ...
\par Vxd_IO       <port #>,<procedure name>
\par Vxd_IO       <port #>,<procedure name>
\par End_Vxd_IO_Table    Table_Name
\par 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Remove_IO_Handler 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, IO_Port_Address
\par VMMCall Remove_IO_Handler
\par jc      IO_Handler_Does_Not_Exist
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the I/O handler for the specified port and disables trapping for that port. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab ts the carry flag if the I/O handler does not exist. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IO_Port_Address}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the port for which the handler should be removed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The I/O handler removed by this service is a procedure that was installed with the {\b Install_IO_Handler} service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_IO 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Data          ; data for output operations
\par mov     ebx, VM            ; current VM handle
\par mov     ecx, IOType        ; type of I/O operation
\par mov     edx, Port          ; I/O port number
\par mov     ebp, OFFSET32 crs  ; address of Client_Reg_Struc
\par VMMjmp  Simulate_IO
\par 
\par mov     [Data], eax        ; data for input operation
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Reduces complex I/O instructions to simpler I/O operations. An I/O callback procedure typically jumps to this service whenever the procedure receives a type of I/O that it does not directly support. Uses EAX, EBX, ECX, EDI, EDX, ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the input data in the EAX register, if the
 IOType parameter specifies an input operation. The size of the value in the EAX register is implied by the operation type. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Data}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Data for an output operation. This parameter is used only if the {\i IOType} parameter specifies an output operation. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IOType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Type of I/O operation, as specified in a call to an I/O trap procedure. Can be one or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Addr_32_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Uses 32-bit address offsets for input or output string operations. If this value is not given, the 16-bit offsets are used. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Byte_Input \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Inputs a single byte; place in AL if String_IO is not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Byte_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Outputs a single byte from AL if String_IO is not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Dword_Input \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Inputs a doubleword; place in EAX if String_IO is not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dword_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Outputs a doubleword from EAX if String_IO is not given. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Rep_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Repeats the input or output string operation the number of times specified by the {\b Client_CX}
 field in the {\b Client_Reg_Struc} structure. (The number of repetitions is stored in the {\b Client_ECX} field if Addr_32_IO is also set.) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Reverse_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Decrements string address on each input or output operation. If this value is not given, the string address is incremented on each operation. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 String_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Inputs or outputs a string. The high 16-bits specifies the segment address of the buffer containing the string to output, or to receive the string input. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Word_Input \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Inputs a word; place in AX if String_IO is not given. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Word_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Outputs a word from AX if String_IO is not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Port}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the I/O port through which to carry out the operation. If word I/O is requested, then Port+1 is also used. If dword I/O is requested, then Port+1 through Port+3 are also used. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i crs}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the register contents for the current virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The parameters to this service are identical to the parameters passed to an I/O callback procedure. A callback procedure should jump to this service, using the {\b VMMjmp}
 macro, with all of the registers in the same state as when the procedure was called. The procedure may modify the ESI and EDI register before jumping, if necessary. 
\par {\b Dispatch_Byte_IO}, {\b Emulate_Non_Byte_IO}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Simulate_VM_IO 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, PortID
\par mov     ecx, IOType
\par mov     eax, OutputData
\par VMMCall _Simulate_VM_IO
\par mov     [InputData], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Reduces complex I/O instructions to simpler I/O operations. Uses EAX, flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab If the service is called to simulate input, EAX will receive the input value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PortID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Identifies the port for which input or output is simulated. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IOType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the type of I/O. It can be one of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Byte_Input \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Inputs a single byte. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Byte_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Outputs a single byte. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dword_Input \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Inputs a doubleword. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dword_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Outputs a doubleword. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Word_Input \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Inputs a word. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Word_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Outputs a word. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i OutputData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The data to be output. (This parameter is only used if the service is called to simulate output.) 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This service is called to simulate port I/O from the current VM. It is useful for VxDs which need to alter the state of other VxDs. For example, a VxD could perform a simulated EOI by calling this procedure with: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     al, 20h
\par mov     edx, 20h
\par mov     ecx, Byte_Output
\par VMMcall Simulate_VM_IO
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Which is the same as a VM executing: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     al, 20h
\par out     \tab 20h, al
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 120}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 10 Linked Lists{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 121}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 10
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Linked Lists 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Linked Lists 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following linked list services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Allocate}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocates a new node for a list. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Attach}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Attaches a node to the head of the list. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Attach_Tail}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Attaches a node to the end of the list. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Create}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Creates a list. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Deallocate}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Deallocates a node. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Destroy}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Destroys a list. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Get_First}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the address of the first node. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Get_Next}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the address of next node in the list. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Insert}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Inserts a node into a list. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Remove}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes a node from the list. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b List_Remove_First}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes the first node in list. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Allocate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par VMMcall List_Allocate
\par 
\par jc      not_allocated   ; carry flag set if error
\par mov     [Node], eax     ; address of new node
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allocates a new node for the specified list. A virtual device can attach the new node to the list using the {\b List_Attach, List_Attach_Tail} or {\b List_Insert}
 service. The contents of the new node are undefined. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear and the address of the new node in the EAX register if successful. For lists created using the LF_Alloc_Error value, the service returns with the carry flag set if a node cannot be allocated. For other lists, the service
 does not return if a node cannot be allocated. (It crashes the current virtual machine instead.) 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the list is created using the LF_Use_Heap value, this service calls the {\b _HeapAllocate} service for each node, in which case all the rules regarding heap access apply to {\b List_Allocate} as well. 
\par Otherwise, the service allocates nodes from a pool of free nodes. This avoids the overhead of calling the {\b _HeapAllocate} service for every node allocation. This non-reliance on {\b _HeapAllocate}
 has both positive and negative consequences. On the positive side, it means that {\b List_Allocate} can be called at times when {\b _HeapAllocate}
 cannot be called, such as during hardware interrupts. On the negative side, this means that if the VMM cannot satisfy the allocation request from its pool of free nodes, it cannot obtain more memory from the heap because it might not be safe to call {\b 
_HeapAllocate} at the time the call to {\b List_Allocate} made. VMM maintains an emergency pool of memory into which it can dip when faced with this situation. The emergency pool is refreshed from the system heap at a time when {\b _HeapAllocate}
 is safe to call. 
\par The consequence of this tradeoff is that virtual devices should not allocate large numbers of nodes in rapid succession from lists not marked LF_Use_Heap, because that would dry up the free list and emergency pool, causing {\b List_Allocate} to fail. 

\par {\b List_Attach}, {\b List_Attach_Tail}, {\b List_Create}, {\b List_Deallocate}, {\b List_Insert}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Attach 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par mov     eax, Node       ; address of node to attach
\par VMMcall List_Attach
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Attaches a list node to the head (front) of a list. A virtual device can attach a node to any list that has a matching node size and was created with the same flags. (It is an error, for example, to attach a node allocated from a list created as LF_Use_He
ap to a list created without that flag, even if the node sizes agree.) This service can be used, for example, to move a node from one list to another. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Node}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the node to attach. The node must have been previously created using the {\b List_Allocate} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The service attaches the node to the head of the list. Subsequent calls to the {\b List_Get_First} service return the address of this node. The address of the previous head of the list can be retrieved using the 
{\b List_Get_Next} service. 
\par {\b List_Allocate}, {\b List_Create}, {\b List_Get_First}, {\b List_Get_Next}, {\b List_Remove}, {\b List_Remove_First}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Attach_Tail 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List   ; list handle
\par mov     eax, Node   ; address of node to attach
\par VMMcall List_Attach_Tail
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Attaches a list node to the tail (end) of a list. A virtual device can attach a node to any list that has a matching node size and was created with the same flags. (It is an error, for example, to attach a node allocated from a list created as LF_Use_Heap
 to a list created without that flag, even if the node sizes agree.) This service can be used, for example, to move a node from one list to another. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Node}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the node to attach. The node must have been previously created using the {\b List_Allocate} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The service attaches the node to the end of the list. A virtual device can retrieve the address of the node by calling the {\b List_Get_Next} service and specifying the address of the previous end of the list. 

\par {\b List_Allocate}, {\b List_Create}, {\b List_Get_Next}, {\b List_Remove}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Create 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Flags      ; creation flags
\par mov     ecx, NodeSize   ; size in bytes of each node in list
\par VMMcall List_Create
\par 
\par jc      error           ; carry flag set if error
\par mov     [List], esi     ; list handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates a new list and returns a list handle that virtual devices use in subsequent calls to other list services. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear and the li
st handle in the ESI register, if successful. The carry flag is set if an error occurs. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Creation flags. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 LF_Alloc_Error \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Directs the {\b List_Allocate}
 service to returns with carry flag set if new node could not be allocated. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 LF_Async \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Creates an asynchronous list that can be used while processing interrupts. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
LF_Use_Heap \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocates nodes on the system heap. This value must not be used in combination with the LF_Async value. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 LF_Swap \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocates n
odes from the swappable system heap. This value must not be used in combination with the LF_Async value. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NodeSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size, in bytes, of each node in the list. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If a virtual device requires large nodes, it should specify the LF_Use_Heap value to force the nodes to be allocated from the system heap. All allocate and deallocate calls for lists created in this way use the {
\b _HeapAlloc} and {\b _HeapFree} services to create and destroy nodes. 
\par To access a list during hardware interrupts, a virtual device must set the LF
_Async value when creating the list. This forces list operations to be atomic operations which cannot be re-entered. When using an asynchronous list, the virtual device must disable interrupts before calling the list services. The virtual device must disa
ble interrupts even if when not calling during an interrupt. The virtual device must use the {\b pushf}, {\b cli}, and {\b popf} instructions to disable and re-enable interrupts. It must not use the {\b sti}
 instruction to enable interrupts unless other documentation states that this is premitted. 
\par If the LF_Alloc_Error value is not specified, the system crashes the current virtual machine if the {\b List_Allocate} service fails. If this value is specified, {\b List_Allocate} returns with the carry flag set when an allocation fails. 
\par If the LF_Swap value is specified, then list nodes are allocated from the swappable system heap. Consequently, all list services related to swappable list nodes become subject to constraints on accessing swappable memory. 
\par {\b List_Allocate}, {\b List_Deallocate}, {\b List_Destroy}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Deallocate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par mov     eax, Node       ; address of node to free
\par VMMcall List_Deallocate
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees the specified node. Once a virtual device frees a node, it must not attempt to use the node. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Node}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the node to free. The node must have been previously created using the {\b List_Allocate} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service normally never destroys a node. Instead, the service places the node back in the free pool. The node can then quickly be reclaimed when the {\b List_Allocate}
 service is called. If the list is created using the LF_Use_Heap value, this service calls the {\b _HeapFree} service for each node. 
\par {\b _HeapFree}, {\b List_Allocate}, {\b List_Create}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Destroy 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par VMMcall List_Destroy
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees all nodes in a list, and destroys the list handle. Once a virtual device destroys a list, it must not attempt to use the list handle. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b List_Create}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Get_First 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par VMMcall List_Get_First
\par 
\par jz      empty_list      ; zero flag set if list is empty
\par mov     [Node], eax     ; address of first node
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the address of the first node in a list. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the zero flag clear and the address of the first node in the EAX register if successful. If the list is empty, the zero flag is set and EAX is zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b List_Attach}, {\b List_Create}, {\b List_Get_Next}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Get_Next 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par mov     eax, Node       ; address of node
\par VMMcall List_Get_Next
\par 
\par jz      empty_list      ; zero set if no more nodes in list
\par mov     [Node], eax     ; address of next node
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the next node in a list after the specified node. This service is typically used in conjunction with the {\b List_Get_First} service to scan an entire list. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the zero flag clear and the address of the next node in the EAX register if successful. If there are no more nodes, the zero flag is set and EAX is zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Node}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a node in the list. The address must have been previously retrieved using the {\b List_Get_First} or {\b List_Get_Next} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b List_Create}, {\b List_Get_First}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Insert 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List    ; list handle
\par mov     eax, NewNode ; address of node to insert
\par mov     ecx, Node    ; address of node to insert after (0 to attach to head)
\par VMMcall List_Insert
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Inserts a node immediately after the specified node in a list. A virtual device can insert a node into any list that has a matching node size and was created with the same flags. (It is an error, for example, to attach a node allocated from a list created
 as LF_Use_Heap to a list created without that flag, even if the node sizes agree.) This can be used, for example, to move a node from one list to another. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NewNode}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the node to insert. The node must have been previously created using the {\b List_Allocate} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Node}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a node in the list. The address must have been previously retrieved using the {\b List_Get_First} or {\b List_Get_Next}
 service. If this parameter is zero, the service attaches the new node to the head of the list. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service inserts the new node between the specified node and the node immediately following the specified node. A virtual device can retrieve the address of the new node by calling the {\b List_Get_Next}
 service, and specifying the {\i Node} parameter. 
\par {\b List_Attach}, {\b List_Attach_Tail}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Remove 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par mov     eax, Node       ; address of node to remove
\par VMMcall List_Remove
\par 
\par jc      not_removed     ; carry flag set if error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the specified node from the list. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Node}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the node to remove. The node must have been previously retrieved using the {\b List_Get_First} or {\b List_Get_Next} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service does {\i not} deallocate the node. It is up to the virtual device to free the node, or attach it to another list. 
\par {\b List_Create}, {\b List_Remove_First}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 List_Remove_First 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, List       ; list handle
\par VMMcall List_Remove_First
\par 
\par jz      list_empty      ; zero flag set if list is empty
\par mov     [Node], eax     ; address of node removed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the first node from a list. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the zero flag clear if successful, or set if the list is empty. The EAX register contains the address if the removed node, or zero if none. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i List}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the list. The handle must have been previously created using the {\b List_Create} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service does {\i not} free the node. It is up to the virtual device to free the node, or attach it to another list. 
\par {\b List_Create}, {\b List_Remove}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 144}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 11 Memory Allocation{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 143}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 11
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Memory Allocation 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Memory Allocation 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Sparse Memory Allocation 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A "sparse memory" block is a range of linear addresses in which not all pages are necessarily
 available for use. The owner of a sparse memory block is responsible for making pages available ("committing") and removing pages ("decommitting"), as it sees fit. Accessing a page which is not committed will raise a protection exception. The sparse memo
ry functions allow a VxD to manage linear address space in roughly the same way as the Win32 "VirtualAlloc" and related functions. 
\par Sparse memory allocation services allocate pages in two steps. First, you reserve a range of pages; then you commit pages as 
they are needed. Reserving pages sets the corresponding linear addresses aside for a specific purpose, but does not consume any physical storage. Committing pages allocates physical storage for them. Free pages are those that are neither reserved nor comm
itted. 
\par Suppose a virtual device uses a data structure that must be contiguous and that varies in size over time. By reserving a large range of pages, and committing them as needed, the virtual device can efficiently grow the data structure. Because the res
erved pages are guaranteed to be available, growing the structure never requires copying it to a new location. 
\par To reserve a range of pages, use the {\b _PageReserve} service. Collectively, the pages reserved in a single call to the {\b _PageReserve} service comprise a memory block. The base linear address returned by {\b _PageReserve}
 identifies the block. For example, you specify this address when you free the block using the {\b _PageFree} service. 
\par To commit pages, use the {\b _PageCommit} service. This service allocates physic
al storage for a range of pages, and enables you to specify whether the pages are fixed (permanently locked) and what their privileges are. (Committing pages fixed rather than locked is more efficient if your VxD will never unlock the pages.) All pages co
mmitted at one time must be in the same memory block \emdash  that is, they must have been reserved by a single call to the {\b _PageReserve} service. To decommit pages, use the {\b _PageDecommit}
 service. Decommitting pages is different from freeing a memory block because the pages remain reserved. 
\par The {\b _PageCommit} service allocates physical memory purely on the basis of availability, such that there is no correlation between linear and physical addresses. Virtual device may sometimes require pages to be physically contiguous \emdash 
 for example, when allocating a DMA buffer. Using the {\b _PageCommitContig} service, you can commit pages that are physically contiguous, and may also specify a physical alignment and a range of allowable physical addresses. 
\par The {\b _PageCommitPhys} service ma
ps a range of pages to the specified physical addresses. The pages are considered committed. However, no physical memory is allocated by this service. That is, the service does not verify that the specified physical addresses are available, and not does u
pdate the list of free physical pages. The specified physical addresses must be outside the control of the memory manager, or otherwise under the control of the virtual device. For more information about the memory manager's use of physical memory, see {
\i Free Physical Page Management}. 
\par See also {\b _PageCommit}, {\b _PageCommitContig}, {\b _PageCommitPhys}, {\b _PageDecommit}, {\b _PageFree}, {\b _PageReserve}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Page Allocation 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The VMM provides a set of page allocation services that do not separately reserve and commit pages. Internally, these services simply reserve and commit pages in one step by calling the appropriate sparse memory management services. 
\par To allocate pages, use the {\b _PageAllocate} service. The service allocates (reserves and commits) a memory block, and returns the block's base linear address. The address is identical to the address returned by the {\b _PageReserve}
 service. To free the memory block, pass the linear address by using the {\b _PageFree} service. 
\par You can change the size of a memory block after it is allocated by using the {\b _PageReAllocate}
 service. The service attempts to change the committed size of the object without changing its base address. However, if necessary the service reserves a new memory block and copies the existing pages to it. 
\par To determine the size of a memory block, use the {\b _PageGetSizeAddr}
 service. This service returns the reserved size of the block, which may be greater than the number of committed pages in the memory block. You can get information about the amount of available memory by using the {\b _PageGetAllocInfo} and {\b 
_GetFreePageCount} services. 
\par Because these services use the sparse memory management services internally, it is possible to use the two groups of services in combination. For example, you might allocate a memory block using {\b _PageAllocate}
 and then decommit certain pages in that memory block using the {\b _PageDecommit} service. However, combining these services is generally not recommended because doing so might break assumptions made by the page allocation services. For example, the {\b 
_PageReAllocate} service assumes that all committed pages in a memory block are contiguous, which may not be the case if sparse memory allocation services have been used on the same region. 
\par See also {\b _PageGetAllocInfo}, {\b _GetFreePageCount}, {\b _PageGetSizeAddr}, {\b _PageReAllocate}, {\b _PageReserve}, {\b _PageFree}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Heap Allocation 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 You can use the system heap to allocate memory objects of any size, rather than allocating in units of pages. 
\par To allocate a memory object on the heap, use the {\b _HeapAllocate} service. You can change the size of the memory object using the {\b _HeapReAllocate} service and free it using the {\b _HeapFree}
 service. To determine the size of a memory object, use the {\b _HeapGetSize} service. 
\par There are three system heaps: the locked heap, the swappable heap, and the init heap. The init heap is discarded at the end of {\b Init_Complete}
. The locked and swappable heaps remain available as long as the system is running. Memory allocated into the swappable heap is swappable; your VxD must be careful not to access it at a time when paging is not allowed. 
\par The system provides no memory protection for memory objects on the heap. It also does not compact the heap. Therefore, virtual devices should avoid using the heap in such a way as to severely fragment it. 
\par See also {\b _HeapAllocate}, {\b _HeapFree}, {\b _HeapGetSize}, {\b _HeapReAllocate}
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Sparse Memory Allocation Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sparse memory allocation services enable virtual devices to allocate pages in two steps: reserving linear addresses, and then committing physical storage as needed. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageCommit 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageCommit(ULONG page, ULONG npages, ULONG hpd, 
\par \tab ULONG pagerdata, ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Commits physical pages to a range of linear addresses. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number to commit the first physical page to, and the number of pages to commit. The entire range of linear addresses must have been previously reserved by a single call to the {\b 
_PageReserve} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hpd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of a registered pager (returned by the {\b _PagerRegister} service) or one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PD_ZEROINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Swappable zero-initialized. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PD_NOINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Swappable uninitialized. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PD_FIXED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Fixed uninitialized (must also pass in PC_FIXED flag). \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PD_FIXEDZERO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Fixed zero-initialized (must also pass in PC_FIXED flag). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pagerdata}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A pager-defined 32-bit value to be stored with the page. Must be zero if the {\i hpd} parameter does not identify a registered pager. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 One or more of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_FIXED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The pages are permanently locked. If you know that the memory will remained locked throughout its lifetime, it is more efficient to use PC_FIXED than PC_LOCKED. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_LOCKED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are initially present and locked, but may be unlocked in the future. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_LOCKEDIFDP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The pages are locked only if the virtual pageswap device uses MS-DOS or BIOS functions to write pages to the hardware. (Note that in such a case, the pages are locked and not fixed.) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_STATIC \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The pages are committed even if the linear addresses were reserved using the PR_STATIC flag. If the linear address had been reserved with PR_STATIC and the PC_STATIC flag is not passed to _PageCommit, the function will fail. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_USER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are accessible at ring 3. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_WRITEABLE \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are writeable. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_INCR \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Increments the pager-defined 32-bit value associated with each page in the specified range. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the PC_LOCKED, PC_LOCKEDIFDP, or PC_FIXED flag is specified, none of the pages in the range of linear addresses specified by the {\i page} and {\i npages}
 parameters can already be committed. If none of these flags are specified, the range can include committed pages; however, recommitting already-committed pages is inefficient and should be avoided. 
\par {\b _PagerRegister}, {\b _PageReserve}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageCommitContig 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageCommitContig(ULONG page, ULONG npages, ULONG flags,
\par \tab ULONG alignmask, ULONG minphys, ULONG maxphys);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Commits physically contiguous pages to a range of linear addresses. ommitting physically contiguous pages is typically required only when interacting with hardware devices that impose external constraints on the physical properties of the memory on which 
they operate. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the base physical address if successful, \endash 1 otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number to commit the first physical page to, and the number of pages to commit. The entire range of linear addresses must have been previously reserved by a single call to the _{\b 
PageReserve} service, and none of the linear pages can be already committed. If the PC_NOLIN flag is specified, {\i page} is ignored. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_USER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are accessible at ring 3. \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_WRITEABLE \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are writeable. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PCC_ZEROINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are zero initialized. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PCC_NOLIN \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The pages are not mapped to any linear addresses. If PCC_NOLIN is passed, raw physical pages are allocated and the raw physical address is returned. Pages allocated in this way cannot be freed; they belong permanently to the caller. The PCC_NOLIN flag mus
t not be combined with any of the other flags. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i alignmask}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the physical alignment of the memory. Can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0x00 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 4 K alignment \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0x01 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 8 K alignment \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0x03 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 16 K alignment \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0x07 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 32 K alignment \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0x0F \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 64 K alignment \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0x1F \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 128 K alignment \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i minphys} and {\i maxphys}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Minimum and maximum physical page numbers for new pages. 
\par The pages allocated will be greater than or equal to minphys and strictly less than maxphys. For example, t
o ensure that the pages returned will lie below the 16MB boundary, pass minphys=0x0000 and maxphys=0x1000. If you do not wish to impose restrictions on the physical page numbers, pass minphys=0 and maxphys=-1. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is typically used when communicating with hardware devices which have peculiar requirements on the physical address on which they operate. The {\b _PageCommit}
 service does not ensure the physical properties of the pages committed. 
\par Pages allocated by this service are allocated as PC_FIXED. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageCommitPhys 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageCommitPhys(ULONG page, ULONG npages, ULONG physpg,
\par     ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Commits a specified physical page or range of physical pages to a range of linear addresses. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number to commit the first physical page to, and the number of pages to commit. The entire range of linear addresses must have been reserved by a single call to the {\b _PageReserve}
 service, and none of the linear pages can be already committed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i physpg}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Physical page number of the first page to commit. All of the physical pages committed must be either outside the control of the memory manager (for example, a memory-mapped device or video memory) or otherwise under the control of the virtual device drive
r making the call (for example, previously allocated and locked, or obtained by a previous call to {\b PageCommitContig} with the PCC_NOLIN flag). By default, all pages in the linear address region are mapped to the page number specified by {\i physpg}
. To commit a region of physical pages to a corresponding region of linear addrsses, use the PC_INCR flag. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 One or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_INCR \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The linear pages are mapped to an equal number of contiguous physical pages. That is, the physical page number is incremented for each linear page committed. 
\par this flag is not specified, all of the linear pages are mapped to the same physical page. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_USER \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are accessible at ring 3. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 PC_WRITEABLE \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The pages are writeable. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Memory committed through this service should not be touched while processing a hardware interrupt, since the page tables mapping the memory may be swapped out. This remains true even if the pages are locked using the {\b _LinPageLock} service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageDecommit 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageDecommit(ULONG page, ULONG npages, ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Decommits physical storage from a specified range of linear addresses. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if success, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of first page to decommit, and the number of pages to decommit. The entire range of linear addresses must have been reserved by a single call to the {\b _PageReserve} service. 
\par While the specified range can include pages that are already decommitted, this is not recommended. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Must be zero. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageFree 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 // C syntax
\par #include <vmm.h>
\par 
\par ULONG EXTERN _PageFree(ULONG hMem, ULONG flags);
\par 
\par // assembler syntax
\par include vmm.inc
\par 
\par VMMcall _PageFree, <hMem, flags>
\par or      eax, eax        ; nonzero if freed, zero if error
\par jz      failed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees the specified memory block. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hMem}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Base linear address of the memory block to free. This value must have been returned by the {\b _PageAllocate,} {\b _PageReAllocate, }or {\b _PageReserve}
 service. You may not free only part of a memory block. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Operation flags. Can be zero or PR_STATIC, which specifies that the memory block being freed was allocated as PC_STATIC. If the memory block was allocated as PC_STATIC, but the PR_STATIC field is not also specified, the free will fail.. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices that allocate PG_VM or PG_HOOKED pages must free these pages when the associated virtual machine is destroyed. PG_SYS pages do not need to be freed when Windows exits. 
\par If a virtual device maps a memory block into the V86 address space (using the {\b _MapIntoV86} service), it should unmap the memory block before attempting to free it. 
\par It is not an error to free memory which is all or partially locked. 
\par It is not necessary to decommit the memory inside a memory block before freeing it. Freeing a memory block automatically decommits its contents. 
\par {\b _PageAllocate}, {\b _PageReAllocate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageReserve 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageReserve(ULONG page, ULONG npages, ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Reserves a range of linear addresses in the current context without allocating any physical storage. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the linear address of the first reserved page if successful, \endash  1 otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the start of the range, or one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PR_PRIVATE \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Anywhere in current ring 3 private arena. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PR_SHARED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Anywhere in the ring 3 shared arena. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PR_SYSTEM \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Anywhere in the system arena. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 If an explicit page is specified, the memory manager attempts to allocate that linear page address. If the linear address is already in use, the service fails. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of linear pages to reserve. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PR_FIXED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Prevents {\b _PageReAllocate} from moving the pages. 
\cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PR_STATIC \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Disallows commit, decommit and free operations unless a static flag is specified. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PR_4MEG \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Forces the reserved address to be aligned on a four-megabyte boundary. This flag is ignored if the {\i page} parameter specifies a specific address. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Before touching any linear page reserved by this service, you must commit physical storage to the page using the {\b _PageCommit}, {\b _PageCommitContig}, or {\b _PageCommitPhys} service. 
\par {\b _PageCommit}, {\b _PageCommitContig}, {\b _PageCommitPhys}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Page Allocation Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Page allocation services allocate blocks of pages, without separately reserving and committing them. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetFreePageCount 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetFreePageCount, <flags>
\par 
\par mov     dword ptr [FreePages], eax      ; number of free pages
\par mov     dword ptr [LockablePages], edx  ; number of lockable pages
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the number of pages in the free list. This service also returns the number of free pages that can be allocated as locked pages. Uses EAX, ECX, EDX, and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the number of free pages in the EAX register register and the number of pages available for allocation as locked pages in the EDX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices can allocate pages by using the {\b _PageAllocate, _PageCommit}, {\b _PageCommitContig}, or {\b _PageCommitPhys} service. 
\par In a demand-paged virtual memory system such as Windows, the number of free pages is usually very close to 0, so the count of pages available for locking is usually a better indicator of available memory. However, virtual devices must not rely on the coun
t of free pages being less than or equal to the count of pages to lock. No guarantees can be made about the length of time the information returned by this service remains accurate. 
\par {\b _PageAllocate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageAllocate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 // C syntax
\par #include <vmm.h>
\par 
\par ULONG EXTERN _PageAllocate(ULONG nPages, ULONG pType, ULONG VM, 
\par     ULONG AlignMask, ULONG minPhys, ULONG maxPhys, ULONG *PhysAddr,
\par     ULONG flags);
\par 
\par ; assembler syntax
\par include vmm.inc
\par 
\par VMMcall _PageAllocate, <nPages, pType, VM, AlignMask, minPhys,
\par     maxPhys, <OFFSET32 PhysAddr>, flags>
\par 
\par test    eax, eax             ; returns 0 on error
\par jz      error
\par 
\par mov     [Address], eax       ; linear address of allocated memory block
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allocates a block of memory consisting of the specified number of pages. This service reserves linear address space for the memory block, and depending on the value of the {\i flags}
 parameter, may also map the linear addresses to physical memory, locking the pages in memory. The service returns a memory handle that can be used in subsequent memory management functions to lock, unlock, reallocate, and free the memory block. Uses EAX,
 ECX, EDX, and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the ring-0 l
inear address of the memory block (in the EAX register). For compatibility with Windows 3.1, the same value is returned in EDX. For Windows 3.1, EAX was the memory handle and EDX the memory address. For Windows 95, the handle and the linear address are al
ways the same. Both registers are zero if an error occurs, such as insufficient memory. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to allocate for the memory block. This parameter must not be zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the type of pages to allocate. Must be PG_HOOKED, PG_
SYS, or PG_VM. If PG_SYS is specified, the pages are allocated in the system arena. Otherwise, they are allocated in the ring 3 shared arena. There is no real difference between the PG_HOOKED and PG_VM types. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which to allocate the pages. This parameter applies to pages allocated using the PG_VM and PG_HOOKED values only. This parameter must be zero if the {\i nType}
 parameter specifies PG_SYS. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i AlignMask}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Alignment mask that defines acceptable starting page numbers for the memory block. This parameter can be one of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 00000000h \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Physical address is a multiple of 4K. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 00000001h \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Physical address is a multiple of 8K. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 00000003h \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Physical address is a multiple of 16K. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 00000007h \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Physical address is a multiple of 32K. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0000000Fh \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Physical address is a multiple of 64K. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0000001Fh \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Physical address is a multiple of 128K. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 This parameter is used only if the {\i flags} parameter specifies the PAGEUSEALIGN value. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i minPhys}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Minimum acceptable physical page number in the memory block. All page numbers must be greater than or equal to this value. This parameter is used only if the {\i flags}
 parameter specifies the PAGEUSEALIGN value. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i maxPhys}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Maximum acceptable physical page number in the memory block. All page numbers must be less than this value. This parameter is used only if the {\i flags} parameter specifies the PAGEUSEALIGN value. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PhysAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a four-byte buffer that receives the physical address of the start of the memory block. The service uses this parameter only if the {\i flags}
 parameter specifies the PAGECONTIG and PAGEUSEALIGN values. The service ignores this parameter if it is zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGECONTIG \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Allocates contiguous physical pages to create the memory block. This value is ignored if the PAGEUSEALIGN value is not also specified. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEFIXED 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Locks the allocated pages in memory at a fixed linear address, and prevents the pages from subsequently be
ing unlocked or moved. The service locks the memory block regardless of the type of virtual page swap device present. 
\par the page will remain locked throughout its life, use PAGEDFIXED; it's more efficient than PAGELOCKED. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGELOCKED \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Locks the allocated pages in the memory. The pages can be subsequently unlocked using the {\b _PageUnLock}
 service. The service locks the memory block regardless of the type of virtual page swap device present. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGELOCKEDIFDP \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Locks the allocated pages in the memory only if the v
irtual page swap device uses MS-DOS or BIOS functions to write to the hardware. If the pages are locked, they can be subsequently unlocked using the {\b _PageUnLock} service. 
\par irtual device must not specify the PAGELOCKEDIFDP value until after it has received the {\b Init_Complete} message. 
\par  PAGELOCKED and PAGELOCKEDIFDP values are mutually exclusive. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEUSEALIGN \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Allocates pages using the alignment and physical addresses specified by the {\i AlignMask}, {\i minPhys}, and {\i maxPhys} parameters. If this value is specified, PAGEFIXED must also be specified. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEZEROINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Fills the memory block with zeros. If this value is not given, the contents of the memory block are undefined. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service reserves linear address space by calling the {\b _PageReserve} service, and then commits physical storage by calling the {\b _PageCommit}
 service. The address returned by this service can be used in the same manner as the linear address returned by the {\b _PageReserve} service. 
\par Unless the PAGELOCKED, PAGELOCKEDIFDP, o
r PAGEFIXED value is specified, the allocated pages are not initially present in physical memory. The system maps a page into physical memory (pages it in) when a virtual device attempts to access the page. You can force a page to be present by using the 
{\b _PageLock} service. 
\par Virtual devices use the PAGEUSEALIGN value to allocate buffers for use by the device which have additional alignment restrictions enforced by the hardware. For example, a DMA may require buffers to start at addresses that are a multiple 
of 64K or 128K. When allocating such buffers, the PAGECONTIG value is often used in combination with PAGEUSEALIGN. 
\par {\b _PageFree}, {\b _PageLock}, {\b _PageReAllocate}, {\b _PageUnLock}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageGetAllocInfo 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _PageGetAllocInfo, <flags>
\par 
\par mov     [Lockable], edx     ; count of lockable pages
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the number of pages that can be allocated as locked or fixed memory. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the number of pages available for allocating as locked pages in
 the EDX register. The value returned in the EAX register is undefined. (This peculiar return convention is for Windows 3.1 compatibility.) 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices must not rely on being able to allocate all pages specified by this service. In general, virtual devices should allocate memory as needed, and not attempt to allocate all available memory. 
\par {\b _PageAllocate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageGetSizeAddr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _PageGetSizeAddr, <hMem, flags>
\par 
\par test    eax, eax            ; returns zero if error
\par 
\par mov     [Pages], eax        ; number of pages in memory block
\par mov     [Address], edx      ; ring-0 linear address of memory block
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the size and linear address of a memory block. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the number of pages in the memory block in the EAX register. For compatibility with Windows 3.1, the ring-0 linear address of the memory block is returned in the EDX register. Both registers are z
ero if an error occurs. (Under Windows 95, handles and addresses are the same, so the return value in EDX is relatively meaningless.) 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hMem}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Base linear address of the memory block for which to return information. This parameter may be a handle returned by the {\b _PageAllocate} or {\b _PageReAllocate}
 service, or may be a linear address returned by the {\b _PageReserve} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The return value specifies the number of reserved pages for the memory block, which may be greater than the number of committed pages. For example, if the {\b _PageReAllocate}
 service is used to reduce the size of a memory block, the number of virtual pages reserved for that block may remain unchanged. 
\par {\b _PageAllocate}, {\b _PageReAllocate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageReAllocate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 // C syntax
\par #include <vmm.h>
\par 
\par ULONG EXTERN _PageReAllocate(ULONG hMem, ULONG nPages, ULONG flags);
\par 
\par ; assembler syntax 
\par 
\par VMMcall _PageReAllocate, <hMem, nPages, flags>
\par 
\par test    eax, eax        ; zero in eax if error
\par jz      error
\par 
\par mov     [Address], eax  ; new linear address
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Resizes and optionally reinitializes an existing memory block. The service can increase or decrease the number of pages in the memory block. Uses EAX, ECX, EDX and flags. 
\par  Returns the ring-0 linear address of the block (in the EAX register). For compatibility with Windows 3.1, the same value is returned in the EDX register. 
\par Both registers are zero if an error occurs, such as insufficient memory, an invalid memory address, or the wrong memory type. In this case, the original memory block is unchanged. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hMem}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Base linear address of the memory block to reallocate. In most cases, this should be a value returned by the {\b _PageAllocate} or {\b _PageReAllocate}
 service. If this parameter is a linear address returned by the {\b _PageReserve} service, see the cautions below. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages in the reallocated memory block. This parameter must not be zero. To free a memory block, use the {\b _PageFree} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGELOCKED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Locks the allocated pages in the memory. The pages can be subsequently unlocked using the {\b _PageUnLock} service. The service locks the memory block regardless of the type of virtual page swap device present. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGELOCKEDIFDP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Locks the allocated pages in memory only if the virtual page swap device uses MS-DOS or BIOS functions to write to the hardware. If the pages are locked, they can be subsequently unlocked using the {\b _PageUnLock} service. 
\par irtual device must not specify the PAGELOCKEDIFDP value until after the {\b Init_Complete} message has been processed by all virtual devices. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
PAGENOCOPY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Does not preserve contents of existing pages. If this value is {\i not}
 given, the service preserves the contents of each existing page by copying the contents of the old memory block into the corresponding pages of the new block. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEZEROINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Fills any new pages with zeros. All existing pages remain unchanged. \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEZEROREINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Fills all pages, new and existing, with zeros. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service chang
es the number of committed pages for the memory block. It attempts to do so without changing the base linear address. If necessary, however, the service reserves a new memory block, copies the old data into it, and then frees the existing memory object. 

\par If you use this service with sparse memory management services, such as {\b _PageReserve,} {\b _PageCommit,} and {\b _PageDecommit,}
 you must ensure that all committed pages are contiguous and that the first committed page is at the start of the memory block's reserved ad
dress range. If pages have been committed sparsely, the service may return an error or free pages unexpectedly. You can reallocate a memory block that has no committed pages. For example, you could call {\b _PageReserve} and then {\b _PageReAllocate}. 

\par If the specified base linear address identifies a fixed memory block (allocated using the PAGEFIXED value), this service implicitly allocates fixed pages for the new memory block. The service returns an error if the block cannot be reallocated without cha
nging the base linear address. 
\par If the specified base linear address identifies an aligned memory block (allocated using the PAGEUSEALIGN value), this service returns an error. 
\par If the specified base linear address identifies a memory block allocated by {\b _PageReserve} with the PR_STATIC flag, this service returns an error. 
\par Virtual devices must never rely on the new and old starting addresses being equal. 
\par The action specified by the PAGELOCKEDIFDP value is available only after the virtual page swap device has been initialized. 
\par {\b _PageAllocate}, {\b _PageFree}, {\b _PageLock}, {\b _PageReserve}, {\b _PageUnLock}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Heap Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Heap allocation services enable virtual devices to allocate memory objects of arbitrary size, rather than in units of pages. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _HeapAllocate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 // C syntax
\par #include <vmm.h>
\par 
\par ULONG EXTERN _HeapAllocate(ULONG nbytes, ULONG flags);
\par 
\par ; assembler syntax
\par include vmm.inc
\par 
\par VMMcall _HeapAllocate, <nbytes, flags>
\par 
\par or      eax, eax            ; zero if error
\par jz      not_allocated
\par mov     [Address], eax      ; address of memory block
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allocates a block of memory from the system heap. Uses EAX, ECX, EDX, and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the address of the block in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nbytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the size in bytes of the block to allocate. Must not be zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Allocation flags. Can be zero or more of these values. 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HEAPLOCKEDIFDP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Allocates a memory block in locked memory only if MS-DOS or BIOS functions are used for paging. Otherwise, the memory block is allocated in pageable memory. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HEAPINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Allocates a memory block that is automatically freed after initialization. This value can only be specified during initialization. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HEAPSWAP \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocates a memory block in pageable memory. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HEAPZEROINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Fills the memory block with zeros. If this value is not given, the initial content of the memory block is undefined. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par Only one of the values HEAPINIT, HEAPSWAP, or HEAPLOCKEDIFDP can be specified. If none of these values is specified, the block is allocated in fixed memory. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service aligns allocated block on doubleword boundaries, however, the block size does not have to be a multiple of 4. 
\par Since the system offers no protection on the heap, virtual devices must provide their own protection to prevent overrunning allocated blocks. 
\par The system offers no compaction on the heap; all memory blocks on the heap are fixed. Virtual devices must not to use the heap in such a way as to severely fragment it. 
\par {\b _HeapFree}, {\b _HeapReAllocate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _HeapFree 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 // C syntax 
\par #include <vmm.h>
\par 
\par ULONG EXTERNAL _HeapFree(ULONG hAddress, ULONG flags);
\par 
\par ; Assembler syntax 
\par include vmm.inc
\par 
\par VMMcall _HeapFree, <hAddress, flags>
\par 
\par or      eax, eax            ; nonzero if freed, zero if error
\par jz      not_freed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees an existing memory block in the system heap. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hAddress}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the memory block to free. This address must have been previously returned by the {\b _HeapAllocate} or {\b _HeapReAllocate} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Although the system can usually recover from an attempt to free an invalid address, you should not rely on this. 
\par {\b _HeapAllocate}, {\b _HeapReAllocate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _HeapGetSize 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 // C syntax
\par #include <vmm.h>
\par 
\par ULONG EXTERNAL _HeapGetSize(ULONG hAddress, ULONG flags);
\par 
\par ; assembler syntax
\par include vmm.inc
\par 
\par VMMcall _HeapGetSize, <hAddress, flags>
\par 
\par or      eax, eax        ; zero if error
\par jz      error
\par mov     [Size], eax     ; size in byte of memory block
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the size, in bytes, of an existing block in the system heap. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the of the block in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hAddress}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the memory block. This address must have been previously returned by the {\b _HeapAllocate} or {\b _HeapReAllocate} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Although the system can usually recover from an attempt to get the size of an invalid address, you should not rely on this. 
\par {\b _HeapAllocate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _HeapReAllocate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 //C syntax
\par #include <vmm.h>
\par 
\par ULONG EXTERNAL _HeapReAllocate(ULONG hAddress, ULONG nbytes, ULONG flags);
\par 
\par ; assembler syntax
\par include vmm.inc
\par 
\par VMMcall _HeapReAllocate, <hAddress, nbytes, flags>
\par 
\par or      eax, eax        ; zero if error
\par jz      error
\par mov     [Address], eax  ; address of reallocated block
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Reallocates or reinitializes a memory block in the system heap. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the address of the reallocated block in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hAddress}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the memory block. This address must have been previously returned by the {\b _HeapAllocate} or {\b _HeapReAllocate} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nbytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 New size, in bytes, of the block. Must not be zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Allocation flags. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HEAPNOCOPY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Does not preserve contents of existing bytes. If this value is {\i not}
 given, the service preserves the contents of existing bytes by copying the contents of the old memory block into the new block. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HEAPZEROINIT 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Fills any new bytes in the memory block with zeros. All existing bytes remain unchanged. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HEAPZEROREINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Fills all bytes, new and existing, with zeros. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If this service is successful, it frees the old memory block, making the old address invalid. Virtual devices must {\i never}
 rely on the old and new addresses being the same. If this service returns an error, the old memory block is not freed and the old address remains valid. 
\par Since the system offers no protection on the heap, virtual devices must provide their own protection to prevent overrunning allocated blocks. 
\par The system offers no compaction on the heap; all memory blocks on the heap are fixed. Virtual devices must not use the heap in such a way as to severely fragment it. 
\par Although the system can usually recover from an attempt to reallocate an invalid address, you should not rely on this. 
\par {\b _HeapAllocate}, {\b _HeapFree}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 170}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 12 Miscellaneous Services{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 171}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 12
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Miscellaneous Services 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Miscellaneous Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following miscellaneous services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _AddReclaimableItem}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Identifies regions of VM memory that can be reclaimed. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Begin_Reentrant_Execution}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Start re-entrant execution. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _CallRing3}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for internal use. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Close_Boot_Log}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Closes the system boot log. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Directed_Sys_Control}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Jumps to the VxD's device-control procedure. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b EnableDisable_Boot_Log}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables or disables boot logging from the virtual machine manager (VMM). 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b End_Reentrant_Execution}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 End re-entrant execution. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _EnumReclaimableItem}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Enumerates reclaimable regions of VM memory declared by a previous call to the {\b _AddReclaimableIem}. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Boot_Flags}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Retrieves the boot-time flags. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_DDB}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Determines whether or not a VxD is installed for the specified device and returns a DDB for that device if it is installed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b GetSetDetailedVMError}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Gets and sets error information. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _GetVxDName}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Retrieves the name of the VxD that contains the specified linear address. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_Device_PM_API}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a protected-mode API callback. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_Device_Service}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a hook for a device service. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_Device_V86_API}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a V86-mode API callback. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Install_Exception_Handler}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs an exception handler. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _LocalizeSprintf}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 To be supplied. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _LocalizeStackSprintf}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 To be supplied. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Log_Fault_Call_Out}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Callout service that the VMM calls when it is about to report a fault to the user. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Map_Flat}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts a V86 or protected-mode address. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Map_Lin_To_VM_Addr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts a linear address. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b MMGR_SetNULPageAddr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets the physical address of system nul page. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Open_Boot_Log}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Opens the system boot log. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Register_Win32_Services}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Copies the location of the calling VxD's Win32 service-table in the DDB. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Remove_Exception_Handler}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes an exception handler. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_Boot_Flags}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets the boot-time flags. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_Delete_On_Exit_File}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Adds a file to the list to delete when exiting. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _SetReclaimableItem}\cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Marks as fully reclaimable or restorable, the regions of reclaimable VM memory declared by a previous call to the {\b _AddReclaimableItem} service. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_System_Exit_Code}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets the Windows exit code value. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b System_Control}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sends a control message to all virtual devices. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_Device_Service}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Unhooks a device service. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VMM_Add_DDB}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Adds a {\b Vxd_Desc_Block}
 structure (DDB) to the appropriate location in the device list (the locations are based on the inititialization order). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VMM_GetDDBList}\cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Retrieves the address of the DDB list. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VMM_GetVxDLocationList}\cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the address of the VxD location list in EAX, returns the count of VxDs in EDX, and returns the list size (in bytes) in ECX. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VMM_Remove_DDB}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes a {\b Vxd_Desc_Block} structure (DDB) from the device list. \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VMMAddImportModuleName}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Adds the specified import-module name to an internal table. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Functions 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _AddReclaimableItem 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include vmm.h
\par 
\par _AddReclaimableItem(ReclaimStruc *pReclaim, DWORD Flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Identifies regions of VM memory that may be reclaimable. Uses C calling convention and the EAX, ECX, EDX, and Flags registers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns non-zero in the EAX register if successful; otherwise returns zero in EAX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pReclaim}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of {\b ReclaimStruc} structure to add. The callback in the {\b RS_CallBack} member of the {\b ReclaimStruc }structure is called using the CDE
CL calling and register conventions, and has no defined return value. The reference data for the callback, if any, is not passed separately, since it is already available in the {\b ReclaimStruc}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved; must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If a region is already reclaimable, then RS_RECLAIM should be specified in the {\b RS_Flags }member of the specifed {\b ReclaimStruc} structure. Otherwise, a subsequent call to {\b _SetReclaimableItem}
 must be made to set RS_RECLAIM sometime prior to {\b Init_Complete} in order for the block to be re-used. 
\par If the block's contents must be restored prior to {\b System_Exit}, then RS_RESTORE must also be specified in the {\b RS_Flags }
member. If an optional callback address is also provided, then it will be called immediately after the contents have been restored, prior to {\b System_Exit}. 
\par If the system elects to not use a fully-reclaimable block (for example, if the block's alignment or size makes it unsuitable), it will still call the caller's callback address, if any, so that any external references to the block can still be restored. 

\par In the unlikely event a block marked reclaimable cannot later be reclaimed, call _{\b SetReclaimableItem} with the RS_RECLAIM flag clear. 
\par {\b _EnumReclaimableItem}, {\b ReclaimStruc}, {\b _SetReclaimableItem}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Reentrant_Execution 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Begin_Reentrant_Execution
\par 
\par mov     [Count], ecx        ; re-entrancy count
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Starts re-entrant execution. Virtual devices use this service when hooking VMM faults (re-entrant processor exceptions) so that they may call nonasynchronous VMM or virtual device 
services, or execute a virtual machine. Uses ECX, Flags. 
\par Most virtual devices have no reason to use this service. Do {\i not} use this service to avoid scheduling events on hardware interrupts. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the old re-entrancy count in the ECX register. This count must be passed to the End_Reentrant_Execution service. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b End_Reentrant_Execution}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _CallRing3 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is reserved for the Shell VxD to implement application-time events. Do not call this service directly. To call ring 3 code from a VxD, use the {\b SHELL_CallAtAppyTime} service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Close_Boot_Log 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Close_Boot_Log
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Requests that the system boot log be closed. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b EnableDisable_Boot_Log}, {\b Open_Boot_Log}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Directed_Sys_Control 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, DDB
\par VMMCall Directed_Sys_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Jumps to the VxD's device-control procedure. Use this service instead of calling the control procedure directly. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Return value depends on the message sent to the virtual device. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DDB}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 VxD's DDB that contains device control procedure. All other registers are passed unaltered to the control procedure. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 EnableDisable_Boot_Log 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par move    eax, fEnable
\par VMMcall EnableDisable_Boot_Log
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Enables or disables boot logging from the virtual machine manager (VMM). This service is intended to be used by the sy
stem (IOS) to indicate whether it is safe to write to the disk; other VxDs should not use this service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i fEnable}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Enable flag. If non-zero, enables boot logging; if zero, disables it. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Close_Boot_Log}, {\b Open_Boot_Log}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Reentrant_Execution 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, Count      ; re-entrancy count
\par VMMcall End_Reentrant_Execution
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Ends re-entrant execution. A virtual device that calls the {\b Begin_Reentrant_Execution} service must call this service before returning. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Count}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Re-entrancy count previously returned by the {\b Begin_Reentrant_Execution} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_Reentrant_Execution}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _EnumReclaimableItem 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include vmm.h
\par 
\par DWORD _EnumReclaimableItem(DWORD enumKey, ReclaimStruc *pReclaim, 
\par     DWORD Flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Enumerates regions of potentially reclaimable VM memory that were added by a previous call to the {\b _AddReclaimableItem} service. The items are enumerated in 
ascending order according to their addresses. Uses C calling convention and the EAX, ECX, EDX, and Flags registers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the enumeration key in EAX for each reclaimable region, or zero if there are no reclaimable regions or the last region has been enumerated. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i enumKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Enumeration key. Set this parameter to zero to begin enumeration. Subsequent calls to this service specify enumeration keys returned by previous calls. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pReclaim}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the {\b ReclaimStruc} structure that receives information about a reclaimable region. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved; must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _AddReclaimableItem}, {\b ReclaimStruc}, {\b _SetReclaimableItem}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Boot_Flags 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall Get_Boot_Flags
\par 
\par mov [BootFlags], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the boot-time flags. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the boot time flags in the EAX register which may be one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BOOT_CLEAN (00000001H) \cell \pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \trowd \trleft280 \cellx3160\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BOOT_DOSCLEAN(00000002H) \cell \pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
BOOT_NETCLEAN (00000004H) \cell \pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BOOT_INTERACTIVE (00000008H) \cell 
\pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_DDB 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Device_ID
\par mov     edi, Device_Name
\par VMMCall Get_DDB
\par mov     [DDB], ecx
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether or not a VxD is installed for the specified device and returns a DDB for that device if it is installed. Uses ECX, flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a DDB for the specified device if the function succeeds; otherwise, returns zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Device_ID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The device identifier. This parameter can be zero for name-based devices. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Device_Name}
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 An eight-character device name that is padded with blank characters. This parameter is only required if {\i Device_ID} is zero. The device name is case-sensitive. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 GetSetDetailedVMError 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM       ; VM handle or 0 if Create_VM error
\par mov     ecx, GetSet   ; zero if get, nonzero zero if set
\par mov     eax, Error    ; error code if ecx nonzero
\par mov     edx, RefData  ; reference data if ecx is nonzero
\par VMMcall GetSetDetailedVMError
\par 
\par jz      no_error_info   ; zero set if no error information
\par 
\par mov     [Error], eax    ; error code
\par mov     [RefData], edx  ; reference data for the error code
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets detailed error code for a virtual machine crash or start-up error. This service is only available for Windows version 3.1 or later. Uses EAX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the zero flag clear if detailed error information was found, set otherwise. If the zero flag is clear, the EAX register contains an error code and the EDX register contains reference data associated with the error code. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine. If this parameter is zero, the service gets or sets error information for the {\b Create_VM} message. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i GetSet}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the action to take. If zero, the service retrieves error information. If nonzero, the service sets error information. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Error}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Error code to set. This parameter is ignored if the {\i GetSet} parameter is zero. There are the following error code values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_CrtNoMsg \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Problem creating the VM. The system will not display any error message; it is the responsibility of the virtual device to use the {\b SHELL_Message} service to display a custom error message. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_DevNuke \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Device-specific problem. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_DevNukeHdwr \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Device-specific problem caused by software running in the virtual machine. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InsMemEMS \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Available EMS memory is less than requested; set by the virtual V86 mode memory manager. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InsMemV86 \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Insufficient V86 memory; set by the virtual V86 mode memory manager. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
GSDVME_InsMemV86Hi \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Insufficient high MS-DOS memory; set by the virtual MS-DOS manager. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InsMemVid \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Insufficient base video memory; set by the virtual display device. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InsMemVM \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Insufficient base virtual machine memory for control block or instance buffer. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InsMemXMS \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Available XMS memory is less than requested; set by the virtual V86 mode memory manager. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 GSDVME_InsV86Space \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Available V86 address space is less than requested; set by the virtual V86 mode memory manager. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InvalFlt \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Invalid fault. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InvalGpFlt \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Invalid GP fault. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InvalInst \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Attempt to execute an invalid instruction. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InvalPgFlt \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Invalid page fault. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_InsMemDev \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Could not allocate base virtual machine memory for device. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_NukeNoMsg \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Fatal problem forcing the VM to be destroyed. The system will not display any error message; it is the responsibility of the virtual device to use the {\b SHELL_Message} service to display a custom error message. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_OkNukeMask \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for the exclusive use of the virtual MS-DOS manager. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_PrivInst \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Attempt to execute a privileged instruction. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GSDVME_UserNuke \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
User requested running virtual machine be terminated. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Error values that have the high word set to 2 are intended to be used when a virtual machine fails on start up. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to set. If the {\i Error} parameter is GSDVME_PrivInst, GSDVME_InvalInst, GSDVME_InvalPgFlt, GSDVME_InvalGpFlt, or GSDVME_InvalFlt, this parameter is the address of a {\b VMFaultInfo} 
structure that contains data associated with the error. Otherwise, {\i RefData} is a pointer to an eight-character buffer giving the name of the virtual device that reported the error. 
\par This parameter is ignored if the {\i GetSet} parameter is zero. This parameter is zero if there is no associated reference data. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetVxDName 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include vmm.h
\par 
\par _GetVxDName(DWORD laddr, DWORD pszName);
\par 
\par mov [BaseAddr], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the name of the VxD that contains the specified linear address. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab R
eturns the base address of the VxD in the EAX register if successful; otherwise returns 0 in EAX. Uses C calling convention. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i laddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear address to locate. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pszName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Buffer to receive the object name. If the function fails, {\i pszName }is filled in with the ASCII version of {\i laddr}. This buffer must be at least 80 bytes in size. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Object names consist of the VxD name, segment number, and offset; for example, VTDAPI(03) + 27C. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_Device_PM_API 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, ID                 ; device ID
\par mov     esi, OFFSET32 Callback  ; points to new API callback
\par VMMcall Hook_Device_PM_API
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Installs an API callback procedure allowing a virtual device to intercept calls to the protected-mode API of another virtual device. This service is intended to support virtual devices that need to monitor calls to the APIs of other virtual devices. Most 
virtual devices will never need this service. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set if the specifi
ed virtual device does not support a protected-mode API. If successful, the ESI register contains the address of the previous callback procedure. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Identifier of the virtual device to monitor. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure to install. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the callback procedure whenever an application in a virtual machine calls the API for the specified virtual machine. The system calls the callback as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     ebp, OFFSET32 crs   ; points to Client_Reg_Struc
\par call    [Callback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine and the {\i crs} parameter points to a {\b Client_Reg_Struc}
 structure containing the register values of the current virtual machine. Other registers contain the parameter values intended for the API. 
\par The callback procedure can carry out tasks, but eventually must pass execution to the previous API callback procedure, preserving the EBX and EBP registers when it calls. 
\par {\b Hook_Device_V86_API}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_Device_Service 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par GetDeviceServiceOrdinal eax, Service
\par mov     esi, OFFSET32 HookProc  ; points to the hook procedure to install
\par VMMcall Hook_Device_Service
\par 
\par jc      not_installed           ; carry flag set if error
\par IF WIN31COMPAT
\par mov     [Real_Proc], esi
\par ENDIF
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allows one virtual device to monitor or replace the services of another virtual device, or of the VMM itself. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the 
carry flag clear if successful, set otherwise. If successful, the ESI register contains the address of the specified service. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Service}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Virtual device or VMM service to hook. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i HookProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the hook procedure to install. The hook procedure is called with the same parameters as the service specified by the {\i Service} parameter. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When a dynamically-loaded VxD is unloaded, it must remove any service hook procedures it has installed by using the {\b Unhook_Device_Service} service. 
\par Virtual devices that use this service must use extreme care to preserve the full functionality of the virtual device whose services are monitored or replaced. 
\par More than one virtual device can hook a device service. The last hook installed is the first one called. 
\par The hook procedure must save and restore registers that are not modified by the hooked service. Also, if flags are a passed as an entry or exit parameter, the hook procedure must also preserve the flags. 
\par If the hooked service uses the C calling 
convention, the hook procedure must copy the entire parameter stack frame before attempting to call the hooked service. If the hooked service uses a register-based calling convention, the hook procedure must preserve all registers, even registers that are
 not currently used as input or output parameters. 
\par The hook procedure must have been declared with the HOOK_PROC attribute to the {\b BeginProc} macro. 
\par {\b Unhook_Device_Service}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_Device_V86_API 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, ID                 ; device ID
\par mov     esi, OFFSET32 Callback  ; points to new API callback
\par VMMcall Hook_Device_V86_API
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Installs an API callback procedure allowing a virtual device to intercept calls to the V86 mode API of another virtual device. This service is intended to support virtual devices that need to monitor calls to the APIs of other virtual devices. Most virtua
l devices will never need this service. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set if the specified virtu
al device does not support a V86-mode API. If successful, the ESI register contains the address of the previous callback procedure. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Identifier of the virtual device to monitor. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure to install. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the callback procedure whenever an application in a virtual machine calls the API for the specified virtual machine. The system calls the callback as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     ebp, OFFSET32 crs   ; points to Client_Reg_Struc
\par call    [Callback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine and the {\i crs} parameter points to a {\b Client_Reg_Struc}
 structure containing the register values of the current virtual machine. Other registers contain the parameter values intended for the API. 
\par The callback procedure can carry out tasks but eventually must pass execution to the previous API callback procedure, preserving the EBX and EBP registers when it calls. 
\par {\b Hook_Device_PM_API}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Install_Exception_Handler 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, Exception          ; points to an Exception_Handler_Struc
\par VMMcall Install_Exception_Handler
\par 
\par jc      not_installed           ; carry flag set if error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a ring-0 exception handler. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Exception}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an {\b Exception_Handler_Struc} structure containing information about the exception handler to install. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system saves a pointer to the specified {\b Exception_Handler_Struc}
 structure instead of copying it. Therefore, the structure must not be in pageable memory, and must not be freed or overwritten until the exception handler is removed. 
\par The system calls the exception handler only if the exception occurs within the range of addresses specified by the {\b EH_StartIP} and {\b EH_EndIP} fields in the {\b Exception_Handler_Struc} structure. The system ca
lls the exception handler with the stack and all registers in same state as when exception occurred. 
\par You can use the {\b Remove_Exception_Handler} service to remove an exception handler that was installed using this service. 
\par {\b Exception_Handler_Struc}, {\b Remove_Exception_Handler}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _LocalizeSprintf 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 $include vmm.inc
\par 
\par VMMCall _LocalizeSprintf, <pOutBuf, pmab, RelativeMessageNumber, 
\par     Param1, Param2, ...>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Format a localizable string. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pOutBuf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a buffer to receive formatted message.No limit checking is done on the buffer. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pmab}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a message anchor block constructed by the message macros. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RelativeMessageNumber}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Message number relative to the base message number for the message class. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1, Param2, ...}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Parameters for the formatted message. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices typically use the {\b LOCALIZE_SPRINTF} macro instead of calling this service directly. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _LocalizeStackSprintf 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is for internal use only. Use one of the PUSH_SPRINTF macros instead of this service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Log_Fault_Call_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     esi, FaultNumber
\par mov     eax, OFFSET32 EventProc
\par mov     edx, UpperStackLimit
\par mov     ebp, FrameClient_Regs
\par VMMcall Log_Fault_Call_Out
\par jnc     not_handled
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This is a callout service that the VMM calls when it is about to report a fault to the user. It is provided so that a supplemental VxD can hook this service and log faults that are reported. The supplemental VxD can also handle the fault notification itse
lf and indicate to the VMM that it shouldn't duplicate the notification. Virtual deices should not call this service directly. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Sets the carry flag if the notification has been handled, indicating that the VMM should not
 do its own notification. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNumber}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the fault to report. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FrameClient_Regs}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Ring 0 client registers of the fault stack frame. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i EventProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the event procedure for the event being processed, address of the timeout procedure associated with the timeout being processed, or zero if neither an event nor a timeout was processed. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i UpperStackLimit}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Upper limit of stack used by event being processed, or garbage if neither an event nor a timeout was processed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Before calling this service (that is, on entry to the hook procedure), the stack looks like this: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 esp    <undefined area between the current ESP and EBP-16>
\par ebp-16  -> saved gs
\par ebp-12  -> saved fs
\par ebp-8   -> saved es
\par ebp-4   -> saved ds
\par ebp     -> pushad frame
\par         -> error code
\par         -> faulting eip
\par         -> faulting cs
\par         -> flags
\par edx     -> upper limit of stack used by event being processed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifications can not be suppressed if the fault was not caused by an event or timeout. 
\par This service can modify any of the registers 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Map_Flat 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ah, SegOffset    ; client register containing the segment
\par mov     al, OffOffset    ; client register containing the offset
\par VMMcall Map_Flat
\par 
\par cmp     eax, -1         ; -1 if error
\par je      error
\par mov     [LinAddr], eax  ; ring-0 linear address
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts the addres
s contained in the specified client registers to a linear address. The given address is either a selector:offset or segment:offset address, depending on the execution mode of the current virtual machine. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a ring-0 linear address in the EAX register if successful, \endash 
 1 if the specified selector is invalid. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SegOffset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset of the client register containing the segment address or selector. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i OffOffset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset of the client register containing the offset address. Can be \endash  1, in which case the offset address is zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i SegOffset} and {\i OffOffset} parameters specify offsets, in bytes, relative to the beginning of the {\b Client_Reg_Struc} structure for the current virtual machine. 
\par Before converting an address, {\b Map_Flat}
 checks the current execution mode and, for protected-mode applications, the bitness of the DPMI client. If the virtual machine is running a 32-bit protected mode application, it uses 32-bit address offsets. For V86 and 16-bit protected-mode app
lications, it uses 16-bit address offsets and ignores the high word if the {\i OffOffset} parameter specifies a 32-bit register. 
\par The following example converts the address {\b Client_DS:Client_DX} and returns the linear address in EAX: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ax, (Client_DS SHL 8) + Client_DX
\par VMMcall Map_Flat
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 It is typically more convenient to use the {\b Client_Ptr_Flat} macro instead. 
\par {\b Client_Ptr_Flat}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Map_Lin_To_VM_Addr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, LineAddr   ; linear address to convert
\par mov     ecx, Limit      ; segment limit in bytes
\par VMMcall Map_Lin_To_VM_Addr
\par 
\par jc      error           ; carry flag set if error
\par mov     [SegSel], cx    ; segment or selector
\par mov     [Offset], edx   ; address offset
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts a 32-bit ring-0 linear address into an V86 or protected-mode address. This service converts the address for use with the current execution mode of the current virtual machine. Uses ECX, EDX, Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, the
 CX register contains the segment address or selector, and the EDX register contains the offset address. The offset is always zero if the virtual machine is running a protected-mode application. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i LinAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear address to convert. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Limit}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Zero-based segment limit (0 specifies a one-byte segment, 1 is a two-byte segment, and so on). This parameter is used only if the service creates an LDT selector. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the virtual machine is running in V86 mode, the {\i LineAddr}
 parameter must specify a linear address that is within the 1 megabyte V86 address space of the current virtual machine. The service returns a segment:offset pair. 
\par If the virtual machine is running a protected-mode application, the service returns a selector:offset pair. This service creates a new selector in the current virtual machine's LDT if the specified base and limit values do not match a selector the service
 previously allocated. The service returns an error if no LDT is available. 
\par A virtual device must {\i never} free a selector that is returned by this service. For this reason, this service should be used sparingly. 
\par {\b Map_Flat}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 MMGR_SetNULPageAddr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, PhysAddr       ; physical address for system nul page
\par VMMcall MMGR_SetNULPageAddr
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the physical address of the system nul page. Uses Flags. 
\par This service is for the exclusive use of the virtual V86MMGR device. The virtual device calls this service, while processing the {\b Init_Complete} message, to set the address of a known nonexistent page in the system. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PhysAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Physical address of the system nul page. This parameter is the page number for the nul page shifted left by 12 bits. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _GetNulPageHandle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Open_Boot_Log 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Open_Boot_Log
\par xor     eax, eax
\par jnz     log_not_enabled
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Opens the system boot log. Any data written to the system boot log after calling this service is appended to the end of the log. Uses EAX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns zero in EAX if boot logging is enabled, or non-zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Close_Boot_Log}, {\b EnableDisable_Boot_Log}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Register_Win32_Services 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par push    DDB_Offset
\par push    OFFSET32 Service_Table
\par VMMCall _Register_Win32_Services
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Copies the location of the calling VxD's Win32 service-table in the DDB. Uses ESP, flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DDB_Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the offset to the DDB. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Service_Table}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The calling VxD's Win32 service table. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the VxD ID is below the CDEVIDSYS value, it is recorded in the {\b apWin32SvcTbl} table in order to allow fast dispatching. 
\par A bit in the {\b DDB_Flags} member is set ot indicate that this service has been called. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Remove_Exception_Handler 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, Exception          ; points to an Exception_Handler_Struc
\par VMMcall Remove_Exception_Handler
\par 
\par jc      not_removed             ; carry flag set if error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the specified exception handler. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Exception}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an exception handler structure containing information about the exception handler to remove. This exception handler must have been previously installed using the {\b Install_Exception_Handler}
 service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Install_Exception_Handler}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Boot_Flags 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov eax, BootFlags
\par VMMCall Set_Boot_Flags
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the boot-time flags. Virtual devices should have no need to call this service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BootFlags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Boot time flags. Can be one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BOOT_CLEAN (00000001H) \cell \pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \trowd \trleft280 \cellx3160\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BOOT_DOSCLEAN(00000002H) \cell \pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
BOOT_NETCLEAN (00000004H) \cell \pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BOOT_INTERACTIVE (00000008H) \cell 
\pard\plain \sa160\sl-240\slmult1\intbl \f4\fs21 \cell \pard \intbl \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _SetReclaimableItem 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include vmm.h
\par 
\par DWORD _SetReclaimableItem(DWORD enumKey, ReclaimStruc *pReclaim, 
\par     DWORD Flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks as fully reclaimable or restorable, the regions of reclaimable VM memory declared by a previous call to the {\b _AddReclaimableItem}
 service. Uses C calling convention and the EAX, ECX, EDX, and Flags registers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns non-zero in the EAX register if successful; otherwise returns zero in EAX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i enumKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Enumeration key. Set this parameter to zero to begin enumeration. Subsequent calls to this service specify enumeration keys returned by previous calls. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pReclaim}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of {\b ReclaimStruc} structure to copy. The callback in the {\b RS_CallBack} member of the {\b ReclaimStruc }structure is called using the CDECL c
alling and register conventions, and has no defined return value. The reference data for the callback, if any, is not passed separately, since it is already available in the {\b ReclaimStruc}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved; must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the block's contents must be restored prior to {\b System_Exit}, RS_RESTORE must also be specified in the {\b RS_Flags }member. If the {\b RS_Callback}
 member specifies the address of an optional callback function, the function is called immediately after the contents have been restored, prior to {\b System_Exit}. 
\par If the system does not use a fully-reclaimable block (for example, if the block's alignment or size makes it unsuitable), it still calls the caller's callback address, if any, so that any external references to the block can still be restored. 
\par If a block marked reclaimable cannot later be reclaimed, call {\b SetReclaimableItem} with the RS_RECLAIM flag clear. 
\par {\b _AddReclaimableItem}, {\b _EnumReclaimableItem}, {\b ReclaimStruc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Delete_On_Exit_File 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, Filename       ; points to filename to add
\par VMMcall Set_Delete_On_Exit_File
\par 
\par jc      not_added           ; carry flag set on error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Adds the specified filename to the list of files to delete when Windows terminates. Uses All registers except EBX, EBP, and the segment registers. 
\par This service is for the exclusive use of the virtual swap file device; other virtual devices must {\i not} use this service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if the service adds a file to the list, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Filename}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string identifying the file to delete. The string must specify a drive letter and full path. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_System_Exit_Code 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     al, ExitCode        ; exit code to set
\par VMMcall Set_System_Exit_Code
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Sets the exit code value that Windows returns to MS-DOS when Windows terminates. The system copies this value to the AL register when it executes the MS-DOS End Program function (Interrupt 21h Function 4Ch). Uses EDX, Flags. 
\par This service is intended for the exclusive use of the virtual shell device. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ExitCode}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Exit code value. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This exit code is associated only with the exit of the system not the system virtual machine. 
\par In the case of an abnormal termination, the system may set its own exit code value and ignore the value set by this service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 System_Control 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Message    ; system control message
\par mov     ebx, VM         ; VM handle (if needed by message)
\par mov     esi, Param1     ; message-specific parameter
\par mov     edi, Param2     ; message-specific parameter
\par mov     edx, Param3     ; message-specific parameter
\par VMMcall System_Control
\par 
\par jc      error           ; carry flag set if error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sends system control messages to all the virtual devices and, depending on the message, to the VMM. Uses Flags, and possibly other registers depending on the service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 If the Create_VM message is specified and the service is successful, the EBX register contains the new virtual machine handle. 
\par If the Create_Thread message is specified and the service is successful, the EDI register contains the new thread handle. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Message}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 System control message to send. Can be one of the values listed in {\i VMM Messages}, or a private message in the reserved private system control range described above. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of a virtual machine. This parameter is not required by every system control message. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Message-specific parameter. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Message-specific parameter. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param3}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Message-specific parameter. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Although virtual devices may receive many of the system control messages, they may send only the following messages: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Message \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Create_VM}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 May only be sent by the virtual shell device. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Destroy_VM}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 May only be sent by the virtual shell device. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_Device_Focus}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
May be sent by any virtual device. If the device ID is zero, all devices with a focus that can be set, must set their focus to the specified virtual machine. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b End_PM_App}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 May only be sent by the virtual MS-DOS manager. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system never uses message numbers in the range {\b BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL} through {\b END_RESERVED_PRIVATE_SYSTEM_CONTROL}
, which remain free for use by virtual devices. Microsoft has not defined a protocol for virtual devices to reserve regions of the private system control message space and thus avoid accidentally colliding. 
\par Virtual devices must send and reply to messages correctly to prevent erratic system behavior. 
\par This service uses the ECX register, therefore the register cannot be used to pass data through to the virtual device receiving the control message. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_Device_Service 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc 
\par 
\par GetDeviceServiceOrdinal eax, Service
\par mov esi, HookProc
\par VMMCall Unhook_Device_Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Unhooks a device service that was previously hooked with the {\b Hook_Device_Service }service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if successful; otherwise sets the carry flag because of one of the following errors: 

\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 The service number is invalid. 
\par The hook procedure could not be found in the chain. 
\par A non-HookProc hook existed in the chain. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ServiceOrdinal}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The highword is the VxD ID and the low word is the service number. If the VxD ID is UNDEFINED_DEVICE_ID, then the EDI register should contain the address of the eight character space-padded VxDName. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Service}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the service being unhooked. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i HookProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Hook procedure to remove from the list. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 In order for {\b Hook_Device_Service} to succeed, the hook to be unhooked and all hooks that were made after the specified hook must have been declared as Hook_Proc's using the {\b BeginProc}
 macro. This macro is provided to correctly generate the procedure header necessary for creating a hook chain that can be processed quickly and still allows hooks to be removed from the chain. 
\par {\b BeginProc}, {\b Hook_Device_Service}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMM_Add_DDB 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, OFFSET32 ddb
\par VMMcall VMM_Add_DDB
\par jc      DDB_Already_Exists;
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Adds a {\b Vxd_Desc_Block} structure (DDB) to the appropriate location in the device list (the locations are based on the inititialization order). 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Clears the carry flag if the DDB was added to the internal list; the carry flag is set if a duplicate entry already exists. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ddb}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A {\b Vxd_Desc_Block} structure that contains the driver version numbers, the addresses of various required procedures, and so on. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Virtual devices should call this service with extreme caution. DDBs added in this manner are treated by the virtual machine manager as full-fledged VxDs. If you want to load a VxD, you would be much better off using the VxD loader services than trying to 
manipulate the DDB list directly. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMM_GetDDBList 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall VMM_GetDDBList
\par mov     [DDBList], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the address of the DDB list. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the DDB list address in EAX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Virtual devices can walk the list of DDBs by following the DDB_Next field in the DDB. The end of the list is marked with a DDB_Next field equal to zero. Note that the DDB list can change as a result of dynamically-loaded VxDs, so virtual devices should no
t attempt to retain the value returned by this service for an extended period of time. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMM_GetVxDLocationList 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall VMM_GetVxDLocationList
\par jz      ErrorHandler
\par mov     [TableAddress], eax
\par mov     [VxDCount], edx
\par mov     [TableSize], ecx
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the address of the VxD location list in EAX, returns the count of VxDs in EDX, and returns the list size (in bytes) in ECX. Uses EAX, ECX, and EDX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the address of the VxD if the function succeeds; otherwise, sets the zero flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The VxD location list is a packed array of variable-length {\b Device_Location_List} structures. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMM_Remove_DDB 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, OFFSET32 ddb
\par VMMcall VMM_Remove_DDB
\par jc      DDB_Not_Found
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes a {\b Vxd_Desc_Block} structure (DDB) from the device list. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the DDB was removed; the carry flag is set if the DDB was not found. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ddb}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A {\b Vxd_Desc_Block} structure that contains the driver version numbers, the addresses of required procedures, and so on. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices should call this service with extreme caution. DDBs removed in this manner are removed from the system w
ithout being given any opportunity to clean up. If you want to unload a VxD, you would be much better off using the VxD loader services than trying to manipulate the DDB list directly. Removing a DDB at a bad time destabilizes the system. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMMAddImportModuleName 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 Mod_Lngth_And_Name
\par VMMcall VMMAddImportModuleName
\par mov     [Internal_Index], eax;
\par jc      Name_Already_Present
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Adds the specified import-module name to an internal table. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the internal index for the module name in EAX. Sets the carry flag if the module name is already present; otherwise, clears the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Mod_Lngth_And_Name}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The module-name string. The first byte of this string specifies the number of characters in the string; the remaining bytes contain the actual characters. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The first byte of the module-name string must specify the length of the string in bytes. The remaining bytes contain the ASCII characters that compose the string. 
\par This service is reserved for the VxDLDR device. Other virtual devices should not use this service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Sprintf 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Sprintf, <pOutBuf, pFormat, Param1, Param2, ...>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Formats a string in a manner analogous to the C procedure. This service uses the C calling convention. Uses EAX, ECX, EDX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the number of bytes written to the output buffer, not including the terminating null. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pOutBuf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a buffer that receives the formatted string. There is no limit checking performed on the buffer; it must be large enough to handle the formatted output. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pFormat}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an ASCIIZ format string. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1}, {\i Param2}, {\i ...}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameters. It is an error to pass too few parameters to satisfy the format string. String insertions may not exceed 255 bytes in length. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Structures 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 ReclaimStruc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 ReclaimStruc   STRUC
\par     RS_Linear   DD ?
\par     RS_Bytes DD ?
\par     RS_CallBack DD ?
\par     RS_RefData  DD ?
\par     RS_HookTable   DD ?
\par     RS_Flags DD ?
\par ReclaimStruc   ENDS
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Contains information about a region of VM memory. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b RS_Linear}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Low (ie, less than 1meg+64K) address of region. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b RS_Bytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size of region in bytes. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b RS_CallBack}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Function to call prior to System_Exit, NULL if none. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b RS_RefData }
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data passed to callback, if any. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b RS_HookTable}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of Reclaim_Hook_Table as defined in int2fapi.h, NULL if none. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b RS_Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 May be any combination of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 RS_RECLAIM (00000001H) \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 RS_RESTORE (00000002H) \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
RS_DOSARENA (00000004H) \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _AddReclaimableItem}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 184}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 13 Nested Execution{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 183}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 13
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Nested Execution 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Nested Execution 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Terms 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 client state \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The state of the registers in a virtual machine. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 nested execution \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The execution of code in a virtual machine at the direction of a virtual device. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 nested execution block \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A block of code in virtual device that is delimited by calls to {\b Begin_Nest_Exec} (or {\b Begin_Nest_V86_Exec}) and {\b End_Nest_Exec}. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Nested Execution 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Often, a virtual de
vice (VxD) handles an interrupt or fault by calling code in a virtual machine (VM). The code might be an MS-DOS routine or a BIOS interrupt handler, for example. When the virtual device calls into the virtual machine, it must do so within the context of a
 nested execution block, which is a block of code delimited by calls to {\b Begin_Nest_Exec} (or {\b Begin_Nest_V86_Exec}) and {\b End_Nest_Exec}. 
\par {\b Begin_Nest_Exec} changes the execution mode of the virtual machine to the mode of the application running in the VM. For example, if the virtual machine is running a protected-mode program but happens to be in V86 mode at the moment, {\b 
Begin_Nest_Exec} changes the virtual machine to protected-mode. {\b Begin_Nest_Exec} is typically used to call callback procedures registered by an application. 
\par {\b Begin_Nest_V86_Exec} is like {\b Begin_Nest_Exec}, except that it forces the mode of the virtual machine to V86-mode, even if the program running in the virtual machine is a protected-mode program. {\b Begin_Nest_V86_Exec}
 is typically used to call the BIOS, a TSR, or other V86-mode code. 
\par {\b End_Nest_Exec} restores the virtual machine to its original mode, regardless of how nested execution was entered. 
\par The code in the virtual machine can modify the virtual machines registers. It is rarely desirable that changes to the registers resulting from nested execution be propagated back to the virtual machine when nested execution is complete. To be able to rest
ore the state of the virtual machine after the code executes, a virtual device must save the state of the virtual machine's registers before entering a nested execution block. To save the registers, a virtual device can use the {\b Save_Client_State}
 service, which stores the registers in a buffer, or the {\b Push_Client_State} macro, which pushes the registers onto the virtual device's stack. After completing the nested execution block, the virtual device can restore the registers by calling the {
\b Restore_Client_State} service or using the {\b Pop_Client_State} macro. 
\par Once inside a nested execution block, virtual device uses simulation services, followed by the {\b Resume_Exec} service to call into a virtual machine. Alternatively, a virtual machine can use the {\b Exec_Int}
 service, which combines the functionality of {\b Simulate_Int} and {\b Resume_Exec}. Multiple calls to {\b Resume_Exec}
 can occur while inside a single nested execution block; you don't need to exit and re-enter nested execution if you need to simulate multiple operations. 
\par For the curious: So how does your virtual device manage to regain control after a {\b Resume_Exec}? When {\b Begin_Nest_Exec} or {\b Begin_Nest_V86_Exec}
 is called, the virtual machine manager changes the mode of the virtual machine, then points the client CS:EIP registers at a pre-allocated breakpoint address. When far calls or interrupts are simulated, this breakpoint gets pushed onto the client's stack
 as the return address. Then when the simulated call or interrupt returns, it returns to this breakpoint address, at which point the virtual machine manager regains control, does some bookkeeping, and returns control to your virtual device. When {\b 
End_Nest_Exec}
 is called, the mode of the virtual machine is restored, and the original CS:EIP is replaced. This information is provided to aid in understanding nested execution; Microsoft reserves the right to alter the details of the implementation in future versions
 of Windows, so you shouldn't rely on it. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Examples 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Nested execution suffers from being relatively important yet poorly-u
nderstood. To help close the gap, various examples illustrating common scenarios are given here. All of the examples assume that EBX contains the handle of the current virtual machine and that EBP contains a pointer to the client registers. 
\par The first example is the prototypical case, where a virtual device wishes to obtain information from MS-DOS. Note that in general, this is a dangerous thing to do without first ensuring that the call will not result in MS-DOS being re-entered. 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Push_Client_State             ; Save all registers
\par VMMcall Begin_Nest_V86_Exec\tab    ; Enter nested execution in V86-mode
\par mov     [ebp.Client_AH], 30h  ; 30h = get MS-DOS version #
\par mov     eax, 21h              \tab ; Execute an Int 21h in the
\par VMMcall Exec_Int              \tab ; current VM to call MS-DOS
\par mov     ax, [ebp.Client_AX]   ; Load MS-DOS version into AX register
\par VMMcall End_Nest_Exec         ; end of nested exec calls
\par Pop_Client_State              ; Restore all registers when done
\par                               ; At this point, AX = MS-DOS version
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notice that the {\b Exec_Int} service was used here to simulate and execute the interrupt. It is equivalent to calling {\b Simulate_Int} followed by {\b Resume_Exec}. 
\par For software interrupts, an alternative method is to execute the interrupt "directly" from ring zero: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ah, 30h  ; 30h = get MS-DOS version #
\par VxD_Int 21h      ; Execute the Int 21h directly
\par                  ; At this point, AX = MS-DOS version
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This mechanism's main benefit is convenience. The drawback is that {\i all}
 changes to registers (other than segment registers) made by the software interrupt are propagated back into ring 0. This is dangerous because the software interrupt might modify a register you expected to be preserved. This is particularly true of softwa
re interrupts 21h and 13h, which are often hooked by TSRs or device drivers which do not preserve all the registers properly. Specifically, we've found TSRs and even BIOSes which destroy the high words of extended registers across these calls. 
\par Furthermore, the {\b VxD_Int} method cannot be used to call services which return information in segment registers, because the ring zero segment registers SS, DS and ES must always remain equal to flat selector. 
\par Another drawback to the {\b VxD_Int}
 method is that it is not always available. For example, translation services for Int 21h calls is not ready until DOSMGR and IFSMGR complete their initialization; similar remarks apply to Int 13h calls and provided by BIOSXLAT and INT13. Attempting to {
\b VxD_Int} an MS-DOS call before the translation services are ready will result in very random behavior. Other services might not even be translated at all. (For example, you cannot use {\b VxD_Int}
 to call Int 33h because nobody provides translation services for that software interrupt.) 
\par The moral of the story is that you should exercise caution when using {\b VxD_Int}. 
\par Sometimes software interrupts aren't enough. You might find it necessary to call a far procedure in V86-mode, possibly with arguments passed on the s
tack or in registers. Suppose that you need to call a procedure in V86-mode (for example, a TSR or a device driver) with a word parameter on the stack and with a function code in the DX register. The procedure returns with a 'retf' instruction, relying on
 the caller to clean the stack on return. 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Push_Client_State            ; Save client state on stack
\par VMMCall Begin_Nest_V86_Exec  ; Prepare to execute V86-mode code
\par mov     ax, wStackParameter  ; the parameter that goes on the stack
\par VMMCall Simulate_Push        ; Push it onto the client stack
\par mov     [ebp].Client_DX, 0   ; Function code in client DX
\par mov     cx, segV86Proc       ; CX = segment of the V86-mode procedure
\par movzx   edx, word ptr ofsV86Proc ; EDX = offset of the V86-mode 
\par                                  ;   procedure (hiword must be 0)
\par VMMCall Simulate_Far_Call    ; Make it look like client did a "call far" 
\par                              ;   instruction
\par VMMCall Resume_Exec          ; Run the procedure until it returns
\par VMMCall Simulate_Pop         ; Pop the parameter off the stack
\par                              ; <<Inspect the return value here>>
\par VMMCall End_Nest_Exec        ; Finished with nested execution
\par Pop_Client_State             ; Restore client state from stack
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Note that there is no equivalent to {\b VxD_Int} for far procedures. You have to use nested execution explicitly. 
\par A final example is a callback procedure registered by an application. Suppose that an application registered an address that it expects to be called back asynchronously based on s
ome condition. You can call the procedure back with the following mechanism, assuming that the procedure uses the Pascal calling convention and takes two arguments: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Push_Client_State         ; Save client state on stack
\par VMMCall Begin_Nest _Exec  ; Prepare to execute application-mode code
\par mov     ax, wParam1       ; Pascal calling convention says
\par VMMCall Simulate_Push     ; you push arguments from left to right
\par mov     ax, wParam2
\par VMMCall Simulate_Push
\par mov     cx, segAppProc    ; CX = segment of the procedure to call
\par mov     edx, word ptr ofsAppProc  ; EDX = offset of the procedure to 
\par                                   ;   call (hiword must be 0 if V86 or 
\par                                   ;   16-bit PM)
\par VMMCall Simulate_Far_Call ; Make it look like client did a "call 
\par                           ;   far" instruction
\par VMMCall Resume_Exec       ; Run the procedure until it returns
\par VMMCall End_Nest_Exec     ; Finished with nested execution
\par Pop_Client_State          ; Restore client state from stack
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Be aware that this mechanism does not work for Win32 applications. Note also that this callback is made completely asynchronously with respect to the application. At a minimum, you should wait until the client interrupt flag is clear. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Nest_Exec 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Begin_Nest_Exec
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Starts a nested execution block. This service is used in conjunction with the {\b End_Nest_Exec} service to create a nested execution block in which a virtual device may call {\b Exec_Int,} {\b Resume_Exec}
, and the various simulation services. Virtual devices use these services to call software in the virtual machine. Uses {\b Client_CS}, {\b Client_IP}, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a break point in Client_CS and Client_IP that is used by nested execution services. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 While in a nested execution block, a virtual device may call the {\b Exec_Int} and {\b Resume_Exec} services any number of times. 
\par If one of these calls changes the virtual machine registers, these changes are also made to the client state. Before creating the nested execution block, a virtual device should save the client state by using the {\b Save_Client_State}
 service. After ending the nested execution block, a virtual device should restore the client state by using the {\b Restore_Client_State} service. 
\par This service forces the virtual machine into protected-mode execution if there is a protected-mode application running in the current virtual machine. Otherwise, the virtual machine remains in V86 mode. The {\b End_Nest_Exec}
 service restores the virtual machine to its mode prior to the call to {\b Begin_Nest_Exec}. 
\par If the execution mode changes to protected mode, this service automatically switches the virtual machine to the locked protected-mode stack and {\b End_Nest_Exec}
 switches it back. This allows most devices to change execution modes without worrying about demand paging issues. 
\par {\b Begin_Nest_V86_Exec}, {\b End_Nest_Exec}, {\b Exec_Int}, {\b Restore_Client_State}, {\b Resume_Exec}, {\b Save_Client_State}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Nest_V86_Exec 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Begin_Nest_V86_Exec
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the current virtual machine to V86 mode and prepares the virtual machine for nested execution. This service is used in conjunction with the {\b End_Nest_Exec}
 service to create a nested execution block in which a virtual device may call the {\b Exec_Int}, {\b Resume_Exec}, and various simulation services. Virtual devices use these services to call software in the virtual machine. Uses {\b Client_CS}, {\b 
Client_IP}, and Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a break point in Client_CS and Client_IP that is used by nested execution services. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When in a nested execution block, a virtual device may call the {\b Exec_Int} and {\b Resume_Exec} services any number of times. 
\par This service should only be used by virtual devices that convert protected-mode calls into V86 calls. For example, the virtual MS-DOS manager uses this service to map calls to MS-DOS functions (Interrupt 21h) issued by protected-mode programs into calls t
o MS-DOS functions in V86 mode. 
\par This service should be used by virtual devices that need to be sure that they are calling V86-mode code. A typical usage is translating a protected-mode call into a V86-mode call. After the parameters are translated, {\b Begin_Nest_V86_Exec}
 is used to ensure that the subsequent simulation is into V86-mode. 
\par This service saves the current execution mode of the virtual machine, and {\b End_Nest_Exec} restores the mode. 
\par {\b Begin_Nest_Exec}, {\b End_Nest_Exec}, {\b Exec_Int}, {\b Resume_Exec}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_V86_Serialization 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, flags
\par VMMcall Begin_V86_Serialization
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Serializes access to V86 mode among the threads in the system VM by using a mutex called the "V86 mutex". Because the mutex is taken automatically when {\b Begin_Nest_V86_Exec}
 is called in the system VM, a VxD typically does not directly call this service. A VxD might call this service when it needs to perform a nested execution operation into protected mode, and the operation will be reflected into V86 mode at the end of the 
protected mode chain. Using this service would prevent the VxD's thread from potentially getting blocked at the end of the protected mode chain. Uses Flags. 
\par  No return value. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be a combination of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Svc_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service events (and simulated interrupts) in the VM if the thread blocks for the critical section. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Block_Svc_If_Ints_Locked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Service events (and simulated interrupts) in the VM if the thread blocks for the critical section and the VMStat_V86IntsLocked flag is set. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Enable_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service interrupt events in the VM even if the VM does not currently have interrupts enabled (force interrupts to be enabled). This flag is relevant only if either Block_Svc_Ints or Block_Svc_If_Ints_Locked is set. \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Thread_Idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
If the thread blocks for the critical section this thread should be considered idle. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
There is a hierarchy between the V86 mutex and the critical section mutex. The V86 mutex can be taken in the system VM when the critical section is owned by another VM, but in the system VM the critical section can only be owned if the V86 mut
ex is already owned. Calling {\b Begin_Critical_Section} in a thread in the system VM takes both mutexes. 
\par Each call to {\b Begin_V86_Serialization} should have a corresponding call to {\b End_V86_Serialization}. 
\par {\b Begin_Critical_Section}, {\b Begin_Nest_V86_Exec}, {\b End_V86_Serialization}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Nest_Exec 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall End_Nest_Exec
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Ends a nested execution block. This service is used in conjunction with the {\b Begin_Nest_Exec} or {\b Begin_Nest_V86_Exec} service to create a nested execution block in which virtual devices may call the {\b 
Exec_Int} and {\b Resume_Exec} services. Uses {\b Client_CS}, {\b Client_IP}, Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns, in Client_CS and Client_IP, the original values saved when the nested execution block was created. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device must end all nested execution blocks before returning to the virtual machine manager. 
\par This service restores the execution mode to the mode prior to the start of the nested execution block. It also restores the {\b Client_CS} and {\b Client_IP}
 registers, but does not restore any other client registers. A virtual device should save and restore other registers using the {\b Save_Client_State} and {\b Restore_Client_State} macros. 
\par {\b Begin_Nest_Exec}, {\b Begin_Nest_V86_Exec}, {\b Exec_Int}, {\b Restore_Client_State}, {\b Resume_Exec}, {\b Save_Client_State}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_V86_Serialization 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall End_V86_Serialization
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Decrements the usage count of the V86 mutex. When the count reaches zero, the mutex is no longer owned by the current system VM thread. (For more information, see the description of the {\b 
Begin_V86_Serialization} service.) Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_V86_Serialization}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Exec_Int 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt
\par VMMcall Exec_Int
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates the specified interrupt, and resumes execution of the virtual machine. This service may only be called in a nested execution block created using the {\b Begin_Nest_Exec} or {\b Begin_Nest_V86_Exec}
 service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to simulate. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When in a nested execution block, this service can be called any number of times. 
\par This service is comparable to combining the {\b Simulate_Int} and {\b Resume_Exec} services. 
\par {\b Begin_Nest_Exec}, {\b Begin_Nest_V86_Exec}, {\b Resume_Exec}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Exec_VxD_Int 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par push    dword ptr Interrupt
\par VMMcall Exec_VxD_Int
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Executes the specified software interrupt. Virtual devices use this service to call MS-DOS or BIOS functions outside the context of a nested execution block. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns values in one or more registers, depending on the function of the specified interrupt. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to execute. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Before calling this service, a virtual device must set registers to values that are appropriate for the specified software interrupt. This service supports all MS-DOS and BIOS functions that are supported in protected-mode programs. 
\par This service does not change the client registers and flags, so there is no need for the virtual device to save and restore the client register structure. This service also pops the interrupt number from the stack. 
\par The following examples calls the MS-DOS function Get Version (Interrupt 21h, Function 30h): 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ax, 3000h
\par push    dword ptr 21h
\par VMMcall Exec_VxD_Int
\par mov     [Major], al     ; major MS-DOS version
\par mov     [Minor], ah     ; minor MS-DOS version
\par 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Nest_Exec_Status 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall Get_Nest_Exec_Status
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves information about whether the current thread is in nested ring 3 execution. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the Z-flag set if the thread is not in nested execution. Otherwise, returns the following: 

\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Original ring 3 EIP \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Original ring 3 CS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ESI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Original ring 3 SS:SP \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Ring 0 stack pointer returned from {\b Resume_Exec }or {\b Exec_Int}
, if ; waiting for completion of ring 3 code. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There should be no need for a virtual device to call this service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Restore_Client_State 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, Buffer
\par VMMcall Restore_Client_State
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Restores a virtual machine execution state that was saved using the {\b Save_Client_State} service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Buffer}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the buffer containing the client state previously saved using the {\b Save_Client_State} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can have the following side effects: 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Changes the execution mode if the state being restored is in a different execution mode from the cu
rrent one. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
May change the state of the current virtual machine's interrupt flag and cause the system to call event callback procedures that were previously scheduled using the Call_When_VM_Ints_Enabled and Call_Priority_VM_Event services. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is typically not called directly; a virtual device typically uses the {\b Pop_Client_State} macro which, in turn, calls this service. 
\par {\b Call_Priority_VM_Event}, {\b Save_Client_State}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Resume_Exec 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Resume_Exec
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Executes the current virtual machine immediately. This service may only be called in a nested execution block created using the {\b Begin_Nest_Exec} or {\b Begin_Nest_V86_Exec} service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be used any number of times in a nested execution block. 
\par This service returns when the virtual machine returns to the same point it was at when {\b Begin_Nest_Exec} was called. 
\par {\b Begin_Nest_Exec}, {\b Begin_Nest_V86_Exec}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Save_Client_State 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, Buffer
\par VMMcall Save_Client_State
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Copies the contents of the current virtual machine's {\b Client_Reg_Struc} structure to the specified buffer. The saved state can later be restored by calling the {\b Restore_Client_State} service. Uses Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Buffer}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the buffer to receive the client state. The buffer must have the same size as a {\b Client_Reg_Struc} structure. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices typically use this service to save client registers prior to creating a nested execution block with the {\b Begin_Nest_Exec} or {\b Begin_Nest_V86_Exec} service. 
\par Never attempt to restore the client state by directly copying saved register values back to the {\b Client_Reg_Struc} structure; this will almost certainly cause the virtual machine manager to crash. 
\par This service is typically not called directly; a virtual device typically uses the {\b Push_Client_State} macro which, in turn, calls this service. 
\par {\b Begin_Nest_Exec}, {\b Begin_Nest_V86_Exec}, {\b Client_Reg_Struc}, {\b Restore_Client_State}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 198}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 14 Page Mapping and Address Spaces{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 199}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 14
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Page Mapping and Address Spaces 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Page Mapping and Address Spaces 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Pages and Page Translation 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The 32-bit linear address space used by the Intel 80386 and later microprocessors is divided into 4 kilobyte units called pages. Each page can be assigned specific permissions, and can be mapped to any 4K section of physical memory. The base physical addr
ess of a page is its {\i page frame address}. A page can also be marked {\i not present,} in which case it does not map to any physical memory. 
\par Page mapping is possible because of {\i page translation,}
 the mechanism by which the CPU translates linear addresses to physical addresses. A linear address can be viewed as a combination of two values: a 20-bit page number, and a 12-bit offset (4K = 2 bytes). The CPU uses the page number to locate a page descr
iptor, which contains a page frame address and other information. Adding the offset to the page frame 
address yields a physical address. A page that is marked not present does not map to any physical address. Attempting to access such a page triggers a page fault. Typically, a page is marked not present if has been temporarily swapped out to disk or if no
 physical storage has been allocated for the page. In addition, virtual devices may mark a hooked page as not present in order to trigger a page fault every time the page is accessed. The system does something similar for instanced pages. Page descriptors
 are organized into page tables. By creating more than one set of page tables, the system can define more than one address space, each with a unique mapping of pages to physical storage. {\i Virtual devices should not manipulate page tables directly.}
 (Doing so is virtually guaranteed to result in incompatibilities with future versions of Windows.) However, a virtual device can use VMM services to get information about the current address space and to change the way pages are mapped to physical storag
e. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Arenas 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system divides the linear address space into four areas, called {\i arenas,} each of which is managed differently. 
\par The DOS arena spans linear addresses in the range MINDOSLADDR through MAXDOSLADDR, and is used for virtual machines (VMs). The DOS arena is itself divided into several areas. For more information about the DOS arena, see {\i 
V86 Address Space Mapping and Allocation}. 
\par The private arena spans linear addresses in the range MINPRIVATELADDR through MAXPRIVATELADDR. This arena is used for code and data th
at is private to a Win32 process. The mapping of pages in this arena to physical storage depends on the current memory context, as does which pages are reserved. 
\par The shared arena spans linear addresses in the range MINSHAREDLADDR through MAXSHAREDLADDR. This arena is used for ring-3 shared code and data, such as 16-bit Windows applications and DLLs, DPMI memory, and 32-bit system DLLs. The mapping of pages in this
 arena does not depend on the current VM or memory context. 
\par The system arena spans linear addresses in the range MINSYSTEMLADDR through MAXSYSTEMLADDR. This arena is used for code and data for the VMM and virtual devices. 
\par The last four megabytes of the linear address space is permanently invalid and is not part of any arena. Because zero is a valid address, you should use an address in this permanently invalid region to denote an invalid pointer. To be extra safe, you can 
use the value 0xFFFE0000, which lies right in the middle of the invalid region. 
\par See also {\b _GetNulPageHandle}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Memory Contexts 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The system uses memory contexts to create a private linear address space for each Win32 application. The current memory context determines the mapping of pages in the private arena, the linear address range from MINPRIVATELADDR through MAXPRIVATELADDR. 

\par Most memory context services are for the exclusive use of the system. Virtual devices should only use the {\b _GetCurrentContext} service. 
\par To access data in the private arena from a different memory context or at interrupt time, map the data to globally addressable pages by using the {\b _LinPageLock} service with the PAGEMAPGLOBAL flag. Do {\i not}
 change the current context for this purpose. 
\par See also {\b _GetCurrentContext}, {\b _LinPageLock}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Page Locking and Mapping 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device cannot access swappable pages while processing hardware interrupts because doing so may trigger a page fault. A virtual device can avoid page faults by committing pages as fixed,
 or by temporarily locking pages when necessary \emdash  for example, during a device input or output operation. Locking a page forces it to remain physically present at a fixed address until it is unlocked. 
\par You can lock a range of pages by using the {\b _LinPageLock} service. The pages remain locked until they are unlocked using the {\b _LinPageUnLock}
 service. The system maintains a lock count for each page. Thus, you can lock a page more than once. You must unlock a page once for each time it is locked unless you specif
y the PL_TOTALUNLOCK flag to bring the lock count to zero. (But don't use the PL_TOTALUNLOCK flag. It is mentioned here only for completeness.) 
\par You can specify the PAGELOCKEDIFDP flag with the {\b _LinPageLock}
 service, in which case the pages are locked only if the pager uses MS-DOS or BIOS functions to perform file operations. You should use this flag for pages that need to be touched while a virtual device owns the critical section. Because MS-DOS is not ree
ntrant, it cannot be called while the critical section is owned. For the same reason, VxD_PAGEABLE_CODE_SEG and VxD_PAGEABLE_DATA_SEG segments are automatically locked when MS-DOS is used for paging. 
\par \pard\plain \s23\li30\ri30\sl-80\slmult1\keepn\brdrb\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Warning 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 You cannot call memory manager services while any virtual machine holds the critical section, unless you ensure that MS-DOS is not used for paging. For more information about critical sections, see {\i 
Synchronization}. 
\par \pard\plain \s20\li30\ri30\sa40\sl-140\slmult1\brdrt\brdrs\brdrw15\brsp20 \f4\fs12\cf8 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If a virtual device must access a range of pages in the private arena regardless of the current memory context, it must map the pages to a range linear addresses outside the private arena. To do so, use the {\b 
_LinPageLock} service with the PAGEMAPGLOBAL flag. When you unlock the pages using the {\b _LinPageUnlock}
 service, you must specify the same flag to undo the mapping. You must also pass the global alias as the page to unlock rather than the original private page. Failure to observe either of these two rules will leak critical system memory and eventually cra
sh the machine. 
\par You can use the {\b _PageLock} and {\b _PageUnLock} services to lock a range of pages. However, these services are more difficult to use than the {\b _LinPageLock} and {\b _LinPageUnLock}
 services, and offer no performance advantage. Also, you cannot map pages into shared memory by using the {\b _PageLock} service. The {\b _PageLock} and {\b _PageUnLock} services exist primarily for compatibility with Windows 3.1 virtual devices. 
\par Do not attempt to lock uncommitted pages. You can verify that all pages in a given range are committed by using the {\b _PageCheckLinRange} service. Locking pages that were committed as
 fixed has no effect, but consumes just as much time as locking swappable pages. 
\par In addition to the services described here, the VMM provides services for mapping pages into VMs. For more information about such services, see {\i V86 Address Space Mapping and Allocation}
. For information about services that convert selector:offset addresses to linear addresses, see {\i Selector Management}. 
\par See also {\b _LinPageLock}, {\b _LinPageUnLock}, {\b _PageLock}, {\b _PageUnLock}, {\b _PageCheckLinRange}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Miscellaneous Page Management Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device must not modify page tables directly. However, a virtual device can retrieve a copy of a page table to analyze. To do so, use the {\b _CopyPageTable}
 service. To retrieve high-level information about a range of pages, use the {\b _PageQuery} function. 
\par Each committed page has a specific set of permissions, which determine whether the page can be written to and whether it is accessible in user mode (ring 3). To change the permissions for a range of pages, use the {\b _PageModifyPermissions} service. 

\par Because zero is a valid address, you should use an address in the permanently invalid region of linear address space to denote an invalid pointer. 
\par See also {\b _CopyPageTable}, {\b _GetNulPageHandle}, {\b _PageModifyPermissions}, {\b _PageQuery}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Obsolete Memory Management Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following services are obsolete. If called, they immediately return zero in the EAX register: 
\par {\b _GetGlblRng0V86IntBase _MapFreePhysReg _SetFreePhysRegCalBk _UnmapFreePhysReg _XchgFreePhysReg}
\par In addition, the {\b _GetSysPageCount} and {\b _GetVMPgCount} services do not return meaningful values, and the {\b _GetSetPageOutCount} and {\b _PageOutDirtyPages} services have been deleted. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Memory Context Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Memory context services control the mapping of pages in the private arena. With the exception of the {\b _GetCurrentContext}
 service, these services are for the exclusive use of the VMM, and are documented here only to satisfy the reader's curiosity. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _ContextCreate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par PVOID EXTERNAL _ContextCreate(void);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates a new memory context. The tasking and scheduling component uses this service to create a private linear address space for a new Win32 application. Do not call this service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the new context if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The private linear address space corresponds to linear addresses in the range MINPRIVATELADR through MAXPRIVATELADDR. A memory context is destroyed using the {\b ContextDestroy} service. 
\par {\b _ContextDestroy}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _ContextDestroy 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _ContextDestroy(PCD hcd);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Destroys a memory context created by the _{\b ContextCreate} service. Do not call this service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hcd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Zero to free the private memory in the current context, or the handle of the dying context to perform final clean-up. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 To destroy a memory context, this service must be called twice. The first call must be from within the dying memory context, and the {\i hcd} parameter m
ust be zero. The second call must be from a different context, and the {\i hcd} parameter must be the handle of the dying context. 
\par {\b _ContextCreate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _ContextSwitch 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par PVOID EXTERNAL _ContextSwitch(PVOID hcd);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Changes the current memory context. The current memory context determines the mapping of pages in the private arena. Do not call this service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the outgoing context. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hcd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Context handle returned by the {\b _ContextCreate} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _ContextCreate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetCurrentContext 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par PVOID EXTERNAL _GetCurrentContext(void);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines the current memory context. Do not call this service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the current context. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _ContextSwitch}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageAttach 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageAttach(ULONG page, PCD hcontextsrc, ULONG npages);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Maps a range of linear pages in the current memory context to the same physical storage that those pages are mapped to in a specified context (the source context). Do not call this service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page to map, and the number of pages to map. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hcontextsrc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the source memory context. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service should only be called by the Win32 program loader, which uses it to map the pages containing a program image from one context into another. 
\par The pages in the source context must be committed, and the pages in the current context must be reserved but not committed. After {\b _PageAttach} is called, the pages in the current context can be regarded as committed pages \emdash 
 for example, they can be decommitted, freed, or mapped into another memory context. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Page Locking and Mapping Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Page locking and mapping services are used to make a range of swappable pages physically present, or to make a range of private pages available in any memory context. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _LinPageLock 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _LinPageLock, <page, npages, flags>
\par or      eax, eax                ; nonzero if locked, zero if error
\par jz      not_locked
\par 
\par 
\par #include <vmm.h>
\par 
\par ULONG EXTERNAL _LinPageLock(ULONG page, ULONG npages, ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Locks one or more pages starting at the specified linear page number. Locking a pages forces it to become physically present and to remain so until it is unlocked. This service is similar to the {\b _PageLock}
 service. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns a nonzero value if successful, zero otherwise. If the PAGEMAPGLOBAL flag is specified, the successful return value is the base linear address of the new linear mapping. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page in the range, and the number of pages in the range. All of the pages in the range must be committed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Zero or one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGELOCKEDIFDP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Lock the pages only if the virtual pageswap device uses MS-DOS or BIOS functions to write pages to the hardware. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 PAGEMAPGLOBAL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Map a global linear address to the locked range so that the memory can be accessed out of the current context. Cannot be specified with PAGELOCKEDIFDP. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEMARKDIRTY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Mark the pages as if they have been written to. This flag is intended for a VxD that needs to modify the pages, but the CPU doesn't recognize the modifications. For example, the CPU may not recognize DMA write ope
rations, or write operations using the address returned when the PAGEMAPGLOBAL flag is used. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A page can be locked more than once, in which case it must be unlocked once for each time it is locked. Unlock pages using the {\b _LinPageUnLock} service. 
\par {\b _LinMapIntoV86}, {\b _LinPageUnLock}, {\b _PageLock}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _LinPageUnLock 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _LinPageUnLock, <page, npages, flags>
\par or      eax, eax         ; nonzero if successful, zero otherwise
\par jz      not_unlocked
\par 
\par 
\par #include <vmm.h>
\par 
\par ULONG EXTERNAL _LinPageUnLock(ULONG page, ULONG npages, ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Unlocks one or more pages starting at the specified linear page number. This service is similar to the {\b _PageUnLock} service. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Linear page number of the first page to unlock, and the number of pages to unlock. All of the pages in the range must be committed. If freeing a global alias, these must describe the location and size of the alias and not the originally locked address. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Zero or one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGELOCKEDIFDP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Unlock the pages only if the virtual pageswap device uses MS-DOS or BIOS functions to write pages to the hardware. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 PL_TOTALUNLOCK \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Bring lock count to zero. This flag should only be used by the {\b SetResetV86Pageable} service. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEMAPGLOBAL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Deletes a linear mapping created by a previous call to the 
{\b _LinPageLock} service. If this flag is specified, the value of the {\i page} parameter must be the linear address that was returned by {\b _LinPageLock}. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _LinPageLock}, {\b _PageUnLock}, {\b _SetResetV86Pageable}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageCheckLinRange 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _PageCheckLinRange, <page, nPages, flags>
\par 
\par mov     [Pages], eax    ; number of committed pages at start of range
\par 
\par 
\par #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageCheckLinRange (ULONG page, ULONG npages, 
\par     ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether all pages in the specified range of linear addresses are committed. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the actual number of contiguous committed pages in the EAX register. In particular, the return value is zero if the first page in the specified range is not committed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Page number of the first page to check. A page number is a ring-0 linear address shifted right by 12 bits. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to check. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices typically use this service to validate an address range before specifying the range in a call to the {\b _LinPageLock} or {\b _LinMapIntoV86} service. 
\par {\b _LinMapIntoV86}, {\b _LinPageLock}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageLock 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _PageLock, <hMem, nPages, PageOff, flags>
\par 
\par or      eax, eax        ; nonzero if locked, zero if error
\par jz      not_locked
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Locks one or more pages in the specified memory block. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hMem}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle (base linear address) of the memory block that contains the pages to lock. This value have been previously returned by the {\b _PageAllocate}, {\b _PageReAllocate,} or {\b _PageReserve} service. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to lock. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PageOff}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset in pages from the start of the memory block to the first page to lock. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or the PAGELOCKEDIFDP value. All other values are reserved. 
\par If the PAGELOCKEDIFDP value is specified, pages are locked only if the virtual swap device uses MS-DOS or BIOS functions to write pages to the hardware. The PAGELOCKEDIFDP value cannot be used until after the {\b Init_Complete}
 message has been processed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b _LinPageLock} service is the preferred method of locking pages. 
\par This service returns an error if the sum of the {\i PageOff} and {\i nPages} parameters is greater than the number of pages in the memory block. 
\par This service has no effect on memory blocks allocated using the PAGEFIXED value; such memory is always locked. 
\par Virtual devices must not assume that the requested number of pages can always be locked. 
\par Each page in a memory block has an individual lock count. This service increments the lock count each time the page is locked, and decrements the count each time the page is unlocked. The lock count must be zero for the page to be unlocked. This means tha
t if the handle is locked 5 times, it has to be unlocked 5 times. Virtual devices must not leave handles locked when not needed. 
\par {\b _PageAllocate}, {\b _PageUnLock}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageUnLock 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _PageUnLock, <hMem, nPages, PageOff, flags>
\par 
\par or      eax, eax            ; nonzero if unlocked, zero if error
\par jz      not_unlocked
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Unlocks one or more pages in the specified memory block. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hMem}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle (base linear address) of the memory block that contains the pages to unlock. This value have been previously returned by the {\b _PageAllocate}, {\b _PageReAllocate,} or {\b _PageReserve}
 service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to unlock. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PageOff}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset in pages from the start of the block to the first page to unlock. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGELOCKEDIFDP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Unlocks pages only if the virtual page swap device use MS-DOS or BIOS functions to write to the hardware. If the virtual page swap device writes directly to the hardware, this service returns immediately without unlocking the pages. 
\par  PAGELOCKEDIFDP value cannot be used until after the {\b Init_Complete} message has been processed. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
PAGEMARKPAGEOUT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Marks pages for immediate swapping, if this service sets the lock count for the pages to zero. This service marks the pages by clearing the P_ACC bit for each page. The PAGEMARKPAGEOUT value should only be used if the pages are unlikely to be accessed for
 some time. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service returns an error if the sum of the {\i PageOff} and {\i nPages} parameters is greater than the number 
of pages in the memory block. It also returns an error if the specified pages are not already locked. 
\par Each page in a memory block has an individual lock count. This service increments the lock count each time the page is locked, and decrements the count each time the page is unlocked. The lock count must be zero for the page to be unlocked. This means tha
t if the handle is locked 5 times, it has to be unlocked 5 times. Virtual devices must not leave handles locked when not needed. 
\par {\b _PageLock}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Miscellaneous Page Management Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Miscellaneous page management services enable you to analyze pages, set page permissions, specify that pages are no longer in use, and get a handle to the system nul page. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _CopyPageTable 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _CopyPageTable, <LinPgNum, nPages, <OFFSET32 PageBuf>, flags>
\par 
\par mov     [Copied], eax           ; nonzero if copied, zero otherwise
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Copies one or more page-table entries to the specified buffer. Virtual devices, such as the virtual DMA device, use this service to analyze the mapping of linear to physical addresses. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns a nonzero value in the EAX register if the copy is successful, zero otherwise. The return value is zero if at least one of the specified page table entries was in a region where the corresponding page directory entry is not present. If zero is re
turned, the contents of the output buffer are undefined. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i LinPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Number of the first page table entry to copy. This parameter must be in the range 0 through 0FFFFFh. Numbers in the range 0 through 10Fh specify pages in the 1 megabyte V86 address space of the current virtual machine. Page numbers for other virtual machi
nes can be computed using the {\b CB_High_Linear} field in the control block of each virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of page-table entries to copy. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PageBuf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the buffer to receive the page-table entries. This buffer must be large enough to receive the specified number of entries. Each entry is 4 bytes. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This service copies the page table, so writing to the buffer does not affect the content of the actual page table. The system does not update the buffer when changes to the actual page table are made, so no guarantees are made about the length of time the
 information in the buffer remains accurate. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetNulPageHandle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetNulPageHandle
\par 
\par mov     [NulPage], eax          ; handle of system nul page
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Returns the memory handle of the system nul page. This page can be mapped to unused regions of the address space to prevent page faults. The system nul page can be mapped to multiple locations in the system, so its contents are always random. Uses EAX. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the memory handle of the system nul page in the EAX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The null page handle is the one exception to the otherwise uniform rule that memory handles and memory addresses are the same. The handle returned by {\b _GetNulPageHandle}
 can be used in the following (and only in the following) ways: It can be passed as the source page handle in {\b _MapIntoV86}, or as the source physical page for {\b _PageCommitPhys}
, in order to map or commit null pages. As a special case, you can also pass the null page handle to {\b _PageGetSizeAddr}, although the return value is not entirely meaningful. 
\par {\b _MapIntoV86}, {\b _PageCommitPhys}, {\b _PageGetSizeAddr}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageModifyPermissions 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageModifyPermissions(ULONG page, ULONG npages,
\par \tab ULONG permand, ULONG permor);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Modifies the permissions for pages in the specified range. Uses EAX, ECX, EDX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the previous permissions of the first page in the range if successful, \endash 
1 otherwise. If an error occurs, the service returns without modifying any permissions. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page} and {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number if the first page in the range, and the number of pages in the range. All of the specified pages must be committed. None of the pages may be static unless the {\i permor}
 parameter specifies the PC_STATIC flag. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i permand}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 AND mask to combine with the existing permissions for each page. Can be PC_USER, PC_WRITEABLE, or both. To withhold a permission, do {\i not} specify the corresponding flag. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i permor}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 OR mask to combine with the existing permissions for each page. Can be PC_USER, PC_WRITEABLE, or both. To grant a permission, specify the corresponding flag. To change the permi
ssions of static pages, this parameter must also include the PC_STATIC flag. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For more information about permission flags, see the description of the {\b _PageCommit} service. 
\par {\b _pagecommit}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageQuery 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageQuery(ULONG pbase,
\par \tab PMEMORY_BASIC_INFORMATION pmbi, \tab ULONG cbmbi);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves information about a range of virtual pages. This service carries out the work for the {\b _VirtualQuery} function in the Win32 API. Uses EAX, ECX, EDX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the count of bytes filled in return structure (0 if error) 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pbase}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Linear address of the first page in the range. This address is rounded down to the nearest page boundary. The range includes all consecutive pages starting at this address that share the following attributes: 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The pages share the same state: committed, reserved, or free. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab If the initial page is not free, all pages were reserved by the same call to the _PageReserve service. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The pages share the same read and write privileges: read-only, read-write, or no access. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pmbi} and {\i cbmbi}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b MEMORY_BASIC_INFORMATION} structure that receives information about the range of pages, and the size of the structure in bytes. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 208}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 15 Pagers{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 207}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 15
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Pagers 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Pagers 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A {\i pager}
 is a component or body of code that the VMM calls to move pages in and out of memory. Every committed page is associated with a pager except for hooked pages, instanced pages, and pages committed using {\b _PageCommitPhys}
. Virtual devices can register pagers by using VMM services. Additional services enable virtual devices to immediately write pages to the swap file, or to discard pages that no longer contain valid information. 
\par A pager is defined by a {\b PD} (pager descriptor) structure. This structure contains t
he addresses of pager functions. The VMM calls pager functions when a page needs be moved in or out of memory (paged in or out). The VMM calls other pager functions when it detects that a page has been accessed, and when a page is decommitted. 
\par The VMM has four internal pagers that correspond to the following page types: fixed zero-initialized, swappable zero-initialized, fixed initialized, and swappable initialized. Fixed pages are paged in when committed, and are never paged out. 
\par A virtual device can register a pager by using the {\b _PagerRegister} service. The VWIN32 device registers pagers to support memory mapped files. The service returns a handle that can be specified when pages are committed. To deregister a pager, use the 
{\b _PagerDeregister} service. To retrieve information about an existing pager, use the {\b _PagerQuery} service. 
\par Registered pages that use MS-DOS functions to perform file operations must be able to do so during hardware interrupt processing. A file is identified by a f
ile handle and a PSP. Any PSP created after Windows starts is instanced, and therefore may not be addressable by MS-DOS when a hardware interrupt occurs. Therefore, a virtual device must use the {\b Get_PSP_Segment}
 service to retrieve a PSP that is in global memory. It can then initialize the PSP with appropriate values and use nested execution services to call MS-DOS functions. 
\par A virtual device can force a range of committed pages to be immediately paged out by using the {\b _PageFlush} service. This service calls the appropriate pager function to page out each page, but the pages remain present. 
\par When referring to a page, the term "virgin" means that the page contents have never been altered. Virgin pages typically do not need to be paged out because they can always be regenerated, either by doing nothing (for uninitialized pages), zero-initializa
tion (for zero-initialized pages), or by reading from a disk file (for demand-paged executables). The term "tainted" refers to a page whose contents have been altered. Tai
nted pages typically need to be saved to disk (either in the swap file or to a memory-mapped file) because their contents cannot be regenerated otherwise. 
\par If the content of a range of pages is invalid or does not need to be preserved, you can discard the pages by using the {\b _PageDiscardPages}
 service. The pages remain committed, but are considered virgin pages. Therefore, they are not written to disk when they are next paged out, and are not read from disk when they are next paged in. Optionally, the pages c
an immediately be made not present. 
\par See also {\b Get_PSP_Segment}, {\b _PageDiscardPages}, {\b _PageFlush}, {\b _PagerDeregister}, {\b _PagerQuery}, {\b _PagerRegister}, {\b PD}
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageChangePager 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par ULONG EXTERNAL PageChangePager(ULONG Page, ULONG nPages, ULONG hpd,
\par     ULONG pagerdata, ULONG flags)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Changes the pager or pager data for a range of pages. This service should only be used to modify the information for pages and pagers under the control of the caller. Uses EAX, ECX, EDX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a non-zero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Page}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page to modify. All pages of the specified range must be committed and within the same memory object. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to modify. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hpd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the page descriptor to set in each of the pages in the range. This parameter is used only if the PCP_CHANGEPAGE flag is specified. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pagerdata}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 New value to store in the page data double-word of each page in the range. This parameter is used only if the PCP_CHANGEPAGERDATA flag is specified. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be one or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PCP_CHANGEPAGER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Change the pager for the specified range of pages. The {\i hpd} parameter specifies the handle of the page descriptor to set in each of the pages. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PCP_CHANGEPAGERDATA \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Store the {\i pagerdata} value in the page data double-word of each page in the range. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PCP_VIRGINONLY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Change only virgin pages. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PC_INCR \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Increment the specified pager data for each page in the range before storing it. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If PCP_CHANGEPAGER is specified, the old pager's {\b pd_taintedfree} or {\b pd_virginfree} callback function is called, just as if the pages had been decommitted. 
\par {\b pd}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageDiscardPages 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageDiscardPages(ULONG Page, ULONG VM, ULONG nPages, 
\par     ULONG flags);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Marks pages as not recently accessed, making them more likely page-out candidates. The pages can optionally be marked discarded as well, which reverts them to a virgin state, avoiding the need even to page them out. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Page}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Linear page number of the first page to mark as page-out candidates. All pages of the specified range must be committed. If the pages are associated with a virtual machine, they must be marked V86Pageable. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine containing the pages to mark as page-out candidates. This parameter is required if the {\i Page} parameter is less than 110h; otherwise it is ignored. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to mark as page-out candidates. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEDISCARD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Immediately makes the pages not present. If this value is not specified, the page remains present but is marked not recently accessed. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PAGEZEROINIT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Fills the pages with zeros when they are next paged
 in. This value is ignored unless PAGEDISCARD is also specified. If this value is not given, the content of the pages is undefined. See the following comments section for additional remarks. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
It is an error to attempt to discard pages that are not committed. This service ignores pages that are not present (that is, already paged out) or are locked (and cannot be paged out). This service affects only pages that are subject to demand paging. 

\par The PAGEDISCARD flag causes the s
ystem to revert the pages to their virgin state as well as removing the pages from memory. The PAGEZEROINIT flag may only be passed for pages that were originally allocated as normal swappable memory, either uninitialized or zero-initialized; that is, PD_
ZEROINIT or PD_NOINIT. It is an error to attempt to PAGEZEROINIT pages that belong to any other type of pager (because they won't know what to do). 
\par {\b _SetResetV86Pageable}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PageFlush 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PageFlush(ULONG page, ULONG npages);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes a range of committed pages to the backing file by calling the appropriate pager function. This service does not mark the pages as not-present. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i page}, {\i npages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page to write, and the number of pages to write. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PagerDeregister 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PagerDeregister(ULONG hpd)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Informs the system that a type of pager is no longer used. All pages using this pager should be freed before calling this service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hpd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the registered pager to deregister. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PagerQuery 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PagerQuery(ULONG hpd, PPD ppd);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves information about a registered pager. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hpd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the registered pager. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ppd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b PD} structure that receives information about the pager. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b PD}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PagerRegister 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par ULONG EXTERNAL _PagerRegister(PPD ppd);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Inform system of a new type of pager. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the registered pager if success, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ppd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b PD} structure containing information about the pager. The system makes its own copy of the structure. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The handle returned by this service may be passed to the {\b _PageCommit} service, thus placing the committed pages under the control of the registered pager. 
\par {\b _PageCommit}, {\b PD}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 PD 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmm.h>
\par 
\par typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage,
\par     ULONG faultpage);
\par typedef FUNPAGE *PFUNPAGE;
\par 
\par typedef struct pd_s \{
\par     PFUNPAGE pd_virginin;
\par     PFUNPAGE pd_taintedin;
\par     PFUNPAGE pd_cleanout;
\par     PFUNPAGE pd_dirtyout;
\par     PFUNPAGE pd_virginfree;
\par     PFUNPAGE pd_taintedfree;
\par     PFUNPAGE pd_dirty;
\par     ULONG pd_type;
\par \} PD, *PPD;
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pager-descriptor structure. Contains pointers to a pager's callback functions, and information about the overcommit characteristics of the pages the pager manages. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b pd_virginin} and {\b pd_taintedin}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Addresses of the pager functions that the system calls swap a page into memory. If the page has never been written to, the system calls the function specified by the {\b pd_virginin}
 member; otherwise it calls the function specified by the {\b pd_taintedin} member. 
\par These functions must return a nonzero value if successful, or zero otherwise. The parameters have the following meanings: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppagerdata}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Address of a pager-defined 32-bit value stored with the virtual page. The pager can modify this value during page in and out operations, but not at other times. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Ring-zero physical address of the page. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i faultpage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Linear page number that triggered a page fault. A pager should not attempt to access this page number. Note that the same page can be mapped to more than one linear address. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 
\f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b pd_cleanout} and {\b pd_dirtyout}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Addresses of the pager functions that the system calls to swap a page out of memory. If the page has not been written to since it was last paged out, the system calls the function specified by the {\b 
pd_cleanout} member; otherwise it calls the function specified by the {\b pd_dirtyout} member. 
\par These functions must return a nonzero value if successful, or zero otherwise. The parameters have the following meanings: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppagerdata}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Address of a pager-defined 32-bit value stored with the virtual page. The pager can modify this value during page in and out operations, but not at other times. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Ring-zero physical address of the page. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i faultpage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Always \endash  1. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b pd_virginfree} and {\b pd_taintedfree}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Addresses of the pager functions that the system calls when the last reference to a virtual page controlled by the pager is decommitted. If the page has never been written to since it was committed, the system calls the function specified by the {\b 
pd_virginfree} member; otherwise it calls the function specified by the {\b pd_taintedfree} member. 
\par The return value of these functions is ignored. The parameters have the following meanings: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppagerdata}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Address of a pager-defined 32-bit value stored with the virtual page. The pager can modify this value during page in and out operations, but not at other times. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Ring-zero physical address of the page if it is in memory, NULL otherwise. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i faultpage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Linear page number of the page being decommitted. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b pd_dirty}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Address of the pager function that the memory manager calls when it detects that a page has been written to. If a page is dirtied in more than one memory context, this function is called once for each context. 
\par The return value of this function is ignored. The parameters have the following meanings: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppagerdata}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Address of a pager-defined 32-bit value stored with the virtual page. The pager can modify this value during page in and out operations, but not at other times. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i ppage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Undefined. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\i faultpage}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Linear page number of the dirtied page. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b pd_type}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the overcommit characteristics of the pages associated with this pager. Can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PD_SWAPPER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Pages controlled by this pager may be paged out. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PD_PAGERONLY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Pages controlled by this pager are never paged out to the swap file. If this value is specified, the VMM calls the pager's virgin-in function as soon as a page is committed; the tainted-in and page-out functions are never called. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _PagerRegister}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 230}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 16 Primary Scheduler{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 231}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 16
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Primary Scheduler 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About the Primary Scheduler 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Introduction 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Windows 95 is a multiple-threaded, preemptive multitasking operating system. Each task running in the system virtual machine can consist of one or more threads of execution. A task running in a non-system virtual machine can have only one thread. The Wind
ows 95 virtual machine manager (VMM) includes a {\i primary scheduler} that determines whether a particular thread receives processor time. This chapter describes the primary scheduler and its related VMM services. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Execution Priority 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The primary scheduler assigns an {\i execution priority}
 value to a each thread. The VMM grants processor time only to threads that share the highest execution priority. A thread with an execution priority lower than the highest priority does not receive any processor time; that is, it is {\i suspended}
. (Note that this should not be confused with the concept of a virtual machine being suspended.) 
\par The VMM assigns an execution priority to a thread when the thread is created. The VMM and virtual devices can subsequently raise or lower the execution priority, causing the processor to switch from one thread to another. If the new thread belongs to a di
fferent virtual machine, the VMM performs a task switch to the new virtual machine, making it the current virtual machine. The VMM often temporarily raises the execution priority for a thread that needs to servi
ce a high-priority device event, such as an interrupt that must be serviced in a timely manner. 
\par A virtual device can raise or lower the priority of a thread by calling the {\b Adjust_Exec_Priority }or {\b Adjust_Thread_Exec_Priority} service. Use {\b Adjust_Thread_Exec_Priority}
 to adjust the execution priority of a thread in the system virtual machine, and {\b Adjust_Exec_Priority} to adjust the execution priority of the thread in a non-system virtual machine. If you specify the handle of the system virtual machine in a call
 to {\b Adjust_Exec_Priority}, the VMM adjusts the priority of the system virtual machine's initial thread. 
\par See also {\b Adjust_Exec_Priority}, {\b Adjust_Thread_Exec_Priority}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Creating and Terminating Threads 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can use the {\b VMMCreateThread} service to create a new thread in the system virtual machine. The new thread runs in protected mode at ring three. {\b VMMCreateThread}
 returns a handle identifying the new thread. The virtual device can use the handle in subsequent services which control the execution of the thread, such as {\b Adjust_Thread_Exec_Priority}. 
\par Before creating the new thread, {\b VMMCreateThread} broadcasts the {\b Create_Thread}
 control message to all virtual devices in the system. A virtual device typically responds by allocating any structures it needs to support the thread. By setting the carry flag, a virtual device that cannot support the new thread can prevent the thread f
rom being created. 
\par After the new thread is created, {\b VMMCreateThread} broadcasts the {\b Thread_Init}
 control message to all virtual devices. This message passes the handle of the new thread to the virtual devices, and gives the devices an opportunity to perform initialization procedures that must take place in the context of the new thread. 
\par A virtual device can use the {\b VMMTerminateThread} service to destroy a thread created by a previous call to {\b VMMCreateThread}. The {\b VMMTerminateThread}
 service will not destroy the initial thread of a virtual machine, nor will it destroy the currently executing thread. 
\par Before terminating a thread, {\b VMMTerminateThread} broadcasts the {\b Terminate_Thread} control message to all virtual devices. When the thread is no longer being scheduled, the {\b Thread_Not_Executeable}
 control message is broadcast to all virtual devices. Finally, the {\b Destroy_Thread} control message is broadcast, signaling that it is safe for virtual devices to free resources associated with the thread. 
\par See also {\b Adjust_Thread_Exec_Priority}, {\b Create_Thread}, {\b Destroy_Thread}, {\b Terminate_Thread}, {\b Thread_Not_Executeable}, {\b VMMCreateThread}, {\b VMMTerminateThread}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Controlling Virtual Machine Execution 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b Close_VM} and {\b Nuke_VM} services terminate the specified virtual machine. {\b Close_VM}
 gives all virtual devices an opportunity to clean up before the virtual machine terminates by first broadcasting the {\b Close_VM_Notify} message to all virtual devices. By comparison, {\b Nuke_VM}
 does not broadcast any notifications before terminating the virtual machine. A virtual device should use {\b Nuke_VM} only to terminate a virtual machine that has not terminated normally and does not respond to {\b Close_VM}. 
\par The VMM maintains a suspend count for each non-system virtual machine. The execution of a non-system virtual machine is suspended whenever its suspend count is greater than zero. Calling {\b Suspend_VM}
 increments the suspend count; calling Resume_VM decrements it. (As noted previously, this sense of the word "suspend" when applied to virtual machines is different from the sense when applied to threads.) 
\par A virtual device receives the {\b VM_Suspend} control message when {\b Suspend_VM} changes a virtual machine's suspend count from 0 to 1. It receives the {\b VM_Resume} control message when {\b Resume_VM}
 changes the count from 1 to 0. A virtual device can prevent the virtual machine from resuming by setting the carry flag in response to {\b VM_Resume}. A virtual device cannot prevent a virtual machine from being suspended. The {\b No_Fail_Resume_VM}
 service is similar to {\b Resume_VM} except that it doesn't allow a virtual device to prevent a virtual machine from resuming. 
\par See also {\b Close_VM}, {\b No_Fail_Resume_VM}, {\b Nuke_VM}, {\b Suspend_VM}, {\b Resume_VM}, {\b VM_Resume}, {\b VM_Suspend}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Task and Thread Switching 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can use the {\b Call_When_Task_Switched }
service to install a callback function that the VMM calls whenever the processor switches from one task to another. The callback remains in effect until it is removed by calling the {\b Cancel_Call_When_Task_Switched} service. 
\par Similarly, a virtual device can use the {\b Call_When_Thread_Switched }service to install a callback function that the VMM calls whenever the processor switches from one thread to another. It can remove the callback function by calling the {\b 
Cancel_Call_When_Thread_Switched} service. 
\par Thread-switch and task-switch callbacks are called extremely frequently and should be written for maximum speed. 
\par See also {\b Call_When_Task_Switched}, {\b Call_When_Thread_Switched}, {\b Cancel_Call_When_Task_Switched}, {\b Cancel_Call_When_Thread_Switched}
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Execution Priority 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Adjust_Exec_Priority 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, PriorityBoost
\par mov     ebx, VMHandle
\par VMMcall Adjust_Exec_Priority
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Raises or lowers the execution priority of the specified virtual machine. The service adds the specified boost to the virtual machine's current execution priority. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PriorityBoost}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A signed integer valu
e representing the positive or negative priority boost for the virtual machine. This parameter must be a value such that when added to the current execution priority, the result is within the range Reserved_Low_Boost to Reserved_High_Boost. The following 
lists some common priority boost values, from lowest to highest: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_Low_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Cur_Run_VM_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use to boost the priority of each virtual machine, in turn, forcing them to run for their allotted time slices. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Low_Pri_Device_Boost \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use for operations that need timely processing but are not time critical. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 High_Pri_Device_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use for time-critical operations that should not circumvent the critical section boost. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Critical_Section_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use to boost the priority of the virtual machine whenever it enters a critical section (calls 
{\b Begin_Critical_Section)}. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Time_Critical_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use for operations that require immediate processing, even when another virtual machine is in a critical section. For example, VPICD uses this when simulating hardware interrupts. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_High_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle }
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Because the nonsuspended virtual machine with the highest execution priority is always the current virtual machine, this service causes a task switch under two circumstances: 
\par \pard\plain \s27\fi-440\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 \tab 1\tab The execution priority of the current virtual machine is lowered (EAX is negative), and there is another virtual machine with a higher priority that is not suspended. 

\par \tab 2\tab The execution of a nonsuspended virtual machine which is not the current virtual machine is raised (EAX is positive) higher than the current virtual machine's execution priority. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Even if the current virtual machine is in a critical section, a task switch will still occur if the priority of another nonsuspended virtual machine is raised higher than the current virtual machine's priority. However, this will only occur when a virtual
 machine is given a time-critical boost, for example, to simulate a hardware interrupt. 
\par It is often more convenient to call the {\b Call_Priority_VM_Event} service than to call this service directly. 
\par {\b Adjust_Thread_Exec_Priority}, {\b Begin_Critical_Section}, {\b Call_Priority_VM_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Adjust_Thread_Exec_Priority 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, PriorityBoost
\par mov     edi, ThreadHandle
\par VMMcall Adjust_Thread_Exec_Priority
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Raises or lowers the execution priority of the specified thread. The service adds the specified boost to the thread's current execution priority. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PriorityBoost}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
A signed integer value representing the positive or negative priority boost for the thread. This parameter must be a value such that when added to the current execution priority, the result is within the range Reserved_Low_Boost to Reserved_High_Boost. Th
e following lists some common priority boost values, from lowest to highest: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_Low_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Cur_Run_VM_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use to boost the priority of each thread, in turn, forci
ng them to run for their allotted timeslices. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Low_Pri_Device_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Use for operations that need timely processing but are not time critical. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 High_Pri_Device_Boost \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use for time-critical operations that should not circumvent the critical section boost. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Critical_Section_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use to boost the priority of the thread whenever it enters a critical section (calls {\b Begin_Critical_Section)}. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Time_Critical_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use for operations that require immediate processing, even when another thread is in a critical section. For example, VPICD uses this when simulating hardware interrupts. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved_High_Boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for use by system. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Because the nonsuspended thread with the highest execution priority is always the current thread, this service causes a task switch under two circumstances: 
\par \pard\plain \s27\fi-440\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 \tab 1\tab The execution priority of the current thread is lowered (EAX is negative), and there is another thread with a higher priority that is not suspended. 
\par \tab 2\tab The execution priority of a nonsuspended thread which is not the current thread is raised (EAX is positive) higher than the current thread's execution priority. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Even if the current thread is in a critical section, a task switch will still occur if the priority of another nonsuspended thread is raised higher than the current thread's priority. However, this will only occur when a thread is given a time-critical bo
ost, for example, to simulate a hardware interrupt. 
\par It is often more convenient to call the {\b Call_Priority_VM_Event} service than to call this service directly. 
\par {\b Adjust_Exec_Priority}, {\b Begin_Critical_Section}, {\b Call_Priority_VM_Event}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Thread Creation and Termination 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Introduction 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A virtual device uses the services described in this section to create and destroy threads in the system virtual machine. Also, a virtual device receives the following messages when creating or destroying threads in the system VM: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Message \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Create_Thread}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A new thread is being created. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Destroy_Thread}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A non-initial thread is about to be destroyed \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Terminate_Thread}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A non-initial thread is about to terminate. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Thread_Not_Executeable}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A non-initial thread has stopped executing. \cell \pard\plain \intbl \f4\fs21 
\row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Thread_Init}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A new thread was created. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For a description of these messages, see {\i VMM Messages}. 
\par See also {\b Create_Thread}, {\b Destroy_Thread}, {\b Terminate_Thread}, {\b Thread_Not_Executeable}, {\b Thread_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMMCreateThread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 VMMcall VMMCreateThread, <initial_ss, intial_esp, initial_cs,
\par     initial_eip, initial_ds, initial_es, ThreadType, InitCallback,
\par     RefData>
\par or      eax, eax
\par jz      thread_not_created
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates a protected mode thread in the system virtual machine and starts it executing in ring 3 at the instruction specified by CS:EIP. Uses all registers and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the new thread in EAX if successful; otherwise, returns 0 in EAX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i initial_ss}, {\i initial_esp}, {\i initial_cs}, {\i initial_eip}, {\i initial_ds}, {\i initial_es}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Ring 3 protected mode registers used to start the thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Programmer-defined DWORD value a VxD can use to uniquely identify the threads that it creates. Typically, this value is a pointer to the VxD's DDB because the pointer is unique among VxDs. This value is stored in the TCB_ThreadType field of the thread's c
ontrol block. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i InitCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Ring 0 initialization function that is called after the {\b Thread_Init} message is sent. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Programmer-defined DWORD value that is passed, in EDX, to the {\i InitCallback} function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is intended for use only by Windows internal system components. A virtual device should not use this service because it can cause the system to become unstable. 
\par The client registers are initialized to the values specified by the procedure parameters. The values must be valid values for ring 3; do not use ring 0 selectors. 
\par The {\b Create_Thread} and {\b Thread_Init} messages are sent to all virtual devices, and the timeslice scheduler is notified to start scheduling the thread. 
\par {\b Create_Thread}, {\b Thread_Init}, {\b VMMTerminateThread}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMMTerminateThread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par VMMcall VMMTerminateThread
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Destroys the specified thread. Uses all registers and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns only if the thread cannot be destroyed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to destroy. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is intended for use only by Windows internal system components. A virtual device should not use this service because it can cause the system to become unstable. 
\par Do not use this service to terminate the initial thread of a virtual machine. Use the {\b Close_VM} service instead. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Virtual Machine Execution Control 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Introduction 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A virtual device uses the functions described in this section to suspend, resume, and destroy virtual machines. Also, a virtual device receives the following messages when suspending, resuming, and destroying virtual machines: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Message \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Close_VM_Notify}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A virtual machine is terminating. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VM_Resume}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A virtual machine is resuming after having been suspended. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VM_Suspend}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A virtual machine is being suspended. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 For a description of these messages, see {\i VMM Messages}. 
\par See also {\b Close_VM_Notify}, {\b VM_Resume}, {\b VM_Suspend}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Call_On_My_Stack 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall _Call_On_My_Stack, <<OFFSET32 pfnCallback>, dwLParam, 
\par     <OFFSET32 pStack>, dwStackSize> 
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Temporarily switches a ring 0 stack to a different locked block of memory. A VxD can use this service to perform an operation that requires more than 4K bytes of stack space (each thread is limited to 4K bytes of ring 0 stack space.) This service switches
 to the new stack and then calls the given callback function with the {\i LParam}
 parameter pushed on the new stack. When the callback function returns, the service switches back to the original ring 0 stack, and then returns control to the caller. This service 
can handle nested calls. Uses the C calling convention. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pfnCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of callback function. This function must be declared using the C calling convention. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwLParam}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Double-word parameter to push on the new stack before calling the callback function. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pStack}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Stack pointer (value of ESP register). The stack can be as many pages as needed as long as they are all locked. Because the stack grows towards smaller addresse
s, this parameter should be the upper limit of the stack, not the lower limit. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwStackSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The size, in bytes, of the temporary stack. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Close_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, TimeOut
\par mov     ebx, VMHandle
\par mov     ecx, Flags
\par VMMcall Close_VM
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Attempts to close the virtual machine, allowing all virtual devices an opportunity to clean up before the virtual machine terminates. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of milliseconds the service must wait before calling the {\b Nuke_VM} service to force the virtual machine to close. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to close. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Action to take: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 CVF_Continue_Exec \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Return to the virtual machine after scheduling the closing event even if the virtual machine is being closed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Whenever possible, a virtual device should use this service instead of the {\b Nuke_VM} or {\b Crash_Cur_VM} service. 
\par {\b Nuke_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 No_Fail_Resume_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par VMMcall No_Fail_Resume_VM
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Resumes the execution of a virtual machine previously suspended by the {\b Suspend_VM} service. Unlike the {\b Resume_VM} service, this service never returns an error. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to resume. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This service decrements the suspend count, and places the virtual machine in the ready-processes queue if the new count is zero. The system carries out a task switch to the resumed virtual machine if the virtual machine has a higher pr
iority than the current virtual machine. 
\par If the virtual machine cannot be resumed for some reason, the system notifies the user of the problem and handles the error automatically, resuming the virtual machine when there is sufficient memory available. 
\par {\b Resume_VM}, {\b Suspend_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Nuke_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par VMMcall Nuke_VM
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Closes a virtual machine that has not yet terminated normally. Uses ECX, EDX, and Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. If VMHandle specifies the current or system virtual machine, this service never returns. 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to destroy. If this parameter specifies the system virtual machine, a fatal error occurs and Windows terminates. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual shell device typically calls this service to close a virtual machine whenever the user chooses to end the task without going through normal application shutdown procedures. 
\par This service should be used with caution. 
\par {\b Close_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Resume_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par VMMcall Resume_VM
\par jc      not_resumed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Resumes the execution of a virtual machine previously suspended by the {\b Suspend_VM} service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Clears the carry flag if the suspend count is zero and the virtual machine is in the ready-processes queue; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to resume. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service decrements the suspend count, and places the virtual machine in the ready-processes queue if the new count is zero. The system
 carries out a task switch to the resumed virtual machine if the virtual machine has a higher priority than the current virtual machine. 
\par An error can occur if a virtual device cannot lock the memory handles for the specified virtual machine. The system notifies every virtual device of the request to resume a virtual machine, and any virtual device can deny the request. In such cases, this 
service returns with the carry flag set and the virtual machine remains suspended with a suspend count of 1. 
\par {\b No_Fail_Resume_VM}, {\b Suspend_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Suspend_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par VMMcall Suspend_VM
\par jc      not_suspended
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Suspends the execution of a specified virtual machine. This service fails if the specified virtual machine either owns the critical section, or is the system virtual machine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the virtual machine is suspended; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to suspend. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 An error occurs if the virtual machine is in a critical section, or if the {\i VMHandle} parameter specifies the system virtual machine. 
\par This service increments the suspend count for the virtual machine. If the virtual machine was not already suspended, the system notifies virtual devices of the suspension by sending a {\b VM_Suspend}
 message to the control procedure for each virtual device. A virtual device must {\i not} refuse to suspend a virtual machine. If a virtual machine remains suspended, subsequent calls to {\b Suspend_VM} do not cause the {\b VM_Suspend} notification. 

\par When a virtual machine is suspended, the system sets the VMStat_Suspended bit in the {\b CB_VM_Status}
 field of the virtual machine's control block. Although virtual devices may examine and modify the contents of the control block of a virtual machine, the virtual devices must not examine or modify any memory owned by a suspended virtual machine unless th
e virtual device previously locked that memory. 
\par Note that the actual suspension of a virtual machine may be delayed for various reasons. When the suspension is delayed, the service returns success, but the actual suspension does not take effect until later. 
\par {\b No_Fail_Resume_VM}, {\b Resume_VM}, {\b VM_Suspend}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Task and Thread Switching 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device uses the following services and callback functions to receive notifications and perform operations when the processor switches to a different thread or task. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_When_Task_Switched 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 TaskSwitchCallback
\par VMMcall Call_When_Task_Switched
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a task-switched callback function which the system calls whenever it carries out a task switch. This service should be used sparingly, and the callback function should be optimized for speed. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TaskSwitchCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. For more information about the callback function, see {\b TaskSwitchCallback}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Some virtual devices must save the state of a hardware 
device every time a task switch occurs and restore the hardware state for the virtual machine that is about to be run. However, virtual machine events can often be used in place of using this service. 
\par Virtual devices can install any number of callback functions. The system calls each one in the order installed, until all functions have been called. 
\par {\b Call_When_Idle}, {\b Call_When_Not_Critical}, {\b Call_When_Thread_Switched}, {\b Cancel_Call_When_Task_Switched}, {\b TaskSwitchCallback}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_When_Thread_Switched 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 ThreadSwitchCallback
\par VMMcall Call_When_Thread_Switched
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a callback function which the system calls whenever it switches to a different thread or task. This service should be used sparingly, and the callback function should be optimized for speed. Uses Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadSwitchCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. For more information about the callback function, see {\b ThreadSwitchCallback}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices can install any number of callback functions. The system calls each one in the order installed, until all functions have been called. 
\par {\b Call_When_Idle}, {\b Call_When_Not_Critical}, {\b Call_When_Task_Switched}, {\b Cancel_Call_When_Thread_Switched}, {\b ThreadSwitchCallback}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Call_When_Task_Switched 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     esi, OFFSET32 TaskSwitchCallback
\par VMMcall Cancel_Call_When_Task_Switched
\par jc      not_removed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes a callback function installed by a previous call to {\b Call_When_Task_Switched}. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the function is removed; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TaskSwitchCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of callback function to remove. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Call_When_Task_Switched}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Call_When_Thread_Switched 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     esi, OFFSET32 ThreadSwitchCallback
\par VMMcall Cancel_Call_When_Thread_Switched
\par jc      not_removed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes a callback function installed by a previous call to {\b Call_When_Thread_Switched}. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the function is removed; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadSwitchCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of callback function to remove. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Call_When_Thread_Switched}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 TaskSwitchCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     eax, OldVMHandle
\par mov     ebx, CurVMHandle
\par call    [TaskSwitchCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing whenever a task switch occurs. {\b TaskSwitchCallback} is a programmer-defined callback function installed by the {\b Call_When_Task_Switched }service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i OldVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the previous virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CurVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The callback function can carry out any operation and can modify the EAX, EBX, ECX, EDX, ESI, EDI, and Flags registers. 
\par {\b Call_When_Task_Switched}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 ThreadSwitchCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     eax, OldThreadHandle
\par mov     edi, CurThreadHandle
\par call    [ThreadSwitchCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing whenever the system switches to a different thread. {\b ThreadSwitchCallback} is a programmer-defined callback function installed by the {\b Call_When_Thread_Switched }
service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i OldThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the previous thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CurThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current thread. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The callback function can carry out any operation and can modify the EAX, EBX, ECX, EDX, ESI, EDI, and Flags registers. 
\par {\b Call_When_Thread_Switched}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Thread Information 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device uses the following services to retrieve thread information. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetLastUpdatedThreadExecTime 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See {\b _GetLastUpdatedThreadExecTime} in {\i Timing Services}. 
\par {\b _GetLastUpdatedThreadExecTime}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetThreadExecTime 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See {\b _GetThreadExecTime} in {\i Timing Services}. 
\par {\b _GetThreadExecTime}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetThreadTerminationStatus 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetThreadTerminationStatus, <ThreadHandle>
\par mov     StatusFlags, eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the termination status of the specified thread. Uses C calling convention. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a combination of these values in EAX: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THREAD_TERM_STATUS_CRASH_PEND \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The virtual machine as
sociated with the thread is terminating because a catastrophic error occurred. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THREAD_TERM_STATUS_NUKE_PEND 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The thread is in a must-complete section. The associated virtual machine will be closed when it reaches the end of the section. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THREAD_TERM_STATUS_SUSPEND \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The thread is in a must-complete section. The associated virtual machine will be suspended when it reaches the end of the section. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 If the return value is 0, the thread is not in a must-complete section and the virtual machine is not about to be suspended or closed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Cur_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall Get_Cur_Thread_Handle
\par mov     [hThread], edi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns a handle identifying the currently executing thread. Uses EDI and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a handle in EDI that identifies the currently executing thread. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Initial_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, [VMHandle]
\par VMMCall Get_Initial_Thread_Handle
\par mov     [hThread], edi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns a handle identifying a thread that was created at the same time that the virtual machine was created. Uses EDI and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a handle in EDI that identifies the VM's initial thread. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Identifies the virtual machine for which the thread was created. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Next_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall Get_Next_Thread_Handle
\par mov     [hThread], edi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Retrieves the handle of the next thread in the current virtual machine. If the current thread is the last thread, the service retrieves the handle off the first thread in the next virtual machine. Uses EDI and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a handle in EDI that identifies the next thread. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Sys_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall Get_Sys_Thread_Handle
\par mov     [hSysThread], EDI
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns a handle identifying the system thread. Uses EDI and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a handle identifying the system thread in EDI. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Thread_Win32_Pri 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc 
\par 
\par mov edi, ThreadHandle
\par VMMCall Get_Thread_Win32_Pri
\par 
\par mov [BasePriority], eax
\par mov [CurrentPriority], ecx
\par mov [TimeDecayBoost], edx
\par mov [InversionPriority], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the Win32 priority of the specified thread. Uses EAX, ECX, EDX, ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab If successful, the EAX, ECX, and EDX registers contain the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 absolute Win32 base priority (0-31) \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 absolute Win32 current priority (0-31) \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time decay boost if any \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ESI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 inversion priority if any \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle to the thread to retrieve the priority for. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Thread Data Slots 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device uses the following services to allocate and free thread data slots. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _AllocateThreadDataSlot 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _AllocateThreadDataSlot
\par cmp eax, 0
\par je  error
\par mov [DataSlotOffset], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allocates a thread data slot. Uses C calling conventions. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns an offset to the data slot, if the service succeeds; otherwise, returns zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A thread data slot is a DWORD value associated with each thread. The thread data slot offset gives the location of the thread data slot that you allocated, relative to the thread handle. Essentially, {\b 
_AllocateThreadDataSlot} works for threads just like {\b _Alloc_VM_CB_Area} works for virtual machines, except that the size of the memory block is always four bytes for thread data slots, whereas it is user-defined for virtual machine control blocks. 

\par Note that thread data slots are {\i not} zero-initialized. If this is important, you should zero-initialize the thread data slot yourself. 
\par Since thread data slots are only four bytes, if you need to record more than four bytes of data on a per-thread basis, the traditional mechanism is to store a pointer to a data block in the thread data slot. Do
n't forget to free the data block when the thread is destroyed, or you will leak memory. 
\par Thread data slots are scarce resources. They should be freed when no longer needed. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _FreeThreadDataSlot 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _FreeThreadDataSlot, <DataSlotOffset>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees a thread data slot. Uses C calling conventions. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DataSlotOffset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A valid data slot offset that was previously allocated by {\b _AllocateThreadDataSlot}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _AllocateThreadDataSlot}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Thread Debugging and Testing 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device uses the following services to debug threads and to test the validity of thread handles. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Test_Cur_Thread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, [hThread]
\par VMMCall Debug_Test_Cur_Thread
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether {\i hThread}
 identifies the current thread. If it is not, the service sends an error message to the debugger before returning. This service is valid only with the debugging kernel. Preserves all registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to test. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is typically not called directly. Virtual devices use the {\b Assert_Cur_Thread_Handle} macro instead. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Test_Valid_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, [hThread]
\par VMMCall Debug_Test_Valid_Thread_Handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether {\i hThread}
 is a valid thread handle. If it is not, the service sends an error message to the debugger before returning. This service is valid only with the debugging kernel. Uses no registers; the Flags register is preserved. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to validate. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is typically not called directly. Virtual devices use the {\b Assert_Cur_Thread_Handle} macro instead. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_Cur_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, [hThread]
\par VMMCall Test_Cur_Thread_Handle
\par je      Is_Current_Thread
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Tests {\i hThread} to determine whether or not it identifies the currently executing thread. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Sets the zero flag if hThread identifies the currently executing thread. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to test. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_Initial_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, [hThread]
\par VMMCall Test_Initial_Thread_Handle
\par je      Is_Initial_Thread
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines if the thread identified by {\i hThread} was the initial thread for a VM. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Sets the carry flag if hThread identifies the initial thread for the VM. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to test. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_Sys_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, hThread
\par VMMCall Test_Sys_Thread_Handle
\par je      Is_System_Thread
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the thread identified by {\i hThread }is the system thread. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Sets the zero flag if the thread identified by hThread is the system thread. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to test. This must be a valid thread handle. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Validate_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, [hThread]
\par VMMCall Validate_Thread_Handle
\par jc      Invalid_Handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Tests validity of thread identified by {\i hThread}. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The carry flag is not set if the thread is valid; otherwise it is set. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of thread being tested. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par  
\par  
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 234}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 17 Processor Faults{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 17
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Processor Faults 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Processor Faults 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A processor fault (also
 called a processor exception) is an interruption of execution typically caused by the currently running program rather than by an external source. There are the following processor fault services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Fault_Hook_Addrs}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns addresses for fault handlers. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_NMI_Handler_Addr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns NMI handler address. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_Invalid_Page_Fault}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a hook procedure for page faults. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_NMI_Event}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a non-maskable interrupt event procedure. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_PM_Fault}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a fault handler for protected mode. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_V86_Fault}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a fault handler for V86 mode. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_VMM_Fault}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a fault handler for VMM. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b NMIEventCallback}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Developer-defined callback function for a NMI event. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_NMI_Handler_Addr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets the NMI handler address. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_Invalid_Page_Fault}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes a hook procedure for page faults. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_NMI_Event}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Unhooks a non-maskable interrupt event procedure. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_PM_Fault}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Removes the hook procedure for the specified protected-mode fault. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_V86_Fault}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes the hook procedure for the specified virtual 8086 mode fault. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_VMM_Fault}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Removes the hook procedure for the specified fault. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Fault_Hook_Addrs 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, FaultNo      ; fault number
\par VMMcall Get_Fault_Hook_Addrs
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns addresses of the V86 mode, protected-mode, and VMM fault handlers for a specified fault. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, the following registers contain the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Contains the address of the handler for VMM faults. This register contains zero if no handler has been installed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Contains the address of the handler for V86 mode faults. This register contains zero if no handler has been installed. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ESI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Contains the address of the handler for protected-mode faults. This register contains zer
o if no handler has been installed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Fault number for which to retrieve information. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device cannot get the hook address for the Non-Maskable Interrupt (Interrupt 2). It must use the {\b Get_NMI_Handler_Addr} and {\b Set_NMI_Handler_Addr} services to hook Interrupt 2. 
\par {\b Get_NMI_Handler_Addr}, {\b Set_NMI_Handler_Addr}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_NMI_Handler_Addr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_NMI_Handler_Addr
\par 
\par mov     [NMI], esi          ; offset to current NMI handler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the address of the current Non-Maskable Interrupt (NMI) handler. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the offset of the current NMI handler in the ESI register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If a virtual device needs to hook the Non-Maskable Interrupt it must first call this service to get and save the original NMI handler address. The virtual device can then install the new NMI handler by using the 
{\b Set_NMI_Handler_Addr} service. The new handler should create an NMI handler chain by passing execution to the original NMI handler whenever it does not process the NMI. 
\par {\b Set_NMI_Handler_Addr}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_Invalid_Page_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 Callback  ; procedure to install
\par VMMcall Hook_Invalid_Page_Fault
\par 
\par jc      not_installed           ; carry flag set if procedure not installed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a procedure to handle any invalid-page faults not handled by the system invalid-page-fault handler. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the procedure to install. For more information about the procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system enables interrupts, and calls the procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     edi, OFFSET32 ipf   ; points to an IPF_Data
\par call    [Callback]
\par 
\par jc      not_corrected       ; carry flag set if procedure did
\par                             ; not correct fault
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine, and the {\i ipf} parameter points to an {\b IPF_Data} structure containing information about the page fault. 
\par If the callback procedure handles the page fault (for example, by mapping a page into the VM or by altering the page protections), it should return carry clear. Otherwise, the callback should return carry set to indicate that the system should pass the fa
ult to the next procedure in the chain. 
\par The procedure may use all registers except the segment registers. 
\par {\b Unhook_Invalid_Page_Fault}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_NMI_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 NmiProc
\par VMMcall Hook_NMI_Event
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Installs a Non-Maskable Interrupt (NMI) event procedure. Virtual devices use this service to install event procedures to carry out tasks that are not permitted in NMI handlers. This service is available only during initialization. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NmiProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of NMI event procedure. For more information about the procedure, see {\b NMIEventCallback}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The system calls each installed NMI event procedure after the last handler in the NMI handler chain has executed. If more than one NMI event procedure is installed, the system calls the procedures in the order in which they were installed. 
\par {\b NMIEventCallback}, {\b Unhook_NMI_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_PM_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, FaultNo          ; fault number to hook
\par mov     esi, OFFSET32 FaultProc ; points to a fault handler
\par VMMcall Hook_PM_Fault
\par 
\par jc      not_installed           ; carry flag set if not installed
\par ; The following line is optional. See the following comments section.
\par mov     [Previous], esi         ; points to previous fault handler (if any)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a fault handler procedure for faults encountered by protected mode applications. Virtual devices typically install fault handlers while processing the {\b Sys_Critical_Init}
 control message to handle faults, such as general protection faults, that the VMM fault handlers cannot handle. The VMM installs its fault handlers only after the {\b Sys_Critical_Init} control message. Virtual devices install fault handlers after {\b 
Sys_Critical_Init} to handle faults before the fault is passed to the VMM fault handlers. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, and if FaultProc is a hook procedure, the address of the previous handler is stored into the hook variable. If there was no previous handler, the address of the d
efault handler is stored in the hook var
iable. Whether or not FaultProc is a hook procedure, the ESI register contains the address of the previous fault handler (zero if there was no previous handler). The return value in ESI exists solely for backwards compatibility with Windows 3.1. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Fault number for which to install the fault handler. The fault number cannot be 02h, and must not be greater than 4Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Points to the fault handler to install, which should be a hook procedure in order to be compatible with future versions of Windows. For more information about the handler, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can install a fault handler while processing the {\b Sys_Critical_Init} message or at a later time. When a fault occurs, fault handlers installed after the {\b Sys_Critical_Init}
 message receive control first, the VMM fault handlers receive control next, and fault handlers installed during the {\b Sys_Critical_Init}
 message receive control last. (Of course, dynamically-loaded VxDs have no choice but to install the fault handler after {\b Sys_Critical_Init}, since they haven't yet been loaded at the time the {\b Sys_Critical_Init} message is broadcast. 
\par The system disables interrupts, and calls the fault handler as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM                 ; current VM handle
\par mov     ebp, OFFSET32 crs       ; points to a Client_Reg_Struc
\par call    [FaultProc]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine, and the {\i crs} parameter points to a {\b Client_Reg_Struc} structure containing the register values for the current virtual machine. 

\par If the fault procedure does not process the fault, it should pass the fault to the previous fault handler as stored into the hook variable, making sure that {\i all} registers are preserved (not just the registers containing input parameters). 
\par The default fault handler calls the fault vector installed by the protected-mode application. (Protected-mode fault hooks gain control before the application sees the fault.) 
\par If the fault handler processes the fault, the handler should return without chaining by executing a near {\b ret} instruction (not an {\b iret} instruction). 
\par The fault handler can modify the EAX, EBX, ECX, EDX, ESI, and EDI registers. 
\par Do not use this service to install a fault handler for the Non-Maskable Interrupt (NMI). Instead, a virtual device must use the {\b Get_NMI_Handler_Addr} and {\b Set_NMI_Handler_Addr} services. 
\par Do not use this service to install handlers for hardware interrupts. Instead, a virtual device must use virtual PIC device services. 
\par {\b Hook_V86_Fault}, {\b Hook_VMM_Fault}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_V86_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, FaultNo         ; fault number 
\par mov     esi, OFFSET32 FaultProc ; points to a fault handler
\par VMMcall Hook_V86_Fault
\par 
\par jc      not_installed        ; carry flag set if not installed
\par ; The following line is optional. See the following comments section.
\par mov     [Previous], esi      ; points to previous fault handler (if any)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a fault handler procedure for V86 mode faults. Virtual devices typically install fault handlers while processing the {\b Sys_Critical_Init} message to handle faults, suc
h as general protection faults, that the VMM fault handlers cannot handle. The VMM installs its fault handlers after the {\b Sys_Critical_Init} control message. Virtual devices install fault handlers after {\b Sys_Critical_Init}
 to handle faults before the fault is passed to the VMM fault handlers. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, and if FaultProc is a hook procedure, the address of the previous handler i
s stored in the hook variable. If there was no previous handler, the address of the default handler is stored in the hook variable. Regardless of whether FaultProc is a hook procedure, the ESI register contains the address of the previous fault handler (z
ero if there was no previous handler). The return value in ESI exists solely for backward compatibility with Windows 3.1. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Fault number for which to install the fault handler. The fault number cannot be 02h, and must not be greater than 4Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the fault handler to install. For more information about the handler, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can install a fault handler while processing the {\b Sys_Critical_Init} message or at a later time. When a fault occurs, fault handlers installed after the {\b Sys_Critical_Init}
 message receive control first, the VMM fault handlers receive control next, and fault handlers installed during the {\b Sys_Critical_Init} message receive control last. (Of course, dynamically-loaded VxDs have no choice but to instal
l the fault handler after {\b Sys_Critical_Init}, because they haven't yet been loaded at the time the {\b Sys_Critical_Init} message is broadcast.) 
\par The system disables interrupts and calls the fault handler as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM                 ; current VM handle
\par mov     ebp, OFFSET32 crs       ; points to a Client_Reg_Struc
\par call    [FaultProc]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine, and the {\i crs} parameter points to a {\b Client_Reg_Struc} structure containing the register values for the current virtual machine. 

\par If the fault procedure does not process the fault, it should pass the fault to the previous fault handler, as stored into the hook variable, making sure that {\i all} registers are preserved (not just the registers containing input parameters). 
\par The default fault handler crashes the virtual machine, except for faults 0 (divide), 1 (trace), 3 (breakpoint), 4 (overflow), 5 (bound), and 7 (coprocessor), which are reflected as interrupts. 
\par If the fault handler processes the fault, or if there is no previous fault handler, the handler should return without chaining by executing a near {\b ret} instruction (not an {\b iret} instruction). 
\par The fault handler can modify the EAX, EBX, ECX, EDX, ESI, and EDI registers. 
\par Do not use this service to install a fault handler for the Non-Maskable Interrupt (NMI). Instead, a virtual device must use the {\b Get_NMI_Handler_Addr} and {\b Set_NMI_Handler_Addr} services. 
\par Do not use this service to install handlers for hardware interrupts. Instead, a virtual device must use virtual PIC device services. 
\par {\b Hook_PM_Fault}, {\b Hook_VMM_Fault}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_VMM_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, FaultNo            ; fault number
\par mov     esi, OFFSET32 FaultProc ; points to a fault handler
\par VMMcall Hook_VMM_Fault
\par 
\par jc      not_installed           ; carry flag set if not installed
\par ; The following line is optional. See the following comments section.
\par mov     [Previous], esi         ; points to previous fault handler (if any)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a fault handler procedure for faults encountered by VMM or other virtual devices. Virtual devices typically install fault handlers while processing the {\b Sys_Critical_Init}
 control message to handle faults, such as general protection faults, that the VMM fault handlers cannot handle. The VMM installs its fault handlers after the {\b Sys_Critical_Init} control message. Virtual devices install fault handlers after {\b 
Sys_Critical_Init} to handle faults before the fault is passed to the VMM fault handlers. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, set otherwise. If the carry flag is clear, and if FaultProc is a hook procedure, the address of the previous handler is stored into the hook variable. If there was no previous handler, the address of the d
efault handler is stored into the hook variable. Regardless of whether FaultProc is a hook procedure, the ESI register contains the address of the previous fault handler (zero if 
there was no previous handler). The return value in ESI exists solely for backwards compatibility with Windows 3.1. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Fault number for which to install the fault handler. The fault number cannot be 02h, and must not be greater than 4Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the fault handler to install. For more information about the handler, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can install a fault handler while processing the {\b Sys_Critical_Init} message, or at a later time. When a fault occurs, fault handlers installed after the {\b Sys_Critical_Init}
 message receive control first, the VMM fault handlers receive control next, and fault handlers installed during the {\b Sys_Critical_Init}
 message receive control last. (Of course, dynamically-loaded VxDs have no choice but to install the fault handler after {\b Sys_Critical_Init}, since they haven't yet been loaded at the time the {\b Sys_Critical_Init} message is broadcast.) 
\par The system disables interrupts and calls the fault handler as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM                 ; current VM handle
\par mov     ebp, OFFSET32 stkfrm    ; points to VMM re-entrant stack frame
\par call    [FaultProc]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine, and the {\i stkfrm} parameter points to the VMM re-entrant fault stack frame. 
\par The EBP register does {\i not} point to a client register structure. 
\par The fault handler may call asynchronous services only. 
\par If the fault handler does not process the fault, it should pass the fault to the previous fault handler (if any), making sure that {\i all} registers are preserved (not just the registers containing input parameters). 
\par If the fault handler processes the fault or if there is no previous fault handler, the handler should return without chaining by executing a near {\b ret} instruction (not an {\b iret} instruction). 
\par The fault handler can modify the EAX, EBX, ECX, EDX, ESI, and EDI registers. 
\par Do not use this service to install a fault handler for the Non-Maskable Interrupt (NMI). Instead, a virtual device must use the {\b Get_NMI_Handler_Addr} and {\b Set_NMI_Handler_Addr} services. 
\par Do not use this service to install handlers for hardware interrupts. Instead, a virtual device must use virtual PIC device services. 
\par {\b Hook_PM_Fault}, {\b Hook_V86_Fault}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 NMIEventCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     ebp, OFFSET32 crs
\par call    [NmiProc]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing that is not permitted in a Non-Maskable Interrupt (NMI) handler. {\b NMIEventCallback} is a programmer-defined callback function installed by the {\b Hook_NMI_Event}
 service. An {\b NMIEventCallback} function can be re-entered; that is, it can be interrupted by another NMI. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i crs}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the contents of the virtual machine's registers. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Client_Reg_Struc}, {\b Hook_NMI_Event}, {\b Unhook_NMI_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_NMI_Handler_Addr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 nmi       ; points to new NMI handler
\par VMMcall Set_NMI_Handler_Addr
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the Non-Maskable Interrupt (NMI) vector to the address of the specified NMI handler. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nmi}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the new NMI handler. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 To install an NMI handler, a virtual device must retrieve and save the current NMI handler address using the {\b Get_NMI_Handler_Addr} service, and set the new address using {\b Set_NMI_Handler_Addr}. 
\par The NMI handler must {\i not} call VMM or virtual device services. This restriction includes calls to asynchronous VMM services. The NMI handler can examine and modify local
 data in the VxD_LOCKED_DATA_SEG segment, but it must not attempt to access any other memory, including virtual machine and V86 memory. If a virtual device needs to use VMM services in response to an NMI, it should install an NMI event handler using the {
\b Hook_NMI_Event} service. 
\par The NMI handler must not execute the {\b iret} instruction. Instead, it must jump to the address of the previous NMI handler (retrieved using the {\b Get_NMI_Handler_Addr} service). The CPU ignores additional NMIs until it executes the {\b iret} in
struction. Because no NMI handlers in the chain execute this instruction, the handlers are guaranteed not to be re-entered. 
\par Some computers require the latch at port 70h be reset to enable further NMIs. To simplify NMI processing for other NMI handlers, the virtual-parity device (PARITY) automatically resets this latch. 
\par {\b Get_NMI_Handler_Addr}, {\b Hook_NMI_Event}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_Invalid_Page_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 HookProc     ; points to hook procedure to remove
\par VMMcall Unhook_Invalid_Page_Fault
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the specified hook procedure from the invalid-page-fault chain. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i HookProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the hook procedure to remove. This procedure must have been previously installed using the {\b Hook_Invalid_Page_Fault} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Hook_Invalid_Page_Fault}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_NMI_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 NmiProc
\par VMMcall Unhook_NMI_Event
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancels a Non-Maskable Interrupt (NMI) event procedure that was installed earlier by the {\b Hook_NMI_Event} function. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NmiProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the NMI event procedure to cancel. For more information about the procedure, see {\b NMIEventCallback}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Hook_NMI_Event}, {\b NMIEventCallback}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_PM_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, FaultNo
\par mov     esi, OFFSET32 Hook_Proc
\par VMMCall Unhook_PM_Fault
\par jc      Error_Handler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the hook procedure for the specified protected mode fault. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if successful; sets the carry flag on the following conditions: 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Invalid fault number passed in EAX. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab ESI does not point to a hook procedure. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Hook procedure could not be found. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab A non-hook procedure was found in the chain of procedures. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the fault number. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Hook_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the hook procedure to be removed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The specified hook procedure must have been declared using the {\b BeginProc} macro with the HOOK_PROC attribute in order to generate the necessary header. 
\par {\b BeginProc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_V86_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, FaultNo
\par mov     esi, OFFSET32 Hook_Proc
\par VMMCall Unhook_V86_Fault
\par jc      Error_Handler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the hook procedure for the specified virtual 8086-mode fault. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if successful; sets the carry flag on the following conditions: 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Invalid fault number passed in EAX. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab ESI does not point to a hook procedure. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Hook procedure could not be found. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab A non-hook procedure was found in the chain of procedures. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the fault number. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Hook_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the hook procedure to be removed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The specified hook procedure must have been declared using the {\b BeginProc} macro with the HOOK_PROC attribute in order to generate the necessary header. 
\par {\b BeginProc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_VMM_Fault 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, FaultNo
\par mov     esi, OFFSET32 Hook_Proc
\par VMMCall Unhook_VMM_Fault
\par jc      Error_Handler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the hook procedure for the specified ring 0 fault. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if successful; sets the carry flag on the following conditions: 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Invalid fault number passed in EAX. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab ESI does not point to a hook procedure. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Hook procedure could not be found. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab A non-hook procedure was found in the chain of procedures. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FaultNo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the fault number. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Hook_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the hook procedure to be removed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The specified hook procedure must have been declared using the {\b BeginProc} macro with the HOOK_PROC attribute in order to generate the necessary header. 
\par {\b BeginProc}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 18 Protected-Mode Execution{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 18
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Protected-Mode Execution 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Protected-Mode Execution 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Term \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Definition \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 locked protected mode stack \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
After switching a virtual machine to protected mode, a virtual device must lock into physical memory the protected mode stack used by the virtual machine so the stack won't be removed by demand paging. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 protected mode application control block \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Storage that is a
llocated when a virtual machine enters protected mode. When a virtual machine switches to protected mode, all virtual machines are notified, and one of the pieces of information included in the notification is a pointer to the protected mode application c
ontrol block. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following protected-mode execution services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Allocate_PM_App_CB_Area}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Cur_PM_App_CB}\cell \pard\plain \intbl 
\f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Begin_Use_Locked_PM_Stack}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_PM_Exec_Mode}\cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b End_Use_Locked_PM_Stack}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_V86_Exec_Mode}\cell \pard\plain 
\intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Exec_PM_Int}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Allocate_PM_App_CB_Area 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, Size
\par VMMcall Allocate_PM_App_CB_Area
\par mov     [acb], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Requests that additional space be reserved in the application control block when a virtual machine enters protected mode. This service is only available during initialization. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns, in EAX, the offset from the beginning of the application control block to the memory block reserved by the virtual device. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Size}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of bytes to reserve for the control block. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Use_Locked_PM_Stack 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Begin_Use_Locked_PM_Stack
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Moves the current virtual machine to the protected-mode locked stack. Doing so serves two purposes: It helps ensure that the client stack does not overflow (in case the client was previously on a very small private stack), and it ensures that the memory u
sed by the stack is always available. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the address of the locked stack in Client_SS and Client_SP if the stack was not already locked. Otherwise, these registers remain unchanged. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Before calling this service, the virtual device must ensure that the current virtual machine is running in protected mode. This means the VMStat_PM_Exec value must be specified in the {\b CB_VM_Status}
 field of the control block for the virtual machine. 
\par The {\b Begin_Nest_Exec} service automatically switches to the locked stack if the system determines that the virtual machine should be placed into (or be left in) protected-mode execution. Since most virtual devices rely on the {\b Begin_Nest_Exec}
 service to switch stacks, this service is only useful for virtual devices, such as the virtual PIC device, which explicitly change the execution mode of a virtual machine. 
\par A virtual device can call this service any number of times. Only the first call switches stacks; all subsequent calls increment a counter. If a virtual device locks the stack, it must eventually unlock it using the {\b End_Use_Locked_PM_Stack} service. 

\par For Windows 95, the size of the protected-mode locked stack is 4K bytes. 
\par {\b Begin_Nest_Exec}, {\b End_Use_Locked_PM_Stack}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Use_Locked_PM_Stack 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall End_Use_Locked_PM_Stack
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Unlocks the protected-mode stack. This service decrements the locked-stack counter, and restores the previous stack of the virtual machine if the counter is zero. To unlock the stack, a virtual device must call this service once for each call made to the 
{\b Begin_Use_Locked_PM_Stack} service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns Client_SS, Client_SP, and Client_EIP to the values they had before the Begin_Use_Locked_PM_Stack service was called, if locked-stack counter drops to zero. Otherwise, these registers remain unchanged. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_Use_Locked_PM_Stack}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Exec_PM_Int 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt
\par VMMCall Exec_PM_Int
\par jc      ErrorHandler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates the specified interrupt in a protected mode virtual machine while in nested execution. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Sets the carry flag if an error occurs. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Interrupt to be simulated. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is intended to be used only by the Windows kernel; external virtual devices should not use it. External virtual devices should use the {\b Exec_Int} service instead. 
\par All DOS and BIOS calls that are supported in protected mode programs are supported by this service. 
\par All client registers and flags modified by the interrupt will be changed in the client virtual machine. 
\par The simulated interrupts will be routed through virtual-device interrupt hooks; however, they will bypass any hook that the application has installed in protected mode. 
\par If the service is called within a must-complete section and a fatal error occurs, the carry flag is set and the client registers are left in an unknown state. 
\par {\b Exec_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Cur_PM_App_CB 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par VMMcall Get_Cur_PM_App_CB
\par mov     [ControlBlock], edi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves a pointer to the application control block for a protected-mode application. Uses EDI. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the address of the application control block in EDI. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine in which the protected-mode application is running. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 It is an error to call this service if the virtual machine is not running a protected-mode application. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_PM_Exec_Mode 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Set_PM_Exec_Mode
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Forces the current virtual machine into protected mode. If the current virtual machine is already in protected mode, this service has no effect. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Whenever possible, a virtual device should use the {\b Begin_Nest_Exec} service instead of this service. 
\par Changing the execution mode of a virtual machine does not change the virtual machine's EAX, EBX, ECX, EDX, ESI, EDI, and EBP registers or most flags. The VM flag and IOPL flags change. The DS, ES, FS, GS, SS, ESP, CS, and EIP registers are restored to the
 previous values for V86 mode. 
\par {\b Begin_Nest_Exec}, {\b Set_V86_Exec_Mode}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_V86_Exec_Mode 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Set_V86_Exec_Mode
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Forces the current virtual machine into V86 mode. If the current virtual machine is already in V86 mode, this service has no effect. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Whenever possible, a virtual device should use the {\b Begin_Nest_V86_Exec} service instead of this service. 
\par Changing the execution mode of a virtual machine does not change the virtual machine's EAX, EBX, ECX, EDX, ESI, EDI, and EBP registers or most fl
ags. The VM flag and IOPL flags change. The DS, ES, FS, GS, SS, ESP, CS, and EIP registers are restored to the previous values for V86 mode. 
\par {\b Begin_Nest_V86_Exec}, {\b Set_PM_Exec_Mode}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 19 Registry{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 19
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Registry 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About the Registry 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following registry services: 
\par {\b 
_GetRegistryKey _GetRegistryPath _RegCreateDynKey _RegCloseKey _RegCreateKey _RegDeleteKey _RegDeleteValue _RegEnumKey _RegEnumValue _RegFlushKey _RegOpenKey _RegQueryInfoKey _RegQueryMultipleValues _RegQueryValue _RegQueryValueEx _RegRemapPreDefKey _RegS
etValue _RegSetValueEx}
\par Note that the registry is read-only when the processor is in real mode. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetRegistryKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 #include <vmmreg.h>
\par 
\par _GetRegistryKey(DWORD dwType, LPSTR lpszDeviceName, 
\par                 DWORD dwFlags, LPHKEY lphDevKey);\tab 
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets a registry key handle for the given device name under the branch of the registry tree specified by the {\i dwType} parameter. Uses C calling convention. Caller should use {\b _RegCloseKey}
 to close the returned HKEY. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function was successful. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_INVALID_PARAMETER \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
ERROR_FILE_NOT_FOUND \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwType} 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Defines the registry branch for the key. Must be REGTYPE_CLASS, REGTYPE_VXD or REGTYPE_ENUM. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszDevName }
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of null terminated string specifying device name. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwFlags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Flags for the registry. Must be either REGKEY_OPEN or REGKEY_CREATE_IFNOTEXIST. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lphKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the buffer that receives the HKEY. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetRegistryPath 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetRegistryPath, <OFFSET32 ThisDDB, OFFSET32 UserBuff,
\par     UserBuffSize>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the path to the registry location where information about a VxD is stored. This service is available only during initialization. Uses C calling convention. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns, in EAX, the length of the string copied to UserBuff if the function succeeds. If UserBuff is too small, EAX contains the required size of the buffer. If the service fails, the return value is zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThisDDB}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the descriptor block ({\b VxD_Desc_Block}) for the virtual device. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i UserBuff}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the buffer that receives the registry path. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i UserBuffSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size, in bytes, of the buffer pointed to by {\i UserBuff}. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegCloseKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegCloseKey(HKEY hkey)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Closes a previously opened key. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the key to close. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The handle for the given key should not be used after it has been closed, because it will no longer be valid. Key handles should not be left open any longer than necessary. 
\par {\b _RegOpenKey}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegCreateDynKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par RegCreateDynKey(LPSTR lpszName, LPVOID KeyContext, PPROVIDER pInfo,
\par     PPVALUE pValList, DWORD dwNumVals, HKEY FAR * pKeyHandle);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates the specified registry key under HKEY_DYN_DATA. Values under HKEY_DYN_DATA are maintained by the VxDs that create them. The VMM will call the appropriat
e VxD's enumeration entrypoint when a value is enumerated or queried. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
$Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_ACCESS_DENIED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_INSUFFICIENT_MEMORY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_CANNOT_OPEN_REGFILE \cell \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGFILE_READERROR \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGFILE_WRITEERROR \cell 
\cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGKEY_INVALIDKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 
\f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the key to create: 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i KeyContext}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Four bytes of context that will be passed to the owning VxD when its enumeration entrypoint is called. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pInfo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b PROVIDER} structure (see vmmreg.h) that specifies the enumeration entrypoints for a key. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pValList}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an array of {\b PVALUE} structures (see vmmreg.h) that specify the value names and other attributes for the values under {\i lpszName}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwNumVals}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of {\b PVALUE} structures in the {\i pValList} array. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pKeyHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the variable to receive the handle of the newly created key, {\i lpszName}. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegCreateKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegCreateKey(HKEY hkey, LPTSTR lpszSubKey, PHKEY phkResult)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates the specified key or opens the key if it already exists in the registry.Caller should use {\b RegCloseKey}
 to close the returned key. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_OUTOFMEMORY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the open key or one of the predefined keys:: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG 
\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszSubKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of null-terminated string specifying the name of a key that this service creates or opens. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i phkResult}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Points to a variable that receives the handle of the opened or created key. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The key addressed by {\i lpszSubKey} must be a subkey of the key identified by hkey. 
\par The key referenced by {\i hkey} cannot have HKEY_DYN_DATA as an ancestor (see {\b RegCreateDynKey}). 
\par The {\i lpszSubKey} parameter cannot be NULL unless {\i hkey} is one of the predefined keys. 
\par This service can be used to create keys several levels deep by specifying a subkey string with several keys separated by backslashes. 
\par Of the predefined key values, only HKEY_LOCAL_MACHINE is available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par {\b _RegDeleteKey}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegDeleteKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegDeleteKey(HKEY hkey, LPTSTR lpszSubKey)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Deletes the specified key. Do not use this service to delete a key that has subkeys. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_FILE_NOT_FOUND \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszSubKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of null-terminated string specifying the name of the key to delete. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE is available to VxDs during VxD initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par {\b _RegCreateKey}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegDeleteValue 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegDeleteValue(HKEY hkey, LPTSTR lpszValue)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes a named value from the given registry key. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns ERROR_SUCCESS if the function succ
eeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_FILE_NOT_FOUND \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG 
\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszValue}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of null-terminated string that contains the name of the value to remove. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 

\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegEnumKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegEnumKey(HKEY hkey, DWORD iSubKey, LPTSTR lpszName, DWORD cchName)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Enumerates subkeys of the given open registry key; retrieves the name of one subkey each time the service is called. See the documentation for the Win32 function of the same name for additional information. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_NO_MORE_ITEMS \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_MORE_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i iSubKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Index of subkey to be retrieved; should be zero for the first call to this service and incremented for each subsequent call 
\par Because subkeys are not ordered, any new subkey will have an arbitrary index. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of buffer that receives the subkey name, including terminating null character. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i cchName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size in bytes of buffer; should include space for terminating null character. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 To retrieve the index of the last subkey, use {\b RegQueryInfoKey} or increment {\i iSubKey} until ERROR_NO_MORE_ITEMS is returned. 
\par Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par The caller should reinitialize the variable containing the buffer size on each subsequent call to this service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegEnumValue 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegEnumValue(HKEY hkey, DWORD iValue, LPTSTR lpszValue, 
\par     LPDWORD lpcchValue, LPDWORD lpdwReserved, LPDWORD lpdwType, 
\par     LPBYTE lpbData, LPDWORD lpcbData)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Enumerates values for the given open registry key; the service copies one indexed value name and data block for the key each time it is called. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_NO_MORE_ITEMS \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_MORE_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i iValue}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Index of the value to retrieve; should be zero for first call to this service and then incremented for each subsequent call. Because values are not ordered, any new value will have an arbitrary index. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszValue}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of buffer that receives name of the value, including the terminating null character. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcchValue}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that specifies the length of the buffer in bytes, including the terminating null character. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpdwReserved}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved; must be NULL. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpdwType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that receives the type code for the value entry. It can be one of these standard values or other value (which is treated like REG_BINARY): 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 REG_BINARY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Binary data in any form. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 REG_SZ \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A null-terminated UNICODE or ANSI string. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 This parameter can be NULL if the type code is not required. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpbData }
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that receives the data for the value entry. This parameter can be NULL if the data is not required. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcbData }
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that specifies the size, in bytes, of the buffer pointed to by lpbData. When the service returns, the variable contains the number of bytes stored in the buffer. 
\par This parameter can be NULL only if {\i lpbData} is NULL. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 

\par The caller should reinitialize the variable containing the buffer size on each subsequent call to this service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegFlushKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegFlushKey(HKEY hkey)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The specified key is written to the registry file on the disk. This service should be avoided for performance reasons. Windows will automatically flush the registry to the disk. See the documentation for the Win32 function of the same name for additional 
information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_OUTOFMEMORY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG 
\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE is available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegOpenKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegOpenKey(HKEY hkey, LPTSTR lpszSubKey, PHKEY phkResult)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Opens the specified key. Caller should use {\b RegCloseKey} to close the returned key. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns ERROR_SUCCE
SS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_FILE_NOT_FOUND \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_OUTOFMEMORY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszSubKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string containing the name of the key to open. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i phkResult}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that receives handle of opened key. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The key opened by this service is a subkey of the key which {\i hkey} identifies. 
\par If {\i lpszSubKey} is NULL or a pointer to an empty string, the service returns {\i hkey}. 
\par Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par {\b _RegCloseKey}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegQueryInfoKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par DWORD _RegQueryInfoKey(HKEY hKey, LPTSTR lpszClass,
\par     LPDWORD lpcchClass, LPDWORD lpdwReserved, LPDWORD lpcSubKeys, 
\par     LPDWORD lpcchMaxSubKey, LPDWORD lpcchMaxClass, LPDWORD lpcValues,
\par     LPDWORD lpcchMaxValueName, LPDWORD lpcbMaxValueData, 
\par     LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves information about a specified registry key. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszClass }
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a buffer that receives the key's class name. Currently, this parameter is not supported. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcchClass}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size of the buffer pointed to by the {\i lpszClass} parameter on input and length of string returned in {\i lpszClass }on output. Currently, this parameter is not supported. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpdwReserved}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved, must be NULL. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcSubKeys}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the buffer that receives the number of subkeys contained by the specified key. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcchMaxSubKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a variable that receives the length of the key's subkey with the longest name. The count returned does not include the terminating null character. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcchMaxClass}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a variable that receives the length of the longest string specifying a subkey class. Currently, this parameter is not supported. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcValues}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a variable that receives the number of values associated with the key. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcchMaxValueName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a variable that receives the length of the key's longest value name. The count returned does not include the terminating null character. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcbMaxValueData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a variable that receives the length of the longest data component among the key's values. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcbSecurityDescriptor}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a variable that receives the length of the key's security descriptor. Currently, this parameter is not supported. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpftLastWriteTime}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that receives a {\b FILETIME} structure, indicating the last time the key or any of its value entries was modified. Currently, this parameter is not supported. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 

\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegQueryMultipleValues 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par DWORD _RegQueryMultipleValues(HKEY hKey, PVALENT pValent, 
\par     DWORD dwNumVals, LPSTR lpValueBuf, LPDWORD lpTotSize) 
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the values for the names specified in the {\i pValent} parameter for the specified key in the registry. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_MORE_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pValent }
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Array of {\b VALENT} structures specifying value names to retrieve values for. The {\b VALENT }structure has the following format: 
\par \pard\plain \s55\li280\sl-220\slmult1\tx670\tx1060\tx1450\tx1840\tx2230\tx2620\tx3010\tx3400\tx3790\tx4180\tx4570\tx4960\tx5350\tx5740\tx6130\tx6520\tx6910 \f31\fs16 typedef struct value_ent \{
\par     PCHAR ve_valuename;
\par     DWORD ve_valuelen;
\par     DWORD ve_valueptr;
\par     DWORD ve_type;
\par \} VALENT;
\par 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwNumVals}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of {\b VALENT} structures in the {\i pValent} array. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpValueBuf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a buffer that receives the value data. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpTotSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of bytes in the {\i lpValueBuf }parameter. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b RegQueryMultipleValues }is useful for dynamic key providers because it assures consistency of data b
y retrieving multiple values in an atomic operation. For all keys, this service, is more efficient than calling {\b RegQueryValue} multiple times, particularly across a network since it can retrieve the values with one network transaction. 
\par Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegQueryValue 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegQueryValue(HKEY hkey, LPTSTR lpszSubKey, LPTSTR lpszValue, 
\par     PLONG pcbValue)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the value associated with the unnamed value for a specified key in the registry. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_MORE_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszSubKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of string that contains name of the subkey of the {\i hkey }parameter for which a value is to be retrieved. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszValue}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of string that contains name of the subkey of the {\i hkey }parameter for which a value is to be retrieved. If this parameter is NULL and {\i pcbValue}
 is not NULL this service returns ERROR_SUCCESS and returns the size of the buffer needed the variable pointed to by {\i pcbValue}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pcbValue}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable specifying the size, in bytes, of the {\i lpszValue }
buffer. The buffer should be big enough to contain the terminating null character. On return, the variable contains the size of the data copied to the buffer. If the passed in size is not big enough, the variable will contain the size needed and ERROR_MOR
E_DATA will be returned. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 

\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegQueryValueEx 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegQueryValueEx(HKEY hkey, LPTSTR lpszValueName, 
\par     LPDWORD lpdwReserved, LPDWORD lpdwType, LPBYTE lpbData, 
\par     LPDWORD lpcbData)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the type and data for a specified value name associated with an open registry key. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_MORE_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_FILE_NOT_FOUND \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszValueName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Points to a null-terminated string containing the name of the value to be queried. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpdwReserved}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved; must be NULL. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpdwType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that receives the type code for the value entry. This parameter can be NULL if the type is not required. The type can be any value or one of the standard values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 REG_BINARY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Binary data in any form. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 REG_SZ \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A null-terminated UNICODE or ANSI string. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpbData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of buffer that receives the data for the value entry. This parameter can be NULL if the data is not required. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcbData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that specifies size, in bytes, of the buffer addressed by lpbData. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 

\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegRemapPreDefKey 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par DWORD _RegRemapPreDefKey(HKEY hKey, HKEY hkRootKey)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Changes the current predefined {\i hkRootKey} to point to the given open key, specified by {\i hKey}
. This operation is only allowed on HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG. This service is intended for use by the system and is not for general use by drivers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A previously opened key. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkRootKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 One of HKEY_CURRENT_USER or HKEY_CURRENT_CONFIG. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This function invalidates all open handles opened through the previous HKEY_CURRENT_USER or HKEY_CURRENT_CONFIG. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegSetValue 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegSetValue(HKEY hkey, LPTSTR lpszSubKey, DWORD fdwType, 
\par     LPTSTR lpszData, DWORD cbData)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Associates a value with the specified key; this value is of type REG_SZ and does not have a value name. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_FILE_NOT_FOUND \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an open key or one of the predefined keys: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG 
\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszSubKey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of null-terminated string that contains the name of the subkey of the {\i hkey }
parameter for which the value is associated. If this is an empty string, the value will be associated with the key identified by the {\i hkey} parameter. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i fdwType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Type of information to be stored. Must be REG_SZ. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of null-terminated string containing value to set for the given key. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i cbData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Length in bytes of string at which {\i lpszData} points, not including the terminating null character. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the key specified by {\i lpszSubKey} does not exist, this service will create it. 
\par Value lengths are limited by available memory. Long values (more than 2048 bytes) should be stored as files with the filenames stored in the registry. 
\par Of the predefined key values, only HKEY_LOCAL_MACHINE is available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _RegSetValueEx 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par LONG _RegSetValueEx(HKEY hkey, LPTSTR lpszValueName, 
\par     DWORD dwReserved, DWORD fdwType, LPBYTE lpbDta, DWORD cbData)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Stores data in the value field of an open registry key; the service can also set additional value and type information for the given key. See the documentation for the Win32 function of the same name for additional information. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns ERROR_SUCCESS if the function succeeds. Otherwise, an error code is returned, possibly one of the following: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_OUTOFMEMORY \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_CORRUPT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
ERROR_BADDB \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hkey}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the open key or one of these predefined values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpszValueName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Points to a null-terminated string containing the name of the value to set. If a value with this name is not already present in the key, the function adds it to the key. If this parameter is NULL or points to an empty string, the {\i fdwType}
 must be REG_SZ and this service will set the same value as {\b RegSetValue}. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpdwReserved}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved; must be NULL. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i fdwType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The type code for the value entry. It can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 REG_BINARY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Binary data in any form. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 REG_SZ \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A null-terminated UNICODE or ANSI string. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpbData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of buffer that receives the data for the value entry. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i lpcbData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of variable that specifies size, in bytes, of the buffer addressed by lpbData. If the type is REG_SZ this must include the terminating null character. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the key specified by {\i lpszSubKey} does not exist, this service will create it. 
\par Value lengths are limited by available memory. Long values (more than 2048 bytes) should be stored as files witht the filenames stored in the registry. 
\par Of the predefined key values, only HKEY_LOCAL_MACHINE is available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Return Values for Registry Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following list of error values is not comprehensive. It is included here to give 
you an idea of the kinds of errors to expect. Future versions of Windows may return new error codes, or return slightly different error codes under analogous circumstances. 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_SUCCESS \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The function was successful. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_NO_MORE_ITEMS \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 There are no more keys or values to enumerate. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_MORE_DATA \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Passed in buffer is not large enough to hold the entire value. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_FILE_NOT_FOUND \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The specified key was not found in the registry database. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_KEY_DELETED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY passed to service
 has been deleted since it was opened. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_CANTOPEN ERROR_CANTREAD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Aliases of ERROR_FILE_NOT_FOUND for 16 bit code. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_ACCESS_DENIED \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Attempt to write to a key for which code does not have write access. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_OUTOFMEMORY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Insufficient memory to open the registry key or insufficient memory to load the required data from the registry file. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following may be returned when calling the registry services incorrectly: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADKEY \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The subkey string contains an invalid character or the handle id
entifying the key is invalid. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_LOCK_FAILED \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Registry reentered while blocked by same process. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
ERROR_INVALID_PARAMETER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Parameter is required and not specified, an invalid pointer or otherwise not valid. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following indicate a system problem. The system contains procedures for recovering from these errors, mostly involving rebooting: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_BADDB ERROR_REGISTRY_CORRUPT \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Registry data structures corrupt. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ERROR_REGISTRY_IO_FAILED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The registry file cannot be found or it was already opened by another application. A full disk or problem reading or writing to the disk may also cause this error. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When an HKEY is specified as an input parameter, it must be an HKEY returned from one of the registry services or one of the following predefined keys: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CLASSES_ROOT \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 HKEY_CURRENT_USER \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_LOCAL_MACHINE \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_USERS \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_CURRENT_CONFIG \cell \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HKEY_DYN_DATA \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Of the predefined key values, only HKEY_LOCAL_MACHINE and HKEY_DYN_DATA are available to VxDs during initialization time. The entire registry space can only be accessed after VxD initialization is complete. 

\par The key names are in OEM character set with some variations. Prior to completion of VxD initialization, all key names referenced must not contain any characters in the extended character set (character whose value is greater than 127). After VxD initializ
ation, the entire character set is available. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 20 Selector Management{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 20
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Selector Management 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Selector Management 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A selector identifies a protected-mode segment. The VMM provides services for creating and destroying selectors, and for converting between selector:offset and flat addresses. Because virtual devices use a flat memory model, these services are used primar
ily to share memory with 16-bit protected mode applications. 
\par Each segment has a base linear address,
 limit, and specific permissions. The limit (size) is measured either in bytes or pages depending on the segment's granularity. The properties of a segment are contained in a hardware-defined data structure called a segment descriptor. 
\par Segment descriptors are contained in two arrays called the global descriptor table (GDT) and the local descriptor table (LDT). There is only one GDT, whereas there is a different LDT for each protected mode virtual machine (VM). If bit 2 (value 4) of a se
lector is zero, the selector is an index into the GDT; otherwise it is an index into the current LDT. 
\par Virtual devices should not modify the GDT or LDT directly. To define a new segment, use the {\b _Allocate_GDT_Selector} or {\b _Allocate_LDT_Selector} service. You can modify a segment descriptor by using the {\b _SetDescriptor}
 service. For example, you might allocate multiple selectors and then use the {\b _SetDescriptor} service to change the base address and limit associated with all but the first selector. You can retrieve the descriptor as
sociated with a selector by using the {\b _GetDescriptor} service. To free a selector, use the {\b _Free_GDT_Selector} or {\b _Free_LDT_Selector} service. 
\par A segment descriptor is a 64-bit structure consisting of several bit fields. You can use the {\b _BuildDescriptorDWORDs}
 service to initialize a selector, rather than performing the necessary bit field operations yourself. You can use the return value of this service when you allocate or change a descriptor. 
\par You can give an application read-only access to system data without allocating a selector. The {\b _GetAppFlatDSAlias}
 service returns a selector that maps the entire linear address space. The selector has read-only access to ensure system integrity. To give an application read-write access to system data, you should allocate a selector with an appropriate base address a
nd limit. 
\par A virtual device can convert a selector:offset address to a flat linear address by using the {\b _SelectorMapFlat} service. 
\par See also {\b _GetAppFlatDSAlias}, {\b _GetDescriptor}, {\b _SelectorMapFlat}, {\b _SetDescriptor}, {\b _Allocate_GDT_Selector}, {\b _Allocate_LDT_Selector}, {\b _BuildDescriptorDWORDs}, {\b _Free_GDT_Selector}, {\b _Free_LDT_Selector}
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Selector Allocation Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Allocate_GDT_Selector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Allocate_GDT_Selector, <DescDWORD1, DescDWORD2, flags>
\par 
\par mov     ecx, eax                    ; zero in eax and edx if error
\par or      ecx, edx
\par jz      error
\par 
\par mov     [Selector], eax             ; new selector
\par mov     word ptr [GDTSel], dx       ; selector for the GDT
\par ror     edx, 10h
\par mov     word ptr [SelCount], dx     ; number of selectors in GDT
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates a new selector and adds it to the Global Descriptor Table (GDT). Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the following values in the EAX and EDX registers if successful: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Contains the new selector. \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Contains the selector for and the size of the GDT. The low 16 bits contains the selector for the GDT, and the high 16 bits contains the size of the GDT expressed as the number of selectors in the table. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 The service returns zero in both registers if an error occurs. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DescDWORD1}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 High-order doubleword of the segment descriptor. This parameter contains the high 16 bits of the base address, the high 4 bits of the limit, and the status and type bits. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DescDWORD2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Low-order doubleword of the segment descriptor. This parameter contains the low 16 bits of the base address and limit. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Although this service returns the selector for the GDT, virtual devices should {\i not} attempt to edit the GDT directly. Virtual devices can instead use the {\b _SetDescriptor}
 service to change selectors in the GDT. 
\par Virtual devices should use the {\b _BuildDescriptorDWORDs} service to set the {\i DescDWORD1} and {\i DescDWORD2} parameters to the appropriate values. 
\par This service sets the RPL of the selector to the DPL of the selector set in the {\i DescDWORD1} parameter. 
\par {\b _Allocate_LDT_Selector}, {\b _Free_GDT_Selector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Allocate_LDT_Selector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Allocate_LDT_Selector, <VM, DescDWORD1, DescDWORD2, 
\par     Count, flags>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Creates a new selector or selectors, and adds them to the Local Descriptor Table (LDT) for the specified virtual machine. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the following values in the EAX and EDX registers if successful: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Register \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Contains the new selector. If {\i Count}
 is greater than 1, EAX contains only the first selector. The second selector is EAX+8, the third EAX+16, and so on. The high 16 bits of the selector is always zero. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Contains the selector for and the size of the local descriptor table (LDT). The low 16 bits contains the selector for the LDT, and the high 16 bits contains the size of the LDT expressed as the number of selectors in the table. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 The service returns zero in both registers if an error occurs 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to receive the selectors. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DescDWORD1}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 High-order doubleword of the segment descriptor. This parameter contains the high 16 bits of the base address, the high 4 bits of the limit, and the status and type bits. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DescDWORD2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Low-order doubleword of the segment descriptor. This parameter contains the low 16 bits of the base address and limit. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Count}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of contiguous LDT selectors to allocate if the {\i flags} parameter does {\i not} specify the ALDTSpecSel value. Otherwise, this parameter specifies the LDT selector to allocate. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the operation flags. Can be zero or the following value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ALDTSpecSel \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocates the LDT selector specified by the {\i Count}
 parameter. The service copies the descriptor data to the specified LDT entry and returns the selector. If the LDT selector is already allocated, the service returns an error value instead. 
\par this value is not given, the service allocates the number of selectors specified by {\i Count}. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The service returns an error if an invalid descriptor is specified, the LDT is full, an invalid virtual machine handle is specified, or a selector is already allocated. 
\par Although this service returns a selector for the LDT, virtual devices should {\i not} attempt to edit the LDT directly. A virtual device should use the {\b _SetDescriptor} service to change an LDT selector rather than edit the LDT. 
\par This service sets the RPL of the selector to the DPL of the selector set in the {\i DescDWORD1} parameter. 
\par LDT selectors are only valid when the virtual machine for which they are created is the current virtual machine. However, a virtual device can use the {\b _SelectorMapFlat}
 service to examine the region described by an LDT selector in virtual machines which are not the current virtual machine. 
\par Although this service can create multiple selectors, the {\b _Free_LDT_Selector} service cannot free multiple selectors. Multiple selectors must be freed individually. 
\par When this service creates multiple selectors, it gives each selector the same descriptor values. It does not change the base address for each selector. It is up to the virtual device to edit the selectors, and assign appropriate base addresses. 
\par Virtual devices should not rely on specific hard-coded LDT selectors, and therefore, they should avoid using the ALDTSpecSel value. 
\par {\b _Allocate_GDT_Selector}, {\b _Free_LDT_Selector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _BuildDescriptorDWORDs 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _BuildDescriptorDWORDs, <DESCBase, DESCLimit, DESCType, DESCSize, flags>
\par 
\par mov     [DescDWORD1], edx       ; high doubleword of descriptor
\par mov     [DescDWORD2], eax       ; low doubleword of descriptor
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Builds the descriptor parameter used in calls to the {\b _Allocate_GDT_Selector} and {\b _Allocate_LDT_Selector} services. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the low-order doubleword of the segment descriptor in the EAX register and the high-order doubleword in the EDX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DESCBase}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 32-bit value specifying the segment's linear base address. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DESCLimit}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 20-bit value specifying the segment limit. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DESCType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Present bit, DPL, and type fields for the descriptor (bits 8\endash 15 of the high doubleword). All bits except bits 0 \endash  7 of this parameter must be zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DESCSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Granularity and big/default fields for the descriptor (bits 20\endash 23 of the high doubleword). All bits except bits 4 \endash  7 of this parameter must be zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or the following value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BDDExplicitDPL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Uses the DPL bits in the {\i DESCType}
 parameters. If this value is not given, the service sets the DPL bits to be equal to the RPL bits for protected-mode applications. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Virtual devices must not rely on the privilege level at which protected-mode applications run. When creating selectors for protected-mode applications, a virtual device should not specify the BDDExplicitDPL value. This provides a convenient way to build d
escriptors without knowing the protection level for protected-mode applications. 
\par {\b _Allocate_GDT_Selector}, {\b _Allocate_LDT_Selector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Free_GDT_Selector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Free_GDT_Selector, <Selector, flags>
\par 
\par or      eax, eax            ; nonzero if freed, zero if error
\par jz      not_freed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees a GDT selector previously allocated using the {\b _Allocate_GDT_Selector} service. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Selector}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Selector to free. The selector must have been previously created using the {\b _Allocate_GDT_Selector} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Certain system selectors cannot be freed since they are required for Windows operation. (Remember, free only those selectors created by calling {\b _Allocate_GDT_Selector}
.) This service ignores the RPL bits of the selector. 
\par {\b _Allocate_GDT_Selector}, {\b _Free_LDT_Selector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Free_LDT_Selector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Free_LDT_Selector, <VM, Selector, flags>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees a LDT selector previously allocated using the {\b _Allocate_LDT_Selector} service. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to which the selector belongs. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Selector}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Selector to free. The selector must have been previously created using the {\b _Allocate_LDT_Selector} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service ignores the RPL bits of the selector. 
\par {\b _Allocate_LDT_Selector}, {\b _Free_GDT_Selector}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Miscellaneous Selector Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetAppFlatDSAlias 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetAppFlatDSAlias
\par 
\par mov     [FlatData], eax         ; read-only GDT selector
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Returns a ring-3, read-only, GDT selector that provides access to the same memory as the system's ring-0 data segment selector. Virtual devices use this service to support protected-mode APIs that let protected-mode applications read from the same memory 
as the virtual device. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the selector in the EAX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Since more than one virtual device may use this selector, a virtual device must {\i never} attempt to free the selector using the {\b _Free_GDT_Selector}
 service. Also, a virtual device should not attempt to create a read/write selector using this selector. If a virtual device requires an application to write to any portion of system memory, the virtual device should build its own selector with a base and
 limit that specifies just the memory the application must modify. 
\par {\b _Free_GDT_Selector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetDescriptor 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetDescriptor, <Selector, VM, flags>
\par 
\par mov     ecx, eax                ; zero in eax and edx if error
\par or      ecx, edx
\par jz      error
\par 
\par mov     [DescDWORD1], edx       ; high doubleword of descriptor
\par mov     [DescDWORD2], eax       ; low doubleword of descriptor
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves a copy of the descriptor associated with the given LDT or GDT selector. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the low-order doubleword of the descriptor in the EAX register and the high-order doubleword in the EDX register. Both registers contain zero if an error occurs. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Selector}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 GDT or LDT selector. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to which the specified LDT selector belongs. This parameter is ignored if the {\i Selector} parameter is a GDT selector. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service ignores the high 16-bits of the {\i Selector} parameter; the 80386 CPU often sets these bits to random values when doubleword operations are performed on segment registers. 
\par This service ignores the RPL bits of the selector. 
\par {\b _BuildDescriptorDWORDs}, {\b _SetDescriptor}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _SelectorMapFlat 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _SelectorMapFlat, <VM, Selector, flags>
\par 
\par cmp     eax, 0FFFFFFFFh         ; 0FFFFFFFFh if error
\par je      error
\par mov     [Address], eax          ; base address of selector
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the base linear address of segment identified by the specified GDT or LDT selector. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the base linear address in the EAX register if successful, 0FFFFFFFFh otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to which the specified selector belongs. This parameter is not used if {\i Selector} is a GDT selector. This parameter must be valid for LDT selectors. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Selector}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 GDT or LDT selector. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The address mapper uses this service to convert pointers, consisting of selector and offset pairs, to flat-model linear addresses suitable for use as parameters for the {\b _LinMapIntoV86} service. 
\par This service ignores the high 16 bits of the {\i Selector} parameter; the 80386 CPU often sets these bits to somewhat random values when doubleword operations are performed on segment registers. 
\par {\b _LinMapIntoV86}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _SetDescriptor 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _SetDescriptor, <Selector, VM, DescDWORD1, DescDWORD2, flags>
\par 
\par or      eax, eax        ; nonzero if set, zero if error
\par jz      not_set
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets (changes) the descriptor associated with the given selector. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Selector}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 GDT or LDT selector to set. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to which the specified LDT selector belongs. This parameter is ignored if the {\i Selector} parameter is a GDT selector. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DescDWORD1}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 High-order doubleword of the new segment descriptor. This parameter contains the high 16 bits of the base address, the high 4 bits of the limit, and the status and type bits. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DescDWORD2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Low-order doubleword of the new segment descriptor. This parameter contains the low 16 bits of the base address and limit. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service ignores the high 16-bits of the {\i Selector} parameter; the 80386 CPU often sets these bits to random values when doubleword operations are performed on segment registers. 
\par The service ignores the RPL bits of the selector. 
\par {\b _GetDescriptor}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 21 String Management{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 21
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 String Management 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About String Management 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following string management services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _lmemcpy}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Performs a forward memory move. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _lstrcmpi}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Compares two strings. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _lstrcpyn}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Copies a string into a buffer. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _lstrlen}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Determines the length of a string. \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _lstrupr}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Converts lowercase characters in a string to uppercase. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _lmemcpy 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par cld
\par VMMcall _lmemcpy, <OFFSET32 pvDst, OFFSET32 pvSrc, dwNumBytes>
\par mov     OFFSET32 pBuf, eax
\par mov     OFFSET32 pEndBuf, edx
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Performs a forward memory move. Unlike the KERNEL function of a similar name, this service does not support backward memory moves. If the source and destination buffers overlap, the results of this service are undefined. Uses the C calling convention. Use
s EAX, ECX, EDX, and Flags. The direction flag must be clear. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the address of the beginning of the destination buffer in EAX, and the address of the end of the buffer in EDX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pvDst}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the destination buffer. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pvSrc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the source buffer. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwNumBytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of bytes to move to the destination buffer. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Note that the VxD that calls this service is responsible for enabling or disabling interrupts as appropriate. Interrupts must be disabled if atomicity is desired, enabled if pageable data is involved. 
\par No validation is done on any of the parameters of this service. 
\par This is an asynchronous service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _lstrcmpi 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _lstrcmpi, <OFFSET32 pString1, OFFSET32 pString2>
\par cmp     eax, 0
\par je      strings_equal
\par jg      string1_greater
\par jl      string2_greater
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Compares two strings by checking the first characters against each other, the second characters against each other, and so on, until it finds an inequality or reaches the ends of the strings. The service returns a value based on the result of the last com
parison. For example, {\b _lstrcmpi} determines that "abcz" is greater than "abcdefg" and returns a positive number. Uses the C calling convention. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns zero in EAX if the two strings are equal, a positive value if pString1 is greater that pString2, and a negative value if pString1 is less than pString2. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pString1}, {\i pString2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Addresses of the strings to compare. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 With a double-byte character set (DBCS) version of Windows, this service can compare two DBCS strings. 
\par Unlike some other string functions, this service resides in pageable memory. It must only be called when pageable code can be executed. 
\par Until the INIT_COMPLETE phase of VxD initialization, this service will not correctly convert case for non-US English languages. A VxD should delay all calls to this function until the INIT_COMPLETE phase of VxD initialization. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _lstrcpyn 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par cld
\par VMMcall _lstrcpyn, <OFFSET32 pszDst, OFFSET32 pszSrc, dwBufSize> 
\par mov     pszDst, eax
\par mov     cbUnused, ecx
\par mov     pszNull, edx
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Copies a zero-terminated ASCII string to a sized buffer. Uses the C calling convention. Uses EAX, ECX, EDX, and Flags. The direction flag must be clear. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the following information: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Address of the destination buffer. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Number of unused bytes in the buffer, not including the terminating null character. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Address of the terminating null byte in the destination buffer. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pszDst}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of destination buffer. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pszSrc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of source buffer. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i dwBufSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size, in bytes, of the destination buffer. Set this parameter to \endash  1 if the size is unlimited. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the destination buffer is larger than the source string, the unused portion of the buffer is not padded with null characters. If the destination buffer is smaller than the source string ({\i dwBufSize}
 - 1), characters from the source string are copied, followed by a (premature) terminating null character. If {\i dwBufSize} is set to zero, no bytes are copied to the destination buffer. 
\par Setting {\i pszSrc} to zero is equivalent to specifying a null source string. This service accesses only bytes from {\i pszSrc}
 that are copied. If the destination buffer fills before the end of the source buffer is reached, the remaining bytes of the source buffer are not accessed. 
\par The source and destination buffers must not overlap. This is an asynchronous service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _lstrlen 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _lstrlen, <OFFSET32 psz>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines the length of a null-terminated ASCII string. The length does not include the terminating null character. 
Uses the C calling convention. Uses EAX, ECX, EDX, and Flags. The direction flag must be clear. 
\par  Returns the following information: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Length, in bytes, of the string. \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Address of the terminating null character, or undefined if {\i psz}
 is NULL. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i psz}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the string. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Setting {\i pszSrc} to zero is equivalent to specifying a null source string. This service will crash if {\i pszSrc} is set to anything other than the address of a null-terminated ASCII string 
\par This is an asynchronous service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _strupr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _strupr, <OFFSET32 psz>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts any lowercase characters in the specified string to uppercase. Uses the C calling convention. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns, in EAX, the address of the converted string. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i psz}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of string to convert. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Unlike some other string functions, this service resides in pageable memory. It must only be called when pageable code can be executed. 
\par Until the INIT_COMPLETE phase of VxD initization, this service will not correctly convert case for non-US English languages. A VxD should delay all calls to this function until the INIT_COMPLETE phase of VxD initialization. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 22 Synchronization{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 22
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Synchronization 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Synchronization 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Terms 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device uses the synchronization services to coordinate the execution of threads and virtual machines. The following terms are related to synchronization: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Term \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Definition \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 block ID \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A programmer-defined 32-bit value associated with one or more blocked threads. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 claim \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A request on the part of a virtual device to enter a critical section. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 claim count \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A system-defined variable that indicates the number of times the owner of a critical section has claimed the section. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 context switch \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The act of turning the CPU's "attention" from one thread to another. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 critical section \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A block of program code that accesses a shared system resource. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 critical section owner \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The thread or virtual m
achine that is currently executing in a critical section. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 must-complete count \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A system-defined variable that indicates the number of times the owner of a must-complete section has claimed the section. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 must-complete section \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A block of code that must be executed in its entirety before any other thread or virtual machine can run. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 mutex \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A synchronization object that ensures only one thread at a time can access a shared resource. A thread must have ownership of the mutex before it can access the resourc
e. The thread blocks if the mutex is owned by another thread. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 reentry count \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A system-defined variable that indicates the number of times the owner of a mutex has called the _{\b EnterMutex} service after gaining ownership. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 semaphore \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
An synchronization object that maintains a token count between zero and some maximum value. The object's state is signaled when its token count is greater than zero, and not-signaled when its count is zero. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 signal \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 To increase the token count of a semaphore. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 semaphore token count \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The value associated with a semaphore. The initial token count is set when the semaphore is created. A signal operation increments the token count, and a wait operation decrements it. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Critical Sections 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A critical section is a section of code that accesses a shared resource. When a virtual machine (VM) is executing code in a critical section, no other VM can execute code within their critical sections. By placing code that accesses shared resources withi
n critical sections, shared resources are protected from simultaneous access by two or more VMs. 
\par It is useful to think of the system as having a single, shared resource called the critical section which can represent any resource critical to the operation of all VMs. Only when a VM owns the critical section can it access the critical resource. 

\par When a VM requests the critical section, it is said to have "claimed" the critical section. A VM that is executing code in the critical section is said to "own" the critical section. The VMM mai
ntains an internal variable, called the claim count, that reflects the number of times the owner has claimed the critical section. Calling {\b Begin_Critical_Section} or {\b Claim_Critical_Section} increments the claim count; calling {\b 
End_Critical_Section}, {\b End_Critical_Section_No_Block}, or {\b Release_Critical_Section}
 decrements it. The owner releases the critical section only when the claim count is zero, allowing another VM to claim ownership. The claim count is not incremented when a VM attempts to claim the critical s
ection while another virtual machine already owns it. 
\par When one VM owns the critical section and a second VM attempts to claim ownership, the system blocks the second VM. Flags specified in the call to {\b Begin_Critical_Section}
 determine how the VM responds to interrupts while it is blocked. You should set the appropriate flags so that the VM processes hardware interrupts in a timely manner. 
\par The system boosts the execution priority of a VM the when it first gains ownership of the critical section. This means that the system switches to another task only if the VM blocks on a semaphore or if a time-critical event occurs in another VM. 
\par While the critical section is owned by any VM, you must not take any action that might cause MS-DOS to be reentered. If MS-DOS is used for paging, such actions include calling memory management services and touching pageable memory. Note that VxD_PAGEABLE
_CODE_SEG and VxD_PAGEABLE_DATA_SEG segments are automatically locked if MS-DOS is used for paging. 
\par A virtual device can request the VMM to notify it when a virtual machine has released the critical section by using the {\b Call_When_Not_Critical}
 service. This service installs a callback function which the VMM calls when the critical section is released. A virtual device typically uses the callback function to perform tasks that the must done only when no virtual machine owns the critical section
. The system removes the callback function after calling it. To remove a callback function before it is called, use the {\b Cancel_Call_When_Not_Critical} service. 
\par The {\b Get_Crit_Section_Status} and {\b Get_Crit_Status_No_Block}
 services retrieve the claim count and the handle of the current owner of the critical section. When a virtual device released the critical section, the system sometimes delays the release while it processes events. {\b Get_Crit_Section_Status}
 allows the system to blocks the current virtual machine, if necessary, while completing any delayed releases. {\b Get_Crit_Status_No_Block}, on the other hand, returns immediately with the claim count and owner handle. {\b Get_Crit_Status_Thread}
 is similar to {\b Get_Crit_Section_Status} except that it retrieves the handle of the thread that owns the critical section, rather than the handle of the virtual machine. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Critical Section Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Critical_Section 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, Flags
\par VMMcall Begin_Critical_Section
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Claims a critical section for the current virtual machine. Only one virtual machine at a time can enter a critical section. If a virtual device calls this service after anoth
er virtual machine has entered a critical section, the system blocks the calling virtual machine until the critical section is released. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Action to take when interrupts occur while the virtual machine is blocked waiting for the critical section. This parameter can be a combination of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Enable_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service interrupts in the virtual machine even if the virtual machine does not currently have interrupts enabled. This forces interrupts to be enabled. This value is only relevant if either Block_Svc_Ints or Block_Svc_If_Ints_Locked is set. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Svc_If_Ints_Locked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service events and simulated interrupts in the virtual machine if the thread blocks for the critical section and the VMStat_V86IntsLocked flag is set. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Block_Svc_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Service events and simulated interrupts in the virtual machine if the thread blocks for the critical section. \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Thread_Idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Consider the thread to be idle if it blocks 
for the critical section. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The Block_Poll value is reserved and must not be used with this service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system maintains a count of claims for critical sections and releases the critical section only when an equal number of {\b Begin_Critical_Section} and {\b End_Critical_Section}
 services have been called. Calling {\b Begin_Critical_Section} before the critical section is released does not increment the claim count. 
\par When the critical section is first claimed, the system boosts the execution priority of the current virtual machine by the Critical_Section_Boost value (as described for the {\b Adjust_Exec_Priority}
 service). While a virtual machine is in a critical section, the system will switch to another task only if the virtual machine blocks on a semaphore or the other task has a time-critical operation, such as simulating hardware interrupts. 
\par {\b Adjust_Exec_Priority}, {\b End_Critical_Section}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_When_Not_Critical 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, CritSecCallback
\par mov     edx, RefData
\par VMMcall Call_When_Not_Critical
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a critical-section callback function. The system calls this function when a virtual device releases the critical section. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CritSecCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. For more information, see {\b CritSecCallback.}
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of reference data to pass to the callback function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system does not execute the callback until the current virtual machine's execution priority is less than the Critical_Section_Boost value even if the current virtual machine is {\i not}
 in a critical section. This allows a virtual device to release the critical section and process any simulated interrupts before the system calls the callback function. 
\par Virtual devices can install any number of callback functions, but the system calls only the most recent function on the list when the critical section is released. The system removes the callback function from the list as it calls the function. This is a 
common point of confusion. Unlike services like {\b Call_When_Task_Switched}, which install a hook permanently, the {\b Call_When_Not_Critical} service removes the callback once it is dispatched. 
\par It is more convenient to use the {\b Call_Priority_VM_Event} service than to call this service directly. 
\par {\b Call_When_Idle}, {\b Call_When_Task_Switched}, {\b CritSecCallback}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Call_When_Not_Critical 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     esi, OFFSET32 CritSecCallback
\par VMMcall Cancel_Call_When_Not_Critical
\par jc     not_removed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Remove references to the specified callback function installed by a previous call to {\b Call_When_Not_Critical}. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if one or more references are removed; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CritSecCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of callback function. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Call_When_Not_Critical}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Claim_Critical_Section 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Claims
\par mov     ecx, Flags
\par VMMcall Claim_Critical_Section
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Increments the claim count by the specified value. It has the same effect as calling the {\b Begin_Critical_Section} service repeatedly. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Claims}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of times to claim the critical section. Zero is a valid number, but is ignored. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Action to take when interrupts occur while the virtual machine is blocked waiting for the critical section. This parameter can be a combination of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Enable_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service interrupts in the virtual machine even if the virtual machine does not currently have interrupts enabled. This forces interrupts to be enabled. This flag is relevant only if either Block_Svc_Ints or Block_Svc_If_Ints_Locked is set. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Svc_If_Ints_Locked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service events and simulated interrupts in the virtual machine if the thread blocks for the critical section and the VMStat_V86IntsLocked flag is set. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Block_Svc_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Service events and simulated interrupts in the virtual machine if the thread blocks for the critical section. \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Thread_Idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Consider the thread to be idle if it blocks for the critical section. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The Block_Poll value is reserved and must not be used with this service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Adjust_Exec_Priority}, {\b Begin_Critical_Section}, {\b End_Critical_Section}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 CritSecCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VMHandle
\par mov     edi, ThreadHandle
\par mov     edx, RefData
\par mov     ebp, OFFSET32 Client_Reg_Struc
\par call    [CritSecCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing when a virtual device releases the critical section. {\b CritSecCallback} is a programmer-defined callback function installed by the {\b Call_When_Not_Critical }
service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data from the virtual device that installed the callback function. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the registers of the current virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The callback function can carry out any operation and can modify the EAX, EBX, ECX, EDX, ESI, EDI, and Flags registers. 
\par {\b Call_When_Not_Critical}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Crit_And_Suspend 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall End_Crit_And_Suspend
\par jc      not_released
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Releases the critical section and immediately suspends the current virtual machine. Virtual devices use this service to block a virtual machine until another virtual machine can process an event. Uses Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if successful, sets it otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service releases the crit
ical section only if the virtual machine has claimed the section once. This service returns an error if the system could not suspend the virtual machine, or could not release the critical section because the claim count was not 1. In such cases, the servi
ce does not decrement the claim count and the critical section is not released. 
\par The following example uses this service to display a dialog box in the system virtual machine. The Show_Dialog_Box function enters a critical section to prevent the {\b Call_Priority_VM_Event}
 service from switching to the system virtual machine immediately. It then calls {\b End_Crit_And_Suspend}
 which blocks the current virtual machine. The Show_Dialog_Event function runs in the system virtual machine and actually displays the dialog box. When it is finished it resumes the virtual machine that called Show_Dialog_Box by calling the {\b Resume_VM}
 service. 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Show_Dialog_Box:
\par     VMMcall Get_Crit_Section_Status
\par     jc      Cant_Do_It                  ; critical section already
\par                                         ; claimed
\par 
\par     VMMcall Begin_Critical_Section
\par     mov     eax, Low_Pri_Device_Boost
\par     VMMcall Get_System_VM_Handle
\par     mov     ecx, 11b
\par     mov     edx, OFFSET32 Dialog_Box_Data_Structure
\par     mov     esi, OFFSET32 Show_Dialog_Event
\par     VMMcall Call_Priority_VM_Event
\par     VMMcall End_Crit_And_Suspend
\par     jc      Did_Not_Work
\par     ; When End_Crit_And_Suspend returns, the dialog box
\par     ; will have been displayed
\par 
\par Show_Dialog_Event:
\par     ; Call Windows to display the dialog box
\par 
\par     mov     ebx, [Suspended_VM_Id]
\par     VMMcall Resume_VM
\par     jc      Error
\par     ret
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b End_Crit_And_Suspend}
 service predates most of the synchronization services provided by Windows 95 and exists primarily for backward compatibility. New virtual devices should avoid this service, since there are better mechanisms available. 
\par {\b End_Critical_Section}, {\b Resume_VM}, {\b Suspend_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Critical_Section 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall End_Critical_Section
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Releases the critical section if the current virtual machine owns the section and the claim count is zero. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This service decrements the claim count and releases the critical section if the new count is zero. Since releasing the critical section lowers the execution priority of the current virtual machine, this service causes a task switch if a nonsuspended virt
ual machine has higher priority. 
\par It is extremely risky for a virtual device to end a critical section it did not enter, or which it entered from a thread other than the current thread. 
\par {\b Begin_Critical_Section}, {\b End_Crit_And_Suspend}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Crit_Section_Status 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Crit_Section_Status
\par 
\par mov     [VMHandle], ebx
\par mov     [Claims], ecx
\par jc      high_priority
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the claim count and owner of the critical section. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the critical section claim count in ECX and the han
dle of the virtual machine owning the critical section in EBX. If ECX is 0, EBX is the handle of the current virtual machine. The carry flag is set if the current virtual machine has an execution priority greater than or equal to Critical_Section_Boost, s
uch as during a hardware interrupt simulation. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Windows 3.1 sometimes delays releasing the critical section until events are processed. This service causes the system to complete any delayed releases before the service returns the status. This may cause a 
task switch if another virtual machine has a delayed release. 
\par If a virtual device must ensure that it owns the critical section to successfully complete an operation, it should call this service to make sure that the critical section status is up to date. 
\par This is not an asynchronous service; it must {\i not} be called at interrupt time. 
\par {\b Get_Crit_Status_No_Block}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Crit_Status_No_Block 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Crit_Status_No_Block
\par 
\par mov     [VMHandle], ebx
\par mov     [Claims], ecx
\par jc      high_priority
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the claim count and handle of the owner of the critical section. Unlike the {\b Get_Crit_Section_Status}
 service, this service returns immediately (without blocking) even if a delayed request to release the critical section is pending. This service is only available for Windows version 3.1 or later. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the critical section claim count in ECX and the handle of the virtual machine owning the critical section EBX. If ECX is 0, EBX is the handle of the cu
rrent virtual machine. The carry flag is set if the current virtual machine has an execution priority greater than or equal to Critical_Section_Boost, such as during a hardware interrupt simulation. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 In some cases, this service may indicate that the critical section is currently owned even when it will be released before returning to the virtual machine. 
\par This is an asynchronous service; it may be called at interrupt time. 
\par {\b End_Critical_Section}, {\b Get_Crit_Section_Status}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Crit_Status_Thread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall Get_Crit_Status_Thread
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the critical-section claim count in ECX and a handle identifying the thread that owns the critical section in EDI. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the critical-section claim count and a handle identifying the thread that owns the critical section. If the claim count is zero, the current thread handle is returned. Sets the carry flag if the thread is in a time-critical operation such as hard
ware interrupt simulation. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service may be called at interrupt time. 
\par This service differs from {\b Get_Crit_Section_Status} and {\b Get_Crit_Status_No_Block} in that it returns a thread handle. 
\par {\b Get_Crit_Section_Status}, {\b Get_Crit_Status_No_Block}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Release_Critical_Section 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, Claims
\par VMMcall Release_Critical_Section
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Decrements the claim count by the specified value. It has the same effect as calling the {\b End_Critical_Section} section repeatedly. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Claims}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of times to release ownership of critical section. Zero is a valid number, but is ignored. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 It is extremely risky for a virtual device to end a critical section it did not enter, or which it entered from a thread other than the current thread. 
\par {\b Claim_Critical_Section}, {\b End_Critical_Section}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Must-Complete Section Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _EnterMustComplete 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 VMMcall _EnterMustComplete
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Increments the must-complete count for the current thread, causing it to enter a must-complete section. Uses the C calling convention. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can call this service recursively. 
\par For each call to _{\b EnterMustComplete}, there must be a corresponding call to _{\b LeaveMustComplete}. 
\par This service ensures that the thread is not suspended or killed (via {\b Suspend_VM} or {\b Nuke_VM}
) by another thread while executing a section of critical code. This service is usually used to protect a thread while it owns an important shared resource or state information. I
f the thread were killed or suspended while it owned such a resource, all other threads would be blocked. 
\par While in a must complete, any suspends or nukes will be postponed until the last {\b _LeaveMustComplete}. A must-complete does not change priorities or thread switching in any way. 
\par A VxD can also enter a must complete section automatically by using the MUTEX_MUST_COMPLETE flag with the {\b _CreateMutex} service. 
\par {\b _EnterMutex}, {\b _LeaveMustComplete}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _ExecIntMustComplete 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt
\par VMMcall _ExecIntMustComplete
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates the specified interrupt, and resumes execution of the virtual machine, causing it to enter a must-complete section. This service may only be called in a nested execution block created using the {\b 
Begin_Nest_Exec} or {\b Begin_Nest_V86_Exec} service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to simulate. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When in a nested execution block, this service can be called any number of times. 
\par This service is comparable to combining the {\b Simulate_Int} and {\b _ResumeExecMustComplete} services. 
\par {\b Begin_Nest_Exec}, {\b Begin_Nest_V86_Exec}, {\b Resume_Exec}, {\b _ResumeExecMustComplete}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _ExecVxDIntMustComplete 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par push dword ptr Interrupt
\par VMMCall _ExecVxDIntMustComplete
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Executes the specified software interrupt. Uses registers and flags modified by the interrupt. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab One or more registers may contain return values depending on the function of the specified interrupt. 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the number of the interrupt to execute. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service should be used with the _{\b EnterMustComplete} service. 
\par The {\b _ExecVxDIntMustComplete} service is similar to the {\b Exec_VxD_Int}
 service with the following exceptions: it may be called within a must-complete section; and if a fatal error occurs while executing the interrupt, this service sets the carry flag leaving the general purpose registers in an unknown state. (The carry flag
 may also be set by the interrupt that is called. A VxD can use the {\b _GetThreadTerminationStatus} service to differentiate between these two cases.) 
\par {\b _EnterMustComplete}, {\b Exec_VxD_Int}, {\b _GetThreadTerminationStatus}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _LeaveMustComplete 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par cCall    _LeaveMustComplete
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Decrements the must-complete count for the calling thread. Uses the C calling convention. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _EnterMustComplete}, {\b _LeaveMutex}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _ResumeExecMustComplete 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _ResumeExecMustComplete
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Executes the current virtual machine immediately, causing it to enter a critical section. This service may only be called in a nested execution block created using the {\b Begin_Nest_Exec} or {\b 
Begin_Nest_V86_Exec} service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be used any number of times in a nested execution block. 
\par This service returns when the virtual machine returns to the same point it was at when {\b Begin_Nest_Exec} was called. 
\par {\b Begin_Nest_Exec}, {\b Begin_Nest_V86_Exec}, {\b _ExecIntMustComplete}, {\b Resume_Exec}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Semaphore Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Create_Semaphore 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, TokenCount
\par VMMcall Create_Semaphore
\par jc      error
\par mov     [Semaphore], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allocates memory for and initializes a new semaphore. Uses EAX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the semaphore handle in EAX and clears the carry flag, if successful; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TokenCount}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Initial count of tokens. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Destroy_Semaphore}, {\b Signal_Semaphore}, {\b Wait_Semaphore}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Destroy_Semaphore 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Semaphore
\par VMMcall Destroy_Semaphore
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Destroys the specified semaphore. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Semaphore}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the semaphore to delete. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Destroying a semaphore while threads are still blocked on it will crash the system. 
\par {\b Create_Semaphore}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Signal_Semaphore 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, SemaphoreHandle
\par VMMcall Signal_Semaphore
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Signals a semaphore, releasing (unblocking) a single thread if there are any threads blocked waiting for the semaphore. The threads are released in order of priority; that is, the highest priority thread is released first even if it has been blocked for t
he shortest time. When signaling the semaphore causes a higher priority thread to be released and the VMM has not been reentered, an immediate context switch to the higher priority thread occurs. This service returns with interrupts enabled. Uses Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SemaphoreHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the semaphore to signal. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Create_Semaphore}, {\b Signal_Semaphore_No_Switch}, {\b Wait_Semaphore}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Signal_Semaphore_No_Switch 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, SemaphoreHandle
\par VMMcall Signal_Semaphore_No_Switch
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Signals a semaphore, releasing (unblocking) a single thread if there are any threads blocked waiting for the semaphore. The threads are released in order of priority; that is, the highest priority thread is released first even if it h
as been blocked for the shortest time. Unlike the {\b Signal_Semaphore}
 service, this service never causes an immediate context switch. Instead any threads that need to be released are released the next time events are serviced. This service also differs in that it preserves the state of processor interrupt mask; that is, if
 interrupts are disabled on entry they are still disabled when this service returns. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SemaphoreHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the semaphore. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Create_Semaphore}, {\b Signal_Semaphore}, {\b Wait_Semaphore}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Wait_Semaphore 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, SemaphoreHandle
\par mov     ecx, Flags
\par VMMcall Wait_Semaphore
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Blocks the current virtual machine until the semaphore is signaled using the {\b Signal_Semaphore} service. Uses Flags 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SemaphoreHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the semaphore on which to wait. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Action to take when interrupts occur while the virtual machine is blocked waiting for the semaphore. This parameter can be a combination of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Enable_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service interrupts in the virtual machine even if the virtual machine does not currently have interrupts enabled. This forces interrupts to be enabled. This value is only relevant if either Block_Svc_Ints or Block_Svc_If_Ints_Locked is set. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Force_Svc_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service events and simulated interrupts in the thread even when the critical section is not available. Be careful when using this flag. If it is used when any VMM or
 real mode MS-DOS resources are held, it will cause deadlocks to occur. If in doubt, do not use this flag. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Poll \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Do not switch away from the blocked virtual machine unless another virtual machine has higher priority. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Svc_If_Ints_Locked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service events and simulated interrupts in the virtual machine even if the thread blocks for the semaphore and the VMStat_V86IntsLocked flag is set. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Block_Svc_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Service events and simulated interrupts in the virtual machine even if the virtual machine i
s blocked. Events are only serviced when the critical section is available or owned by the blocked thread unless the Block_Force_Svc_Ints flag is also set. Then when events are serviced, the critical section is taken and held while they are serviced. This
 is necessary to prevent a deadlock from occurring when an event tries to enter the critical section and blocks while holding system-wide resources. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Thread_Idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Consider the thread idle when it blocks on the semaphore. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service blocks if the semaphore's token count is zero or less. Otherwise, it decrements the token count and returns immediately. If the token count is not zero (meaning the {\b Signal_Semaphore}
 service has been called), {\b Wait_Semaphore} decrements the token count and returns immediately. 
\par {\b Create_Semaphore}, {\b Signal_Semaphore}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Mutex Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _CreateMutex 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par DWORD SERVICE _CreateMutex(LONG Boost, ULONG Flags)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allocates memor
y for and initializes a mutex. The priority boost is stored in the mutex, and is used to boost a thread's priority when it acquires the mutex. When a thread blocks waiting for the mutex it is given one half of the priority boost. Uses EAX, ECX, EDX, and f
lags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a handle identifying the new mutex if the function succeeds; otherwise returns NULL. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Boost}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The amount by which the thread that owns the mutex should be boosted. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Execution options. It can be the following value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MUTEX_MUST_COMPLETE \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A "must-complete" section is entered each time the mutex is entered. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _DestroyMutex 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.h
\par 
\par DWORD SERVICE _DestroyMutex(DWORD hmtx)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees memory allocated for a mutex. The mutex cannot be in use when this function is called. Uses EAX, ECX, EDX, and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a non-zero value if successful; otherwise, returns zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hmtx}
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Handle of mutex that will be destroyed. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _EnterMutex 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall     _EnterMutex, <MutexHandle, Flags>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Enters a mutex. If the mutex is unowned, the calling thread becomes the owner and execution continues. If the mutex is owned by another thread, the calling thread blocks until the mutex is available. If the mutex is already owned by this thread, the reent
ry count is incremented and execution continues. Uses C Calling Convention: Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i MutexHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the mutex. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Action to take when interrupts occur while the virtual machine is blocked for the mutex. This parameter can be a combination of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Enable_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service interrupts in the virtual machine even if the virtual machine does not currently have interrupts enabled. This forces interrupts to be enabled. This value is only relevant if either Block_Svc_Ints or Block_Svc_If_Ints_Locked is set. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Svc_If_Ints_Locked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service events and simulated interrupts in the virtual machine if the thread blocks for the mutex and the VMStat_V86IntsLocked flag is set. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Block_Svc_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Service events and simulated interrupts in the virtual machine if the thread blocks for the mutex. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Thread_Idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Consider the thread to be idle if it blocks for the mutex. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The Block_Poll value is reserved and must not be used with this service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the mutex has a priority boost and the mutex is entered for the first time, the execution priority of the current thread is boosted by the same amount. 
\par {\b _EnterMustComplete}, {\b _LeaveMutex}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetMutexOwner 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall   _GetMutexOwner, <MutexHandle>
\par mov     Owner, eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the handle of the thread that owns the specified mutex. Uses C calling convention: Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle in EAX or zero if the mutex is unowned. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i MutexHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the mutex. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _LeaveMutex 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par cCall    _LeaveMutex, <MutexHandle>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Leaves a mutex. If the reentry count of the mutex is greater than one, this function decrements the reentry count. If the reentry count is one, it becomes unowned and the highest priority thread waiting for the mutex is released. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i MutexHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the mutex. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service causes a context switch if the execution priority of the released thread is higher priority than the current thread. 
\par Only the thread owning a mutex can leave it. 
\par When the critical section is freed, any threads waiting for the critical section are released. 
\par {\b _EnterMutex}, {\b _LeaveMustComplete}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Thread-Blocking Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _BlockOnID 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _BlockOnID, <ThreadID, Flags>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Records the identifier (ID) to be used to block the current thread. The actual blockage of a thread is signaled with _{\b SignalID}. Uses the C calling convention. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The programmer-defined ID used to block the thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Actions to take when interrupts occur while the virtual machine is blocked. This parameter can be a combination of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Enable_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service interrupts in the virtual machine even if it does not currently have interrupts enabled. This forces interrupts to be enabled. This value is only relevant if either Block_Svc_Ints or Block_Svc_If_Ints is set. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Svc_If_Ints_Locked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Service interrupts in the virtual machine even if the virtual machine is blocked, and the VMStat_V86IntsLocked flag is set. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Block_Svc_Ints \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Service interrupts in the virtual machine even if the virtual machine is blocked. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Typically, the {\i ThreadID} consists of 32-bit linear address of something related to the object being blocked on, because that helps ensure uniqueness. When the same ID is passed to {\b SignalID}
, the blocked thread reawakens. When a thread reawakens, it must check whether the wakeup was valid or spurious. 
\par This service always blocks the current thread on the ID passed. Multiple threads may block on the same ID. When the ID is signaled with _{\b SignalID} all of the threads currently blocked on the ID will unblock. 
\par Block IDs are not guaranteed to be unique to the caller; an unrelated piece of code may signal the ID in order to awaken a thread that it has blocked and cause this one to be spuriously awakened. Therefore when this service returns the caller must check f
or a spurious wake up and call {\b _BlockOnID} again if this has occurred. Typically a user maintained flag is used for this. The flag is set before calling _{\b BlockOnID} the first time and cleared when {\b _SignalID} is called. 
\par The Block ID is traditionally the address of an object somehow related to the reason why the virtual device needs to block. Be aware of race conditions that may occur if {\b _BlockOnID}
 is called after the ID is signalled. For example, if a virtual device initiates an operation, it may be that the operation completes and the Block ID is signalled before the virtual device gets to call {\b _BlockOnID}
 to wait for the signal. The virtual device ends up blocking waiting for a signal that has already arrived. 
\par {\b _SignalID}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _SignalID 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall _SignalID, <ID>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Signals an ID. Threads currently blocked on this ID will be unblocked. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value used to identify blocked threads. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service does not cause an immediate context switch; instead any threads that need to be released are released the next time events are serviced. 
\par This service preserves the state of the interrupt mask. 
\par  
\par {\b _BlockOnID}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 23 System-Internal Memory Management{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 23
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 System-Internal Memory Management 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About System-Internal Memory Management 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 System-internal memory management services are used internally, and should not be used by virtual devices. They are as follows: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _GetDemandPageInfo}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Retrieves information used for demand paging. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _MMGR_Toggle_HMA}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables or disables the HMA. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _SetLastV86Page}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets last page in V86 address space. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_Physical_HMA_Alias}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets the physical HMA alias. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetDemandPageInfo 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetDemandPageInfo, <<OFFSET32 DemandInfo>, flags>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves information used for demand paging, copying the information to the specified structure. This service is for exclusive use by the virtual paging device. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DemandInfo}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b DemandInfoStruc} structure containing information for demand paging. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _MMGR_Toggle_HMA 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _MMGR_Toggle_HMA, <VM, flags>
\par 
\par cmp     flags, MMGRHMAQuerry
\par jne     did_toggle
\par mov     [HMAState], eax     ; 0 if disabled, 1 if enabled
\par 
\par did_toggle:
\par or      eax, eax           ; nonzero if enabled/disabled, zero if error
\par jz      error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Enables or disables th
e high memory area (HMA). The V86MMGR XMS device uses this service to control the state of the HMA for a specified virtual machine, and to notify the instance data manager that the state is changing. If your virtual device needs to toggle the HMA, use the
 {\b V86MMGR_Toggle_HMA} service instead of this one. This service is for exclusive use by the V86MMGR XMS device. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a value in the EAX register, the meaning of which depends on the operation specified by the
 flags parameter. If the flags parameter specifies the MMGRHMAEnable or MMGRHMADisable operation, the service returns a nonzero if successful, zero otherwise. 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 If the flags parameter specifies the MMGRHMAQuerry operation, the service returns a nonzero value if the HMA is enabled, and zero if disabled. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be one or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MMGRHMADisable \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Disables the HMA, causing addresses greater than 1 megabyte to be wrapped back to addresses in pages 0 through 0Fh. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MMGRHMAEnable \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Enables the HMA, allowing addresses greater than 1 megabyte to access pages 100h through 10Fh. If the MMGRHMAPhysical value is given, the service maps physical pages 100h through 10Fh into the linear pages 100h through 10Fh for the virtual machine, enabli
ng the global HMA for this virtual machine and which all virtual machines share. 
\par the MMGRHMAPhysical value is not given, the servic
e marks the linear pages 100h through 10Fh as not present system pages. To prevent a system crash when these pages are accessed, the virtual device must provide its own physical pages to map into these linear pages. This effectively creates a local HMA th
at is specific to the given virtual machine. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MMGRHMAQuerry \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Returns the current state of the HMA for the virtual machine. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MMGRHMAPhysical \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Specifies whether the service maps physical pages 100h through 10Fh into the HMA or expects the virtual device to 
map some other physical pages into the area. The value is used only if the MMGRHMAEnable value is also given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The MMGRHMAEnable, MMGRHMADisable, MMGRHMAQuerry values are mutually exclusive. 
\par All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can fail if the MMGRHMAEnable and MMGRHMAPhysical values are given, but the system is already using the physical pages 100h through 10Fh for some other purpose. 
\par A virtual device must not call this service unless it has already used the {\b _Assign_Device_V86_Pages} service to assign the pages 100h through 10Fh to itself. For this reason, this service is intended to be used by one and only one virtual device. 

\par When the system creates a virtual machine, it disables the HMA and causes the virtual machine to operate like an 8086 processor. To override this default, the virtual device responsible for the HMA must enable the HMA while processing the {\b 
VM_Critical_Init} message. 
\par Virtual devices must {\i not} identify instance data in the HMA. 
\par {\b _Assign_Device_V86_Pages}, {\b VM_Critical_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _SetLastV86Page 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _SetLastV86Page, <PgNum, flags>
\par 
\par or      eax, eax            ; nonzero if set, zero if error
\par jz      not_set
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Sets the page number of the last page in V86 memory for the current virtual machine. This service is intended for exclusive use by the virtual V86 memory manager device, and is only available for Windows version 3.1 or later. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 New linear page number for the last V86 page. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This service is intended to help the V86MMGR support backfill machines. These machines have unused, unoccupied memory from the end of MS-DOS memory (typically at 512K) up to 640K (page 0A0h). On such machines, it is desirable to fill out (backfill) this u
noccupied space so that virtual machines provide memory up to 640k. 
\par {\b _GetLastV86Page}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Physical_HMA_Alias 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, Entries        ; points to page-table entries for physical HMA alias
\par VMMcall Set_Physical_HMA_Alias
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Defines an HMA alias for pages 100h through 10Fh. This service is for the exclusive use of the XMS driver, a part of the virtual V86MMGR device, and is only available during initialization. Uses EAX, ECX, EDI, ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Entries}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an array of 16 page-table entries, which define the physical HMA alias. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service does {\i not} map new pages into the HMA. Instead, the virtual device must call the {\b _MMGR_Toggle_HMA}
 service with the MMGRHMAPhysical value after the calling this service. This service specifies which pages are mapped when the MMGRHMAPhysical value is specified in a call to the {\b _MMGR_Toggle_HMA} service. 
\par {\b _MMGR_Toggle_HMA}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 DemandInfoStruc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par DemandInfoStruc struc
\par DILin_Total_Count  dd  ?          ; pages in linear addr. space
\par DIPhys_Count       dd  ?          ; see below
\par DIFree_Count       dd  ?          ; see below
\par DIUnlock_Count     dd  ?          ; see below
\par DILinear_Base_Addr dd  ?          ; always zero
\par DILin_Total_Free   dd  ?          ; see below
\par DIPage_Faults      dd  ?          ; total page faults
\par DIPage_Ins         dd  ?          ; calls to pagers to page in
\par DIPage_Outs        dd  ?          ; calls to pagers to page out
\par DIPage_Discards    dd  ?          ; calls to pagers to discard
\par DIInstance_Faults  dd  ?          ; instance page faults
\par DIPagingFileMax    dd  ?          ; see below
\par DIPagingFileInUse  dd  ?          ; see below
\par DICommit_Count     dd  ?          ; total committed pages
\par DIReserved         dd  2 DUP (?)  ; reserved; do not use
\par DemandInfoStruc ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b DemandInfoStruc} structure contains information about pages that are subject to demand paging. The {\b _GetDemandPageInfo} service fills in the members of this structure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b DIPhys_Count}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the total number of physical pages managed by the memory manager. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b DIFree_Count}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the number of pages currently in the free pool. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b DIUnlock_Count}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the number of pages that are currently unlocked. Free pages are always unlocked. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b DILin_Total_Free}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Total number of free virtual pages in the current memory context. This value includes only pages in the private arena, the linear address range controlled by the memory context services. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b DIPagingFileMax}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Current maximum size of the swap file, in pages. This member is zero if swapping is turned off. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b DIPagingFileInUse}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of swap file pages currently in use. This value reflects the number of pages 
by which physical memory is overcommitted. It is zero if swapping is turned off or if physical memory is available for all swappable pages. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _GetDemandPageInfo}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 24 Time-Slice Scheduler{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 24
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Time-Slice Scheduler 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About the Time-Slice Scheduler 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual machine manager (VMM) includes a time-slice scheduler that determines how much processor time to grant to virtual machines. This chapter describes the time-slice scheduler. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Terms 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following terms are related to the time-slice scheduler: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Term \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Definition \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 background priority \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The time-slice priority of a virtual machine that does not have the execution focus. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 background virtual machine \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A virtual machine that does not have the execution focus. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 base priority \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 The unboosted time-slice priority of a thread. A thread's base priority depends on its priority class. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 block \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The temporary halting of the execution of a thread or virtual machine while it waits for a needed resource to be freed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 An increase or decrease in the time-slice priority of a thread. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 dynamic boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
An temporary increase or decrease in the time-slice priority of a thread, brought about by either the VMM or a virtual device. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 exclusive execution 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The execution of a virtual machine to the exclusion of all other non-system virtual machines. When a virtual machine has the execution focus and is exec
uting exclusively, the VMM suspends all other non-system virtual machines. The VMM never suspends the system virtual machine. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 execution focus 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A property of the virtual machine with which the user is currently working. The virtual machine with the execution focus runs in the foreground and its priority is boosted. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 foreground priority \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The time-slice priority assigned to a virtual machine that has the execution focus. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 foreground virtual machine \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The virtual machine that has the execution focus. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 high priority class \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A group of time-slice priority values associated with high priority threads. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The state of a thread or virtual machine that is runnable but needs input before continuing. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 idle priority class \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A group of time-slice priority values associated with idle threads. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 idle thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A thread that runs only when there are no higher priority threads to run. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 initial thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The first thread created in a virtual machine. The system virtual machine can have many thread, non-system virtual machines have only one thread. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
inversion boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
An increase in the time-slice priority of a thread that owns a resource so that the priority matches that of the highest-priority thread that blocks on the resource. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 inversion priority \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
In priority inversion prevention, the time-slice priority to which the owner thread is raised. Also see priority inversion prevention. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
normal priority class \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A group of time-slice priority values associated with threads that are not idle, high priority, or real time. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 priority class \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A group of priority values associated with threads of a particular type. Also see idle priority class, normal priority class, high priority class, and real-time priority class. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 priority inversion list \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A list, maintained internally by the VMM, that contains information used to raise the priority of threads that own resources on which other threads block. Also see priority inversion prevention. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 priority inversion prevention \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A technique the VMM uses to prevent a form of deadlock in which 
a low priority thread that owns a resource is unable to run because of its low priority, and a higher priority thread that also needs the resource remains blocked while waiting for the resource to be freed. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 real-time priority class \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A group of priority values associated with threads that perform time-critical tasks. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 round robin \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The sequential, cyclical allocation of processor time to all threads of the same priority. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 schedule \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Allocating processor time to a virtual machine or thread. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 static boost \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Raising or lowering a thread's time-slice priority with no time decay. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 suspend \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 To halt a process temporarily. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 system idle priority \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A priority of 0, which is reserved for system use. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 system thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The first thread created in the system virtual machine. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The basic entity to which the VMM allocates processor time. A thread can execute any part of the application's code, including a part currently being executed by another thread. All threads of a process share the virtual address space, globa
l variables, and operating system resources of the process. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 thread group \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Two or more threads whose priorities are boosted at the same time. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 thread starvation \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A situation in which a thread does not receive adequate processor time because its time-slice priority is too low. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time-slice \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A brief period of time during which a thread receives control of the processor. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time-slice execution flags \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A set of flags, defined in the VMM include files, that can be set in the control block of a virtual machine or thread and control aspects of how the thread is scheduled. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time-slice granularity \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The duration of a time-slice. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time-slice list \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A list of the threads that the VMM is currently scheduling. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time-slice priority \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
A number associated with a thread and used by the VMM to determine the amount of processor time to grant to the thread. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time-slice quantum \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The average duration of all time slices. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 time-decayed boost \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Raising or lowering of a thread's time-slice priority, followed by a return to the base priority over several subsequent time slices. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\cellx2880\cellx6660 \pard \sa160\sl-240\slmult1\intbl \cell \cell \pard \intbl \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Priority Model 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Introduction 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The time-slice scheduler controls the amount of processor time each virtual machine and application thread receives by setting priorities for them. This section describes priorities and how the time slicer assigns them. 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Priorities and Priority Classes 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Threads, including separate virtual machine and application threads
, have 32 possible priorities, which are divided into four priority classes: idle, normal, high, and real time. Furthermore, the normal priority class is divided into foreground and background subclasses. The following table shows how priorities are divid
ed into classes: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Class \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Priorities \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 1-6, 15 (15 if the base-relative realtime thread priority is specified) \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Normal \cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19  Background \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 1 or 5-9, 15 (1 if the base-relative idle thread priority is specified) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19  Foreground 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 1 or 7-11 or 15 \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 High \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 1 or 11-15 \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Real time \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 16-31 \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Priority 0 is reserved for system use as the system idle priority. Classifying priorities helps to define dynamically variable priority ranges and establishes application guidelines to prevent monopolizing the system with simple set-priority system calls.
 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Preemption 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 All 32 priorities are preemptive of priorities lower than themselves. This means that a runnable thread of one priority preempts all lower priority threads. Threads that are running at the same priority are sch
eduled in a round robin fashion. 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Time-Slice Quantums 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
All time slices are for a statistically constant period of time, called the time-slice quantum. This means that, although two time slices may have different periods, the average period of any large time slice sample remains constant. 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Dynamic Priority Boosting and Timed Decay 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A thread with a priority that is lower than the real-time priority class can have its priority dynamically boosted to respond more quickly to system events or to enhance overall s
ystem throughput. For example, a thread that is just becoming unblocked receives a boost in priority so that, among other threads with the same priority, it will be chosen to execute next. A dynamically boosted thread automatically loses a specified amoun
t of boost for every time slice that it executes. This is called timed decayed boosting, and is used whenever dynamic priority boosting is indicated. Also, when the system detects that a boosted thread no longer needs its boost, the system may return the 
thread to its original base priority. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Thread Starvation 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
If a thread's priority remains low for too long, it can be starved for processor time. The time slicer includes an algorithm that prevents thread starvation by temporarily boosting threads that have not been scheduled within a reasonable amount of time. R
easonable is defined as a number of milliseconds calculated by multiplying the size of the time-slice quantum by the number of executable threads, then multiplying the result by an internal threshold value. 
\par The system cannot dynamically change the priority of a thread that belongs to the real-time priority class. Real-time threads are excluded from the thread starvation algorithm; moreover, real-time threads can starve threads of other priority classes in sp
ite of the starvation algorithm. 
\par An idle thread is one that runs only when there are no higher priority threads to run. All priorities in the idle priority class except the system reserved 0 priority are included in the thread starvation algorithm. 
\par Idle, normal, and high priority class threads are normally not starved. Within these priority classes, the system dynamically boosts the priorities of starving threads using time decayed boost functions. During every starvation detection interval (which v
aries depending on the number of runnable threads) the system recalculates the dynamic priorities of all idle, normal, and high priority threads based on the recent processor usage. When the system finds a thread that has not run for an extended period, t
h
e system gives it a timed decayed boost to the highest priority possible for threads of the normal priority class. By adjusting both the period of time between checks and the acceptable starvation level of threads, the system prevents starvation while eff
iciently setting the priorities of threads. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Blocking and Unblocking 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Introduction 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Usually, when a thread attempts to get access to a resource which is unavailable, such as a semaphore, mutex, critical section, or synchronization object, the thread stops r
unning while waiting for the resource to become available. This is called blocking. Unless a thread happens to block at exactly the time its time-slice quantum has expired, blocking prevents the thread from completing a full time slice. When the resource 
waited on becomes available, the blocked thread is unblocked and runs the next time it is scheduled. 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unblock Boosting 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If, before completing a time slice, a thread blocks and unblocks but is left at the same priority, it will effectively have its time slic
e reduced to the time it uses between the unblock and block operations. This is because the scheduler does not have any reason to schedule the newly unblocked thread before any other threads running at the same priority. This gives threads that do not nee
d to block on resources a great advantage when competing for processor time. 
\par To allow threads which block and unblock to compete effectively for processor time, the time slicer dynamically boosts the priority of a thread when it blocks. 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Monopolization of Processor by Blocking 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A system that boosts priorities when threads block can have problems with threads that monopolize the system by blocking and unblocking very quickly. Without checks in place to prevent this, a thread could block and unblock so quickly that it essentially 
maintains the priority of its boosted state. 
\par To prevent this kind of monopolization, the elapsed time since a thread was scheduled to run is totaled whenever the thread blocks. When the total reaches or exceeds the 
quantum period, the total is reset and the thread is blocked with an unboosted priority. Effectively, the thread is back in the runnable queue at its base priority. 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Priority Inversion Boosting 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A synchronization problem that can occur in a system with preemptive priorities is that threads that own system resources may not be able to run when other, higher priority threads are executing. This can cause a situation in which a thread remains blocke
d on a resource owned by a thread that is unable to run. If th
reads at a higher priority than the resource owning thread do not block, the resource may never be freed. To prevent this problem, the system uses a technique called priority inversion prevention in which the system boosts the priority of the thread that 
owns a resource to at least the priority of any thread that blocks on the resource. 
\par The Windows 95 time slicer's algorithm for priority-inversion-prevention is associative. This means that, once a priority inversion boost is in place, the boosted thread maintains the same priority as the boosting thread. 
\par When threads are suspended by events not related to blocking on resources, they will simply lose their current time slice, and will not be block boosted. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Compatibility with the Primary Scheduler 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
For simplicity, and to remain compatible with the primary scheduler, threads boosted by the primary scheduler are beyond the time slicer's control. When threads or virtual machines are boosted by virtual devices, the time slicer does not track this boosti
ng and wi
ll consider them to be boosted to the real time priority. The time slicer continues to request the primary scheduler to schedule the next available thread at the same priority as the currently executing thread whenever a quantum expires. This allows time 
slicing to continue in a round robin fashion between boosted threads, but prevents the time slicer and primary scheduler from "fighting." 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Execution Focus Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Execution_Focus 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Execution_Focus
\par mov     [Focus], ebx
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the handle of the virtual machine that currently has the execution focus. This virtual machine is called the foreground virtual machine. This is an asynchronous service. Uses EBX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle in EBX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Set_Execution_Focus}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Execution_Focus 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par VMMcall Set_Execution_Focus
\par jc      focus_not_set
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Assigns the execution focus to the specified virtual machine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the execution focus is assigned; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to receive the execution focus. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When a virtual machine receives the execution focus, the system suspends all other virtual machines except the system virtual machine and background virtual machines. 
\par Only the system virtual machine can assign the execution focus to other virtual machines; a nonsystem virtual machine can only assign the execution focus to itself. 
\par {\b Get_Execution_Focus}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Virtual Machine Execution Control Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_When_Idle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 IdleCallback
\par VMMcall Call_When_Idle
\par jc      error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Installs a system-idle callback function. The system calls this function whenever the Windows kernel signals that Windows is idle and all other virtual machines are also idle. Virtual devices typically use this service to perform background operations. Fo
r example, the memory manager uses this service to asynchronously write dirty pages to the backing store. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag is clear if the callback function is installed. Otherwise, sets the carry flag. 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IdleCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback function to install. For more information about the callback function, see {\b IdleCallback}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices can install any number of idle callback functions. The system calls each one, in the order installed, until one of the functions clears the carry flag. A system-idle callback function remains ins
talled until it is explicitly removed by the {\b Cancel_Call_When_Idle} service. 
\par {\b IdleCallback}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Call_When_Idle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, OFFSET32 IdleCallback
\par VMMcall Cancel_Call_When_Idle
\par jc      not_removed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes a callback function installed by a previous call to {\b Call_When_Idle}. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the function is removed; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IdleCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of callback function to remove. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Call_When_Idle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 IdleCallback 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMhandle
\par mov     edi, SysThreadHandle
\par mov     ebp, OFFSET32 Client_Reg_Struc
\par call    [IdleCallback]
\par jc      pass_to_next
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Performs programmer-defined processing whenever the Windows kernel signals that Windows is idle and all other virtual machines are also idle. {\b IdleCallback}
 is a programmer-defined callback function installed by the {\b Call_When_Idle }service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Sets the car
ry flag to pass the call to the next idle callback function; clears the carry flag to prevent the call from being passed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure that contains the registers of the system virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The callback function can carry out any operation and can modify EAX, EBX, ECX, EDX, ESI, EDI, and Flags. If the operation takes a significant amount of time, the function sh
ould clear the carry flag before returning to prevent other callbacks from being called. Otherwise, the function should set the carry flag and return. 
\par {\b Call_When_Not_Critical}, {\b Call_When_Task_Switched}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Release_Time_Slice 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Release_Time_Slice
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 In the system thread, this service idles the thread until the {\b Wake_Up_VM}
 service is called on behalf of the thread. In other threads in the system virtual machine, this service releases the current time slice if there is another thread of equal o
r greater priority ready to run. In nonsystem virtual machines, this service idles the virtual machine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The semantics of this service differ from Windows 3.1 because the two systems have different time slicing algorithms. 
\par {\b Wake_Up_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Time_Slice_Sleep 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc 
\par 
\par mov eax, Timeout
\par VMMCall Time_Slice_Sleep
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Makes the current thread idle for a specified number of milliseconds. The thread can be woken if either {\b Wake_Up_VM} is called on the thread's VM or the specified number of milliseconds elapses. Uses Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the zero flag if the sleep timed out. Sets the zero flag if the sleep was woken up prematurely. 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Signed timeout in milliseconds to use. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service should not be used as a timeout function. The timeout passed in is treated as the maximum time the thread will sleep, but it may wake up earlier. This function will return when either someone calls {
\b Wake_Up_VM} on this VM or when this timeout or the previous timeout set for this VM expires. A timeout of 0 will yield. 
\par A VxD should avoid calling this service while owning the critical section; doing so makes the system appear to hang for the {\i TimeOut} duration. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Time_Slice_Wake_Sys_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc 
\par 
\par VMMCall Time_Slice_Wake_Sys_VM
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Wakes up the system VM from an idle state. Similar to {\b Wake_Up_VM} except that {\b Wake_Up_VM} will not cause the system thread to return to ring 3 and try scheduling 16-bit applications agai
n. Returns after completely waking the system thread and VM interrupts are on. This service should be called only by the Vwin32 device. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Wake_Up_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Wake_Up_Thread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ThreadHandle
\par VMMcall Wake_Up_Thread
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Awakens an idle thread. For the system thread, this service sets the base Win32 priority back to what it was before the thread went idle. For all other threads, the service simply removes any negative decay boost. "Use Flags." 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of thread to awaken. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Wake_Up_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VM
\par VMMcall Wake_Up_VM
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Restores an idle virtual machine, allowing the system to schedule the virtual machine for subsequent time slices. A virtual machine is idle if it has called the {\b Release_Time_Slice}
 service, or has set the VMStat_Idle flag in the {\b CB_VM_Status} field of its control block. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to restore. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the specified virtual machine is not idle, this service returns immediately (does nothing). Do not attempt to make a thread idle by merely setting the VMStat_Idle bit in the {\b CB_VM_Status} field. Use the {
\b Release_Time_Slice} or {\b Time_Slice_Sleep} service to make a thread idle. 
\par {\b Release_Time_Slice}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Time-Slice Priority Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Boost_With_Decay 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, BoostAmount
\par mov     ecx, DecayAmount
\par VMMcall Boost_With_Decay
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Boosts a thread's time-slice priority for one time slice, then adjusts the boost by the specified decay amount for subsequent time slices until the thread's original base priority is reached. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to boost. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoostAmount}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A signed integer value representing the number of milliseconds to lengthen or shorten the time slice. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DecayAmount}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A signed integer value representing the number of milliseconds to lengthen or shorten each subsequent time slice. A positive value shortens subsequent time slices; a negative value lengthens them. 

\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i BoostAmount} and {\i DecayAmount} values must be either both positive or both negative. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Thread_Win32_Pri 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See {\b Get_Thread_Win32_Pri} in {\i Primary Scheduler}. 
\par {\b Get_Thread_Win32_Pri}, {\b Set_Thread_Win32_Pri}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Time_Slice_Priority 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par VMMcall Get_Time_Slice_Priority
\par mov     [Flags], eax
\par mov     [Foreground], ecx
\par mov     [Background], edx
\par mov     [CPUTime], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Retrieves the time-slice execution flags for the specified virtual machine. Also, for backward compatibility, this service also retrieves values for certain obsolete parameters. Uses EAX, ECX, EDX, ESI, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns values in these registers: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 One of the following time-slice execution flags: \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Exclusive \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Virtual machine is executing to the exclusion of all other threads \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Background \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is executing in the background \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 VMStat_High_Pri_Back \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is executing in the background, but with a boost in time-slice priority \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Set to 10,000 if the virtual machine is time-critical and has almost exclusive execution priority; otherwise, ECX is set to 100. In previous versions of Windows, this value indicates the foreground time-slice priority. \cell \pard\plain \intbl \f4\fs21 
\row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EDX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Obsolete. The low-order word is always 50, and the high-order word is always zero. In previous versions of Windows, this value indicates the background time-slice priority. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ESI \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Obsolete. Always specifies 100. In previous versions of Windows, this value indicates the percentage of processor usage. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which to retrieve information. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Time_Slice_Granularity}, {\b Set_Time_Slice_Priority}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Thread_Static_Boost 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, BoostAmount
\par VMMcall Set_Thread_Static_Boost
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Boosts a thread's time-slice priority by the specified amount with no time decay. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to boost. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoostAmount}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A signed integer value representing the number of milliseconds to lengthen or shorten the time slice. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Set_VM_Static_Boost}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Thread_Win32_Pri 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, Priority
\par VMMcall Set_Thread_Win32_Pri
\par jc      priority_not_set
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the base Win32 priority of the given thread, removing any timed decay boost associated with the thread. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the priority is set; otherwise, sets it. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Priority}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Absolute Win32 base priority. This must be a value from 0 to 31. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Thread_Win32_Pri}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Time_Slice_Priority 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Flags
\par mov     ebx, VMHandle
\par mov     ecx, Foreground
\par mov     edx, Background
\par VMMcall Set_Time_Slice_Priority
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the time-slice execution flags and the foreground and background priorities for the specified virtual machine. Uses EAX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the time-slice priority is set; otherwise, sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 One of the following status flags: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Exclusive \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Virtual machine is executing to the exclusion of all other threads \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Background \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is executing in the background \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 VMStat_High_Pri_Back \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is executing in the background, but with a boost in time-slice priority \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to change. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Foreground}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Foreground time-slice priority. The high word must be 0. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Background}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Background time-slice priority. The high word must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 To change the time-slice priority, a virtual machine should retrieve the current time-slice priority using the {\b Get_Time_Slice_Priority}
 service, modify the returned values, and use the modified values as input parameters to this service. The following example assigns a virtual machine to the background: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, [VMHandle]
\par VMMcall Get_Time_Slice_Priority
\par or      eax, VMStat_Background
\par VMMcall Set_Time_Slice_Priority
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Time_Slice_Priority}, {\b Set_Time_Slice_Granularity}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_VM_Static_Boost 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, BoostAmount
\par VMMcall Set_VM_Static_Boost
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Boosts a virtual machine's time-slice priority by the specified amount with no time decay. If {\i VMHandle} identifies the system virtua
l machine, the service boosts all threads in the virtual machine by the specified amount. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to boost. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoostAmount}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A signed integer value representing the number of milliseconds to lengthen or shorten the time slice. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Set_Thread_Static_Boost}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Time-Slice Period Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Adjust_Execution_Time 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Time
\par mov     ebx, VMHandle
\par VMMcall Adjust_Execution_Time
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Adjusts the duration of a virtual machine's time slice. Virtual devices, such as the virtual COM device, use this service to temporarily increase the amount of time a virtual machine is allowed to execute, such as when the virtual machine is receiving an 
unusually high number of interrupts. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Time}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A signed integer value representing the number of milliseconds to lengthen or shorten the time slice. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to adjust. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service adjusts the time slice regardless of the virtual machine's time-slice priority. 
\par If the specified virtual machine is not on the time-slice list, this service returns immediately (does nothing). This service can not force a non-runnable virtual machine to execute. That is, a virtual machine that does not have the VMStat_Background flag
 set cannot be forced to run in the background by increasing the duration of its time slice. 
\par This service can lengthen or shorten the time slice for a virtual machine. However, shortening the time slice is not recommended because it defeats the purpose of multitasking. 
\par Use this service with caution \emdash  it can cause other processes to be starved for processor time. 
\par {\b Get_Time_Slice_Granularity}, {\b Set_Time_Slice_Granularity}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Time_Slice_Info 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Time_Slice_Info
\par mov     [Scheduled], eax
\par mov     [Current], ebx
\par mov     [Idle], ecx
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the number of virtual machines currently scheduled by the time slicer, and the number of virtual machines that are idle. This service can be called at interrupt time. Uses EAX, EBX, ECX, and Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns values in these registers: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EAX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Number of virtual machines scheduled \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EBX \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Handle of the currently scheduled virtual machine \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ECX \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Number of scheduled virtual machines currently idle \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_Time_Slice_Granularity}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Time-Slice Granularity Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Time_Slice_Granularity 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Time_Slice_Granularity
\par mov     [Granularity], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the current time-slice granularity. This value specifies the minimum number of milliseconds a virtual machine runs before being rescheduled. Uses EAX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the granularity value in EAX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Set_Time_Slice_Granularity}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Time_Slice_Granularity 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Time
\par VMMcall Set_Time_Slice_Granularity
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the minimum time-slice granularity, the minimum number of milliseconds a virtual machine can run before being rescheduled. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Time}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Minimum time-slice granularity, in milliseconds. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Small time-slice granularity values make multitasking appear smoother, but require high numbers of task switches and increase execution overhead. Large values allow more time for the virtual machines to execute, but may make execution look intermittent to
 the user. 
\par The limit for the maximum time-slice granularity is 250 milliseconds. 
\par {\b Get_Time_Slice_Granularity}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Thread Groups 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Attach_Thread_To_Group 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, ThreadInGroup
\par mov     edi, ThreadToAdd
\par VMMcall Attach_Thread_To_Group
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Adds a thread to a thread group. A virtual device creates thread groups so that it can boost the priority of all the threads in the group with a single call to the {\b Set_Group_Static_Boost}
 service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadInGroup}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of a thread that belongs to a group. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadToAdd}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of a thread to add to the group to which {\i ThreadInGroup} belongs. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If {\i ThreadToAdd} already belongs to a group, it is removed from the current group before being added to the new group. 
\par {\b Detach_Thread_From_Group}, {\b Set_Group_Static_Boost}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Detach_Thread_From_Group 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ThreadHandle
\par VMMcall Detach_Thread_From_Group
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes a thread from any thread group to which may belong. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of thread to remove from any thread group. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Attach_Thread_To_Group}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Group_Static_Boost 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, BoostAmount
\par VMMcall Set_Group_Static_Boost
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Boosts the time-slice priorities of all thread in a thread group by the specified amount with no time decay. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of a thread in a thread group. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoostAmount}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A signed integer value representing the number of milliseconds to lengthen or shorten the time slice. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Attach_Thread_To_Group}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Priority Inversion Services 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Release_Inversion_Pri 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, BoostHandle
\par VMMcall Release_Inversion_Pri
\par jc      not_released
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the given thread from the priority inversion list, deallocates the memory associated with the list entry, and invalidates the handle to the list entry. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if successful; otherwise sets it. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoostHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an entry in the priority inversion list. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 After removing the thread from the list, the service sets the new time-slice priority as follows: 
\par  priority = MAX((all inversion priorities), (Win32BasePri + TimeDecayBoost)) 
\par {\b Release_Inversion_Pri_ID}, {\b Reset_Inversion_Pri}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Release_Inversion_Pri_ID 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, ID
\par mov     edi, ThreadHandle
\par VMMcall Release_Inversion_Pri_ID
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes all entries from the priority inversion list that have the specified identifier and that were added by the given thread. The entries were added by a previous call to the {\b Set_Inversion_Pri} servic
e. Uses EAX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the number of entries removed in EAX. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Identifier of entries to remove. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of thread that added entries to the priority inversion list. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Release_Inversion_Pri}, {\b Reset_Inversion_Pri}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Reset_Inversion_Pri 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, BoostHandle
\par mov     eax, Priority
\par VMMcall Reset_Inversion_Pri
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Adjusts a thread's time-slice priority without associating the priority with a timed decay boost. If the new priority is less than the current priority, the service reduces the priority by the difference. Uses EAX, ECX, and EDX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoostHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of an existing inversion priority boost. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Priority}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 New time-slice priority for the thread associated with {\i BoostHandle}. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Release_Inversion_Pri}, {\b Release_Inversion_Pri_ID}, {\b Set_Inversion_Pri}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Inversion_Pri 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, TargetThread
\par mov     ebx, BoosterThread
\par mov     eax, Priority
\par mov     edx, BoostID
\par VMMcall Set_Inversion_Pri
\par jc      error
\par mov     [InvertHandle], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Adds the given target thread to the priority inversion list. While a thread remains in the list, it has the same time-slice priority as that of the thread with the highest priority in the list. Uses EAX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns, in EAX, the handle of the inversion list entry for the given thread. 
Clears the carry flag if successful; sets it if an error occurs. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TargetThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to add to the priority inversion list. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoosterThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread that is adding the target thread to the inversion list. This parameter need not be the current thread. Also, 0 is valid. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Priority}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Absolute Win32 priority required by the target thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i BoostID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Identifier to associate with the entry in the priority inversion list. If a virtual device does not use this parameter, it should set it to zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can use the handle returned by this service in a subsequent call to {\b Release_Inversion_Pri} to remove the thread from the inversion list. 
\par {\b Reset_Inversion_Pri}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 25 Timing Services{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 25
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Timing Services 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Time Services 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Timing Query Services 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Time query services allow a virtual device to obtain information about how long the system, a virtual machine, or a thread has been executing, in milliseconds. 
\par When the system creates a thread or virtual machine, it sets the execution time for the thread or virtual machine to zero. The system increases the execution time only when the thread or virtual machine actually runs. Therefore the execution does not refl
ect the length of time the thread or virtual machine has existed, but indicates the amount of time the thread or virtual machine has run. Note however that {\i any}
 code executed in the indicated thread or virtual machine contributes to the tally; it is not the case that one second of thread execution time or virtual machine execution time translates into one second of actual CPU time given to the application. 

\par For each query service there are two variants, the {\i standard} form and the {\i last updated} form (for example, {\b _GetThreadExecTime} and {\b _GetLastUpdatedThreadExecTime}). The standard form returns the time to millisecond accuracy, wher
eas the last updated form returns the time only to an accuracy of approximately 50 milliseconds. The difference is that the standard form will ask the timer device to give the time to millisecond accuracy, and use the result to compute the value to return
, whereas the last updated form returns the value most recently obtained by a standard form call, or by the timer device explicitly updating the system clock (which happens on every timer tick). 
\par If the interval being measured is on the order of seconds or 
minutes, the last updated form is sufficient because a 50 milliseconds variation will not make a noticeable difference. If the interval being measured is less than one half second, you may be better off with the standard form. 
\par Note also that all of the query services return 32-bit unsigned values. This value overflows every 49 1/2 days. If a virtual device is sensitive to rollover, it should schedule a time-out every 30 days. 
\par Make certain to handle the boundary cases correctly. For example, the following code is incorrect when the system time is close to rollover. 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 VMMcall Get_System_Time
\par add    eax, 60000      ; Do it for one minute
\par mov    StopTime, eax
\par ...
\par VMMcall Get_System_Time
\par cmp     eax, StopTime  ; Q: Time to stop?
\par jae     StopMe         ; Y: Stop doing it
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the operation starts less than one minute before a timer rollover, the operation will halt prematurely, because {\i StopTime}
 will contain a very small number due to addition overflow. Conversely, if the operation starts slightly earlier than one minute before timer rollover, it may never stop because {\i StopTime}
 will be extremely close to 0xFFFFFFFF. The correct way to handle the boundary cases is as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 VMMcall Get_System_Time
\par mov    StartTime, eax
\par ...
\par VMMcall Get_System_Time
\par sub    eax, StartTime
\par cmp    eax, 60000      ; Q: Time to stop?
\par jae    StopMe          ; Y: Stop doing it
\par 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Time-Out Callback Procedures 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When the specified amount of time has elapsed for a time-out, the callback procedure is called. For asynchronous time-outs, the callback 
procedure is called at hardware interrupt time; for other time-outs, the callback procedure is called at unrestricted event time. At hardware interrupt time, only asynchronous services may be called. See {\i Events}
 for restrictions on what can and cannot be done at event time. 
\par All time-out callback procedures receive a tardiness value in the ECX register. This value is the number of milliseconds by which the time-out is late. For example, if you scheduled a time-out for 100 milliseconds, but it does not get di
spatched until 115 milliseconds have elapsed, the ECX register will contain the value 15. Time-outs are often delayed by 10 milliseconds or more, because the normal system timer runs at 20 milliseconds or slower. If a virtual device needs more accurate ti
me-outs, it must increase the timer interrupt frequency using virtual timer device (VTD) services. 
\par Note that the value in ECX is accurate only to the last updated resolution. If you need the tardiness to millisecond resolution, you must first ensure that the virtual machine manager originally scheduled the time-out to millisecond resolution (see {\i 
Timing Query Services}), then use the following algorithm to convert the last-updated resolution to system-time resolution: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 ; On entry, ECX = tardiness in milliseconds relative to 
\par ; Last_Updated_System_Time
\par VMMcall  Get_Last_Updated_System_Time
\par sub    ecx, eax      ;ECX = Remove Last_Updated_System_Time bias
\par VMMcall  Get_System_Time
\par add    ecx, eax      ; ECX = Apply System_Time bias
\par                      ; ECX = true tardiness to millisecond resolution
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Alternatively, you could record the system time when the time-out was scheduled, and subtract it from the current system time at the time the callback is made, rather than doing the above. 
\par If you need to convert the tardiness of a thread time-out or virtual machine time-out, you should use {\b _GetLastUpdatedThreadExecTime} and {\b _GetThreadExecTime}, or {\b Get_Last_Updated_VM_Exec_Time} and {\b Get_VM_Exec_Time}
, respectively. Note that, since {\b _GetLastUpdatedThreadExecTime} and {\b _GetThreadExecTime} use the C calling convention, you need to preserve the EDX and ECX registers around the calls. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Cancel_Time_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     esi, TimeOut     ; time-out handle
\par VMMcall Cancel_Time_Out
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Cancels a time-out that was scheduled using the {\b Set_Async_Time_Out}, {\b Set_Thread_Time_Out}, {\b Set_VM_Time_Out} or {\b Set_Global_Time_Out} service. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the time-out to cancel. If this parameter is zero, the service ret
urns immediately (does nothing). If this parameter is non zero, it must be the handle of a time-out which has not yet been processed or canceled. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service makes the time-out handle invalid; the virtual device must not attempt to use the handle in subsequent calls to services. 
\par {\b Set_Global_Time_Out}, {\b Set_VM_Time_Out}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Last_Updated_System_Time 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_Last_Updated_System_Time
\par 
\par mov     [SysTime], eax          ; system time in milliseconds
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b Get_Last_Updated_System_Time}
 service returns the time in milliseconds since Windows was started. This service is accurate to approximately 50 milliseconds. This is an asynchronous service. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns in the EAX register, the elapsed time, in milliseconds, since Windows was started. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See {\i Timing Query Services} for a discussion of timer rollover and a comparison of {\b Get_System_Time} with {\b Get_Last_Updated_System_Time}. 
\par {\b Get_System_Time}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetLastUpdatedThreadExecTime 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetLastUpdatedThreadExecTime, <ThreadHandle>
\par mov     [ThreadExecTime], eax;
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Retrieves the amount of time in milliseconds that the specified thread has run. This service is accurate to approximately 50 milliseconds. This is an asynchronous service. This service uses the C calling convention. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns in the EAX register, the amount of time, in milliseconds, that the thread has executed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to obtain execution time information for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See {\i Timing Query Services} for a definition of thread execution time, a discussion of timer rollover, and a comparison of _{\b GetThreadExecTime }with _{\b GetLastUpdatedThreadExecTime}. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Last_Updated_VM_Exec_Time 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov    ebx, [VMHandle]
\par VMMcall Get_Last_Updated_VM_Exec_Time
\par 
\par mov     [ExecTime], eax     ; time in milliseconds that VM has run
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the amount of time that the specified virtual machine has run. This service is accurate to approximately 50 milliseconds. This is an asynchronous service. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns in the EAX register the execution time, in milliseconds, for the specified virtual machine. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to obtain execution time information for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When the system creates a virtual machine, it sets the execution time for the virtual machine to zero. The system increases the execution time only when the virtual machine actually runs. Therefore the 
execution does not reflect the length of time the virtual machine has existed, but indicates the amount of time the current virtual machine has run. Note however that {\i any}
 code executed in the indicated virtual machine contributes to the tally; it is not the case that one second of virtual machine execution time translates into one second of actual CPU time given to the application. 
\par See {\i Timing Query Services} for a definition of virtual machine execution time, a discussion of timer rollover, and a comparison of {\b Get_VM_Exec_Time} with {\b Get_Last_Updated_VM_Exec_Time}. 
\par {\b Get_VM_Exec_Time}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_System_Time 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_System_Time
\par 
\par mov     [SysTime], eax          ; system time in milliseconds
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the time in milliseconds since Windows started. This service is accurate to 1 millisecond. This is an asynchronous service. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns in the EAX register the elapsed time, in milliseconds, since Windows was started. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See {\i Timing Query Services} for a discussion of timer rollover and a comparison of {\b Get_System_Time} with {\b Get_Last_Updated_System_Time}. 
\par {\b Get_Last_Updated_System_Time}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_System_Time_Address 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Get_System_Time_Address
\par mov     [System_Time_Addr], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the address of the system-time variable. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns in the EAX register the address of the system time variable. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system time variable is the 32-bit value returned by the {\b Get_Last_Updated_System_Time} service. This service is pr
ovided as a convenience (primarily to C-language callers), so that the return value can be stored into a pointer variable and accessed directly, thus avoiding the overhead of a C wrapper and dynalink call. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetThreadExecTime 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetThreadExecTime, <hThread>
\par mov     [ExecTime], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the amount of time that a particular thread has executed. The value returned indicates the amount of time the specified task has been the currently running thread. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns in EAX the amount of time in milliseconds that thread has executed. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hThread}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread to get the execution time for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service can be called at interrupt time. 
\par See {\i Timing Query Services} for a definition of thread execution time, a discussion of timer rollover, and a comparison of {\b _GetThreadExecTime} with {\b _GetLastUpdatedThreadExecTime}. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_VM_Exec_Time 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov  ebx, [VMHandle]
\par VMMcall Get_VM_Exec_Time
\par 
\par mov     [ExecTime], eax     ; time in milliseconds that VM has run
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the amount of time that the specified virtual machine has run. This service is accurate to 1 millisecond. This is an asynchronous service. Uses EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns in the EAX register the execution time for the specified virtual machine. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to obtain the execution time information for. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 See {\i Timing Query Services} for a definition of virtual machine execution time, a discussion of timer rollover, and a comparison of {\b Get_VM_Exec_Time} with {\b Get_Last_Updated_VM_Exec_Time}. 
\par {\b Get_Last_Updated_VM_Exec_Time}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Async_Time_Out_Proc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov  ecx, Tardiness
\par mov  edx, Reference_Data
\par 
\par call [Async_Time_Out_Proc]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Callback procedure installed by {\b Set_Async_Time_Out}. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Tardiness}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of extra milliseconds that have elapsed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Reference_Data}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Data that is returned by the callback procedure to the calling procedure. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Note that asynchronous time-outs do not receive a pointer to the client registers in the EBP register. 
\par Asynchronous time-outs differ from other time-outs in that they are called at hardware interrupt time. Thus, stricter rules are in force during the time-out callback. The time-out callback procedure may only call asynchronous services, must reside in lock
ed code, and must restrict itself to locked code and data. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Async_Time_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, TimeOut_Delay
\par mov     edx, Reference_Data
\par mov     esi, Async_Time_Out_Proc
\par VMMcall Set_Async_Time_Out
\par mov     [TimeOut_Handle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Schedules a time-out callback procedure that will be called after the specified length of time. Uses ESI, flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab If the time-out was scheduled, returns in ESI a handle that identifies it; otherwise, ESI is zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut_Delay}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The specified number of milliseconds that must transpire before the time-out occurs. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Reference_Data}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Data that's returned to the procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Async_Time_Out_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A callback procedure that is called when the time-out occurs. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Global_Time_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Time                       ; number of milliseconds
\par mov     edx, RefData                    ; reference data
\par mov     esi, OFFSET32 TimeOutCallback   ; callback procedure
\par VMMcall Set_Global_Time_Out
\par 
\par mov     [TimeOut], esi                  ; time-out handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Schedules a time-out to occur after the specified number of milliseconds have elapsed. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the handle of the time-out in the ESI register if successful, zero if the time-out could not be scheduled. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Time}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of milliseconds to wait before calling the time-out callback procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the callback procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOutCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the time-out callback procedure when the specified number of milliseconds elapse. The system calls the procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VMHandle      ; current VM handle
\par mov     ecx, Tardiness     ; number of milliseconds since time-out
\par mov     edx, RefData       ; reference data
\par mov     ebp, OFFSET32 crs  ; points to Client_Reg_Struc
\par call    [TimeOutCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VMHandle} parameter is a handle specifying the current virtual machine. The {\i RefData} parameter specifies the reference data for the callback procedure, and the {\i crs} parameter points to a {\b 
Client_Reg_Struc} structure that contains the register values for the current virtual machine. 
\par The {\i Tardiness }parameter specifies the number of milliseconds that have elapsed since the actual time-out occurred. See {\i Time-Out Callback Procedures} for a description of this value. 
\par {\b Set_VM_Time_Out}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Thread_Time_Out_Proc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov  ebx, VMHandle
\par mov  ecx, Tardiness
\par mov  edx, Reference_Data
\par mov  edi, ThreadHandle
\par mov  ebp, OFFSET32 Client_Reg_Struc
\par call [Thread_Time_Out_Proc]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The thread time-out callback procedure is called when the corresponding thread has executed for the amount of time specified when the time-out was set. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Tardiness}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of extra milliseconds that have elapsed. See {\i Time-Out Callback Procedures} for a description of this value. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Reference_Data}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data originally provided when the time-out was scheduled. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of current thread. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of {\b Client_Reg_Struc} structure containing the contents of the virtual machine's registers. 
\par The time-out will occur after the thread has run for the specified number of milliseconds. If there is more than one thread executing, it may take more than the specified time to occur. See {\i Time-Out Callback Procedures}
 for more information about time-out callbacks. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Thread_Time_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, TimeOut_Delay
\par mov     edx, Reference_Data
\par mov     esi, OFFSET32 Thread_Time_Out_Proc
\par mov     edi, ThreadHandle
\par VMMcall Set_Thread_Time_Out
\par mov     [TimeOut_Handle], esi
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Schedules a time-out that will occur after the specified thread has executed for the specified length of time. Uses ESI, flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab If the time-out was scheduled, ESI contains a handle that identifies it; otherwise, ESI is zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOut_Delay}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The specified number of milliseconds that must transpire in the thread before the time-out occurs. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Reference_Data}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Data that is provided to the callback procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Thread_Time_Out_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 A callback procedure that is called when the time-out occurs. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The time-out will occur after the thread has run for the specified number of milliseconds. If there is more than one thread executing, it may take more than the specified time to occur. See {\i 
Timing Query Services} for more information about time-outs. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_VM_Time_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Time                       ; number of milliseconds
\par mov     ebx, VMHandle                   ; VM handle
\par mov     edx, RefData                    ; reference data
\par mov     esi, OFFSET32 TimeOutCallback   ; callback procedure
\par VMMcall Set_VM_Time_Out
\par 
\par mov     [TimeOut], esi                  ; time-out handle
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Schedules a time-out that occurs after the specified virtual machine has run for the specified length of time. The system calls the time-out callback procedure only after the virtual machine has run for {\i Time}
 milliseconds. Time that elapses while other virtual machines run is not counted. Uses ESI, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the handle of the ti
me-out in the ESI register if successful, zero if the time-out could not be scheduled. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Time}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of milliseconds to wait before calling the time-out callback procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the callback procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TimeOutCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the time-out callback procedure after the virtual machine has run for the specified number of milliseconds. The system calls the procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VMHandle       ; current VM handle
\par mov     ecx, Tardiness      ; number of milliseconds since time-out
\par mov     edx, RefData        ; reference data
\par mov     ebp, OFFSET32 crs   ; points to Client_Reg_Struc
\par call    [TimeOutCallback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VMHandle} parameter is a handle specifying the virtual machine for which the time-out was scheduled. The {\i RefData} parameter specifies the reference data for the callback procedure, and the {\i crs}
 parameter points to a {\b Client_Reg_Struc} structure that contains the register values for the virtual machine. 
\par The {\i Tardiness }parameter specifies the number of milliseconds that have elapsed since the actual time-out occurred. See {\i Timing Query Services} for more information about time-outs. 
\par {\b Set_Global_Time_Out}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Update_System_Clock 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ecx, Time           ; elapsed time in milliseconds
\par VMMcall Update_System_Clock
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Updates the current system time, and the current virtual machine's execution time. Uses Flags. 
\par This service is reserved for exclusive use by the virtual timer device. If other virtual devices call this service, the VMM timing services will behave incorrectly. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Time}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of milliseconds that have elapsed since the last call to this service. The service adds this amount to the system time maintained by the VMM. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual timer device must disabled interrupts before calling this service. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 26 Virtual Machine Interrupts and Callbacks{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 26
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 Virtual Machine Interrupts and Callbacks 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About Virtual Machine Interrupts and Callbacks 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following virtual machine interrupt and callback services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Service \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Build_Int_Stack_Frame}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Builds a stack frame for an interrupt. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Call_When_VM_Ints_Enabled}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs an interrupts-enabled callback. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Disable_VM_Ints}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Disables interrupts for the virtual machine. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Enable_VM_Ints}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables interrupts for the virtual machine. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Instanced_V86_Int_Vector}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Returns a real-mode interrupt address instanced per VM. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_Inst_V86_Int_Vec_Base}\cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Retrieves the address of a 400h-byte memory block that contains the current interrupt vectors for the given VM. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_PM_Int_Type}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the type of interrupt vector. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_PM_Int_Vector}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns a protected-mode interrupt address. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Get_V86_Int_Vector}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns a real-mode interrupt address. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_V86_Int_Chain}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Installs a hook procedure for a V86 interrupt. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_PM_Int_Type}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets the protected-mode interrupt type. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_PM_Int_Vector}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets a protected-mode interrupt vector. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Set_V86_Int_Vector}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sets a real-mode interrupt vector. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Far_Call}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates a far call. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Far_Jmp}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates a jump. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Far_Ret}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates a far return. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Far_Ret_N}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates a far return with parameters. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Int}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates an interrupt. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Iret}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates a return from an interrupt. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Pop}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates a pop instruction. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Simulate_Push}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Simulates a push instruction. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Test_VM_Ints_Enabled}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Determines whether the current VM interrupts are enabled or disabled. \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_V86_Int_Chain}\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Removes the hook procedure for the specified interrupt. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Build_Int_Stack_Frame 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     cx, Segment        ; code segment of routine to call
\par mov     edx, Offset        ; offset of routine to call
\par VMMcall Build_Int_Stack_Frame
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Prepares the current virtual machine to execute an interrupt routine. This service saves the current {\b Client_CS}, {\b Client_IP}, and {\b Client_Flags} registers on the virtual machine's stack and sets the {
\b Client_CS} and {\b Client_IP} registers to the address of the interrupt routine specified by the {\i Segment} and {\i Offset} parameters. When execution resumes in the virtual machine (such as when the {\b Resume_Exec}
 service is called), the virtual machine executes the interrupt routine. The interrupt routine continues to run until it executes an {\b iret} instruction. Uses Client_CS, Client_EIP, Client_ESP, Client_Flags, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Segment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Segment address or segment selector for the code segment containing the interrupt routine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset of interrupt routine. If the specified code segment is a 16-bit segment, the high word of this parameter must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following example executes the interrupt routine in the code segment specified by My_Segment at the offset My_Offset: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 VMMcall Begin_Nest_Exec
\par mov     cx, [My_Segment]
\par mov     edx, [My_Offset]
\par VMMcall Build_Int_Stack_Frame
\par VMMcall Resume_Exec
\par VMMcall End_Nest_Exec
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Simulate_Far_Call}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Call_When_VM_Ints_Enabled 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edx, RefData            ; reference data
\par mov     esi, OFFSET32 Callback  ; points to callback procedure
\par VMMcall Call_When_VM_Ints_Enabled
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a callback procedure that the system calls when the virtual machine enables interrupts. This service calls the callback procedure immediately if interrupts 
are already enabled. Virtual devices use this service to ensure that virtual machine interrupts are enabled before carrying out some action, such as calling a callback procedure in the virtual machine. Uses Client_Flags, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i RefData}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reference data to be passed to the callback procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure to install. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 It is usually more convenient to use the {\b Call_Priority_VM_Event}
 service instead of calling this service directly. However, this service is faster. The callback procedure is automatically uninstalled when it is called. 
\par The system calls the callback procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM                  ; current VM handle
\par mov     edx, OFFSET32 RefData    ; points to reference data
\par mov     ebp, OFFSET32 crs        ; points to a Client_Reg_Struc
\par call    [Callback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter is a handle identifying the current virtual machine, the {\i RefData} parameter points to the reference data specified when the callback procedure was installed, and the {\i crs}
 parameter points to a {\b Client_Reg_Struc} structure containing the register values for the virtual machine. 
\par The callback procedure may use the EAX, EBX, ECX, EDX, ESI, EDI, and Flags registers. 
\par {\b Call_When_Idle}, {\b Call_When_Not_Critical}, {\b Call_When_Task_Switched}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Disable_VM_Ints 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Disable_VM_Ints
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Disables interrupts during virtual machine execution for the current virtual machine. This has the same effect as the virtual machine executing a {\b cli} instruction. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices should use this service instead of changing the {\b Client_Flags} directly, so that the virtual machine manager can do necessary associated bookkeeping. 
\par {\b Enable_VM_Ints}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Enable_VM_Ints 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Enable_VM_Ints
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Enables interrupts during virtual machine execution for the current virtual machine. This has the same effect as the virtual machine executing an {\b sti} instruction. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices use this service to permit callback procedures installed by the {\b Call_When_Ints_Enabled} or {\b Call_Priority_VM_Event} service to be called. The system does {\i not}
 call these callback procedures immediately. Instead, it waits until the next event occurs. This means the virtual machine's state does not change while this service executes. 
\par Virtual devices should use this service instead of changing the {\b Client_Flags} directly, so that the virtual machine manager can do necessary associated bookkeeping. 
\par {\b Call_Priority_VM_Event}, {\b Call_When_VM_Ints_Enabled}, {\b Disable_VM_Ints}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Instanced_V86_Int_Vector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov eax, InterruptNumber
\par mov ebx, VMHandle
\par VMMCall Get_Instanced_V86_Int_Vector
\par 
\par mov dword ptr [Handler], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the address of the routine that handles the specified interrupt from a V86 interrupt table. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the address of the routine that handles the specified interrupt in the EAX register if successful; otherwise returns 0 in EAX. The high word of the EAX register contains the segment address of the interrupt-handling routine, and the low word of t
he EAX register contains the offset. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i InterruptNumber}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The interrupt number that causes the interrupt routine to be called. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 VM handle. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The interrupt table is instanced per VM. For performance reasons, this service retrieves the address
 of the interrupt-handling routine without causing an instance fault. This service is preferred over accessing the interrupt vector table directly. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_Inst_V86_Int_Vec_Base 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     VMHandle
\par VMMcall Get_Inst_V86_Int_Vec_Base
\par mov     [Address], ecx
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves the address of a 400h-byte memory block that contains the current interrupt vectors for the given VM. This function can be used in place of the {\b Get_Instanced_V86_Int_Vector}
 service to examine multiple interrupt vectors. Uses ECX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns, in ECX, the address of a memory block that contains the current interrupt vectors. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHANDLE}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Be careful when using this service. Your code must reside in page locked memory and must not touch pageable memory, including instance pages, and must not yield while using the pointer returned by this service. 

\par A VxD must not use this pointer to modify interrupt vectors because doing so can cause the system to become unstable. To be safe, use the {\b Get_Instanced_V86_Int_Vector} service instead of {\b Get_Inst_V86_Int_Vec_Base}. 
\par {\b Get_Instanced_V86_Int_Vector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_PM_Int_Type 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt    ; number of interrupt to check
\par VMMcall Get_PM_Int_Type
\par 
\par mov     [Type], edx       ; 0 if trap gate, else interrupt gate
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether a protected-mode interrupt vector is an interrupt gate or trap-gate type interrupt. Uses EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns zero in the EDX register if the interrupt
 corresponds to a trap gate, a nonzero value if the it corresponds to an interrupt gate. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to check. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
An interrupt that passes through an interrupt gate automatically clears the interrupt flag bit to disable interrupts. Interrupts that pass through a trap gate do not modify the interrupt bit. All protected-mode interrupts default to the trap-gate type, bu
t virtual devices such as the virtual PIC device, may change some trap gates to interrupt gates so that hardware interrup
ts disable interrupts. The virtual PIC device leaves software interrupts, such as Interrupt 21h, unchanged. This avoids an unnecessary ring transition by eliminating the need for the software interrupt handlers to execute an {\b sti} instruction. 
\par {\b Get_PM_Int_Vector}, {\b Set_PM_Int_Type}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_PM_Int_Vector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt      ; number of interrupt to check
\par VMMcall Get_PM_Int_Vector
\par 
\par mov     [Segment], cx       ; selector for interrupt routine
\par mov     [Offset], edx       ; offset to interrupt routine
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the address of the interrupt routine for the specified protected-mode interrupt in the current virtual machine. Uses ECX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the selector in the CX register and the offset in the EDX register. The high word of the EDX register is zero if the code segment is a 16-bit segment. The zero flag is set if the interrupt address points to the default interrupt handler, or clear
 if a virtual device has hooked the interrupt. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to check. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system maintains a protected-mode interrupt vector table for each virtual machine. By default, each table entry points to a protected-mode breakpoint procedure that reflects the interrupt to V86 mode. 
\par {\b Get_PM_Int_Type}, {\b Set_PM_Int_Vector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Get_V86_Int_Vector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt      ; number of interrupt to check
\par VMMcall Get_V86_Int_Vector
\par 
\par mov     [Segment], cx       ; segment addr. for interrupt routine
\par mov     [Offset], edx       ; offset of interrupt routine
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the address of the interrupt routine for the specified real-mode interrupt in the current virtual machine. Uses ECX, EDX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the segment address in the CX register and the offset in the EDX register. The high word of the EDX register is always zero. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to check. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Get_PM_Int_Vector}, {\b Set_V86_Int_Vector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_V86_Int_Chain 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt          ; number of interrupt to hook
\par mov     esi, OFFSET32 HookProc  ; points to hook procedure
\par VMMcall Hook_V86_Int_Chain
\par 
\par jc      not_installed           ; carry flag set if procedure not installed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Installs a hook procedure that the system calls whenever the specified interrupt occurs. Virtual devices use this service to monitor software interrupts, and simulated hardware interrupts in V86 mode. Unlike Windows 3.1 in which this service was available
 only during initialization, Windows 95 allows V86 interrupt hooks to be installed after initialization is complete. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful, set otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt for which to install the hook procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i HookProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the hook procedure. For more information about the hook procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the hook procedure whenever the corresponding interrupt occurs, a virtual device calls the {\b Simulate_Int} service, or th
e system simulates a hardware interrupt. This means a hook procedure must make no assumptions about the origin of the interrupt. 
\par The system calls the procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     eax, Interrupt      ; number of interrupt hooked
\par mov     ebx, VM             ; current VM handle
\par mov     ebp, OFFSET32 crs   ; points to a Client_Reg_Struc
\par call    [HookProc]
\par 
\par jc      pass_to_next        ; carry set if interrupt not serviced
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i Interrupt} parameter is the number of the current interrupt, the {\i VM} parameter is a handle identifying the current virtual machine, and the {\i crs} parameter points to a {\b Client_Reg_Struc}
 structure containing the register values of the current virtual machine. If the hook procedure services the interrupt, it must clear the carry flag to prevent the system from passing the interrupt to the next hook procedure. 
\par Any number of virtual devices can install a hook procedure for a given interrupt. The system always calls the last hook procedure first. A hook procedure either services the interrupt or d
irects the system to pass the interrupt to the next hook procedure. If no hook procedure services the interrupt, the system reflects the interrupt to the virtual machine. 
\par This service is recommended instead of hooking the V86 interrupt vector directly. 
\par {\b Set_V86_Int_Vector}, {\b Simulate_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Far_Call 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     cx, Segment       ; segment containing procedure
\par mov     edx, Offset       ; offset of procedure
\par VMMcall Simulate_Far_Call
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates a far call to a procedure in the the current virtual machine. This service sets the {\b Client_CS} and {\b Client_IP} registers to the specified procedure address after saving the original {\b Client_CS
} and {\b Client_IP} registers on the stack of the current virtual machine. When the virtual machine resumes execution (such as when the {\b Resume_Exec}
 service is called), the system executes the specified procedure and returns only when the procedure executes a far {\b ret} instruction. Uses Client_CS, Client_EIP, Client_SP, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Segment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Selector or segment address of the code segment containing the procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset of the procedure to call. If the code segment is a 16-bit segment, the high word must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Build_Int_Stack_Frame}, {\b Simulate_Far_Jmp}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Far_Jmp 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     cx, Segment       ; segment containing procedure
\par mov     edx, Offset       ; offset of procedure
\par VMMcall Simulate_Far_Jmp
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates a far jump to a procedure in the current virtual machine. This service sets the {\b Client_CS} and {\b Client_IP}
 registers to the specified address. When the virtual machine resumes execution (such as when the {\b Resume_Exec} service is called), the system executes the specified procedure. Uses Client_CS, Client_EIP, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Segment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Selector or segment address of the code segment containing the procedure. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset of the procedure to jump to. If the code segment is a 16-bit segment, the high word must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Simulate_Far_Call}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Far_Ret 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Simulate_Far_Ret
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates a far return in the current virtual machine. This service pops the top two words (or doublewords) from the stack of the current virtual machine, and copies these values to the {\b Client_CS} and {\b 
Client_EIP} or {\b Client_IP} registers. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This services pops two word values from the stack if the segment containing the address is a 16-bit segment. Otherwise, this service pops two doubleword values. 
\par {\b Simulate_Far_Call}, {\b Simulate_Far_Ret_N}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Far_Ret_N 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Bytes          ; number of bytes to pop from stack
\par VMMcall Simulate_Far_Ret_N
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates a far return in the current virtual machine. This service pops the top two words (or doublewords) from the stack of the current virtual machine, and places the values in the {\b Client_CS} and {\b 
Client_EIP} or {\b Client_IP} registers. It then adds the specified value to the {\b Client_ESP} or {\b Client_SP} register, effectively popping any pushed parameters from the stack. Uses Client_CS, Client_EIP, Client_ESP, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Bytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of bytes to pop from the stack. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Simulate_Far_Call}, {\b Simulate_Far_Ret}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Int 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt      ; interrupt number
\par VMMcall Simulate_Int
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates an interrupt in the current virtual machine. The service first calls any hook procedures set by the {\b Hook_V86_Int_Chain} service. If no hook procedure services the interrupt, this service pushes the 
{\b Client_Flags}, {\b Client_CS}, and {\b Client_IP} registers on the stack of the current virtual machine. When the virtual machine resumes execution (such as when an {\b Resume_Exec}
 service is called), the system carries out the simulated interrupt and executes the corresponding V86 mode interrupt routine. Uses Client_CS, Client_EIP, Client_Flags, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to simulate. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual PIC device uses this service to simulate hardware interrupts. Other virtual devices use the {\b Exec_Int} service to simulate interrupts. 
\par If the virtual machine is currently in V86 mode, this service simulates a V86 interrupt. Otherwise, the service simulates a protected-mode interrupt. Simulating an interrupt in a virtual machine running a protected-mode application can have undesirable ef
fects if the corresponding interrupt attempts to reflect the interrupt to V86 mode. 
\par Virtual devices that need immediate execution of an interrupt should use the {\b Exec_Int} service in a nested execution block. 
\par {\b Exec_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Iret 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Simulate_Iret
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simulates a return from an interrupt. This service pops the top three word or doubleword values from the stack of the current virtual machine, and places the values in the {\b Client_Flags}, {\b Client_CS}, and {
\b Client_EIP} or {\b Client_IP} registers. Uses Client_CS, Client_EIP, Client_ESP, Client_Flags, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service pops three word values from the stack if the segment corresponding to the return address is a 16-bit segment. Otherwise, the service pops three doubleword values. 
\par {\b Simulate_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Pop 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall Simulate_Pop
\par 
\par mov     [Value], eax        ; value popped from stack
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the word or doubleword value at the top of the stack of the current virtual machine, and adds two or four to the {\b Client_ESP} register. Uses Client_ESP, EAX, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the value popped from virtual machine stack in the EAX register. The high word is zero if in V86 mode, or the virtual machine is running a 16-bit program. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Simulate_Push}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Simulate_Push 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Value          ; value to push
\par VMMcall Simulate_Push
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pushes a word or doubleword value on the stack of the current virtual machine and subtracts two or four from the {\b Client_ESP} register. Uses Client_ESP, Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Value}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to push on the stack. In V86 mode or when the virtual machine is running a 16-bit program, only the low word is pushed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Simulate_Pop}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_PM_Int_Type 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt  ; interrupt number
\par mov     edx, Type       ; 0 if trap gate, else interrupt gate
\par VMMcall Set_PM_Int_Type
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the gate type for a protected-mode interrupt vector. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to set. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Type}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Type of gate to set. If this parameter is zero, the service sets a trap gate; if nonzero, it sets an interrupt gate. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
An interrupt passing through an interrupt gate automatically clears the interrupt flag bit to disable interrupts. Interrupts passing through a trap gate do not modify the interrupt bit. All protected-mode interrupts default to the trap gate type, but virt
ual devices such as the virtual PIC device, may change some trap gates to interrupt gates so that hardware interrupts disable interrupts. The virtual PIC device leaves software interr
upts, such as Interrupt 21h, unchanged. This avoids an unnecessary ring transition by eliminating the need for the software interrupt handlers to execute an {\b sti} instruction. 
\par {\b Get_PM_Int_Type}, {\b Set_PM_Int_Vector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_PM_Int_Vector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt       ; interrupt number
\par mov     cx, Segment          ; selector for interrupt routine
\par mov     edx, Offset          ; offset of interrupt routine
\par VMMcall Set_PM_Int_Vector
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the specified protected-mode interrupt vector to the address of the given interrupt routine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to set. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Segment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Selector of the code segment containing the interrupt routine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset to the interrupt routine. If the code segment containing the routine is a 16-bit segment, the high word of this parameter must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the {\b Set_PM_Int_Vector} service is called before the {\b Sys_VM_Init} message, the 
installed interrupt routine becomes part of the default interrupt vector table for every virtual machine. Otherwise, this service affects the interrupt vector table for the current virtual machine only. By default, each table entry points to a protected-m
ode breakpoint procedure that reflects the interrupt to V86 mode. 
\par {\b Get_PM_Int_Vector}, {\b Set_PM_Int_Type}, {\b Set_V86_Int_Vector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_V86_Int_Vector 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt   ; interrupt number
\par mov     cx, Segment      ; segment address of interrupt routine
\par mov     edx, Offset      ; offset of interrupt routine
\par VMMcall Set_V86_Int_Vector
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the specified real-mode interrupt vector to the address of the given interrupt routine. Uses Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the interrupt to set. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Segment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Segment address of the code segment containing the interrupt routine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset of the interrupt routine. The high word must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the {\b Set_V86_Int_Vector} service is called before the {\b Sys_VM_Init}
 message, the installed interrupt routine becomes part of the default interrupt vector table for every virtual machine. Otherwise, this service affects the interrupt vector table for the current virtual machine only. 
\par {\b Get_V86_Int_Vector}, {\b Set_PM_Int_Vector}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Test_VM_Ints_Enabled 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     ebp, OFFSET32 Client_Reg_Struc
\par VMMcall Test_VM_Ints_Enabled
\par jz      VM_Interrupts_Disabled
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the current VM interrupts are enabled or disabled. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The zero flag is clear if the VM's interrupts are enabled; the zero flag is set if they are disabled. 

\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to be tested. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Client_Reg_Struc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of {\b Client_Reg_Struc} structure containing the contents of the virtual machine's registers. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Simply checking the interrupt flag in the client registers is not a sufficient means of testing the condition of a VM's interrupts since another thread in the VM may have disabled the interrupts. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_V86_Int_Chain 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Interrupt
\par mov     esi, OFFSET32 Hook_Proc
\par VMMCall Unhook_V86_Int_Chain
\par jc      Error_Handler
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Removes the hook procedure for the specified interrupt. Uses flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Sets the carry flag if the interrupt number is invalid or the procedure was not found. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Interrupt}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The interrupt for which the hook procedure should be removed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Hook_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The hook procedure which should be removed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The hook procedure being removed must have been installed using the {\b Hook_V86_Int_Chain}. 
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 27 VMM Macros{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 27
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 VMM Macros 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About VMM Macros 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This chapter is an alphabetic listing of the virtual machine manager (VMM) macros. There are these macros: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ArgVar \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Mono_Out \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert_Client_Ptr \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Mono_Out_At \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert_Cur_Thread_Handle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 pCall \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert_Cur_VM_Handle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Pop_Client_State \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert_Ints_Disabled \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Push_Client_State \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert_Ints_Enabled \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Queue_Out \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert_Thread_Handle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 RestoreReg \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assert_VM_Handle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Return \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Assumes_Fall_Through \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SaveReg \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Begin_Control_Dispatch \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 sCall \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Begin_Service_Table \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ShiftState \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Begin_Touch_1st_Meg \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Trace_Out \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Begin_VxD_IO_Table \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMMCall \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BeginProc \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMMJmp \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 CallRet \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_CODE_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 cCall \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_CODE_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Client_Ptr_Flat \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_DATA_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Control_Dispatch \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_DATA_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Debug_Out \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_ICODE_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Debug_Printf \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_ICODE_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Declare_Virtual_Device \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_IDATA_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dispatch_Byte_IO \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_IDATA_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dword_Align \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_IO \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Emulate_Non_Byte_IO \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_LOCKED_CODE_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 End_Control_Dispatch \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_LOCKED_CODE_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 End_Service_Table \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_LOCKED_DATA_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 End_Touch_1st_Meg \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_LOCKED_DATA_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 End_VxD_IO_Table \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_PAGEABLE_CODE_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EndProc \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_PAGEABLE_CODE_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Fatal_Error \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_REAL_INIT_ENDS \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GetVxDServiceOrdinal \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxD_REAL_INIT_SEG \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IO_Delay \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxDCall \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IsDebugOnlyLoaded \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxDint \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 LeaveProc \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VxDJmp \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 LocalVar \cell \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 ArgVar 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par ArgVar varname, size, used
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Declares a stack argument for a procedure. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i varname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the name of the variable. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i size}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
A numeric expression specifying the size of the variable in bytes. The words BYTE, WORD, and DWORD, are acceptable as synonyms for 1, 2, and 4, respectively. If the value is not a multiple of four, the variable is padded to the nearest multiple of four. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i used}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 An optional parameter, normally omitted. If present and identical to the word NOTUSED, indicates that this parameter is not used. In such case, the ArgVar mac
ro will point the name at an intentionally undefined symbol. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is used in writing assembly-language procedures which use the C, Pascal, or StdCall calling convention. 
\par If the variable is a WORD, then two additional symbols are defined: varnameL refers to the low byte and varnameH refers to the high byte. If the variable is a DWORD, then six additional symbols are defined: varnameL refers to the low word, varnameLL to th
e low byte of the low word, varnameLH to the high byte of the low word, varnameH to the high word, varnameHL to the low byte of hte high word, and varnameHH to the high byte of the high word. 
\par When the EndProc is reached, the names of all ArgVar variables are set to an intentionally undefined symbol so that they cannot be used by accident later. (This behavior can be overridden by using the KEEPFRAMEVARS attribute on EndProc.) Here is an exampl
e procedure that uses these macros. The example procedure doesn't do anything interesting, but it illustrates the proper use of the macros. 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 BeginProc MyProc, CCALL
\par 
\par ArgVar Param1, DWORD
\par ArgVar Param2, WORD
\par ArgVar Param3, 12    ; third parameter is a 12-byte structure, 
\par                      ;   passed by value
\par 
\par LocalVar Local1, DWORD
\par LocalVar Local2, <size FOO>
\par 
\par EnterProc
\par SaveReg <ebx, esi>
\par lea  eax, Local2    ; eax now points to a FOO structure on the stack
\par mov  cx, Param2     ; cx contains the value of Param2
\par mov  Local1LL, ch   ; Store ch into the the low byte of the low 
\par                     ;   word of Local1
\par lea  edx, Param3    ; edx points to the 128-byte structure on the stack
\par RestoreReg <esi, ebx>
\par LeaveProc
\par Return
\par EndProc MyProc
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The above example illustrates several important points. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The first thing after the BeginProc is an optional list of ArgVars, naming the procedure arguments. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Immediately following the ArgVars is an optional list of LocalVars, naming the procedure local variables. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Immediately following the LocalVars is the EnterProc macro, which sets up the procedure local stack frame. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
The body of the procedure may use the SaveReg and RestoreReg macros to push and pop values from the stack. Using SaveReg and RestoreReg is mandatory if you use the ESP attribute on the BeginProc macro, otherwise the macros will access the wrong stack var
iables because you moved the stack pointer behind their back. Furthermore, the macros do not track jump instructi
ons, so jumping around inside an ESP procedure is fraught with peril. Unless you know what you're doing, you might be better off just not using the ESP attribute. 
\par {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab To return from a procedure, use the LeaveProc, then Return macros. Each procedure must contain exactly one LeaveProc and one Return. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assert_Cur_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assert_Cur_Thread_Handle ThreadHandle, level
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that the specified register is equal to the handle of the current thread. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the register containing the thread handle to check. The macro is more efficient if the thread handle is in the EDI register, but any 32-bit register is allowed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter which specifies the debugging level for which the macro should generate code. The default is DeblevelNormal. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro does not generate code unless the DEBUG symbol is defined. If the macro generates code, the code calls the Debug_Test_Cur_Thread_Handle service. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assert_Client_Ptr 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assert_Client_Ptr reg, level
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that the specified register is a pointer to the current set of client registers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i reg}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the register containing the pointer to check. The macro is more efficient if the client pointer is in the EBP register, but any 32-bit register is allowed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter which specifies the debugging level for which the macro should generate code. The default is DeblevelNormal. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro does not generate code unless the DEBUG symbol is defined. If the macro generates code, the code calls the Validate_Client_Ptr service. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assert_Cur_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assert_Cur_VM_Handle VM, level
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that the specified register is equal to the handle of the current virtual machine. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the register containing the virtual machine handle to check. The macro is more efficient if the thread handle is in the EBX register, but any 32-bit register is allowed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter which specifies the debugging level for which the macro should generate code. The default is DeblevelNormal. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro does not generate code unless the DEBUG symbol is defined. If the macro generates code, the code calls the Debug_Test_Cur_VM_Handle service. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assert_Ints_Disabled 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assert_Ints_Disabled
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that interrupts are currently disabled. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
If the DEBUG symbol is defined, the macro generates code which checks that interrupts are disabled. If interrupts are enabled, the generated code will print an error message and stop in the debugger if a debugger is installed. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assert_Ints_Enabled 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assert_Ints_Enabled
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that interrupts are currently disabled. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
If the DEBUG symbol is defined, the macro generates code which checks that interrupts are enabled. If interrupts are disabled, the generated code will print an error message and stop in the debugger if a debugger is installed. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assert_Thread_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assert_Thread_Handle ThreadHandle, level, USES_FLAGS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts that the specified thread handle is valid. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. The macro does not return if the handle is not valid. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the register containing the thread handle to check. The macro is more efficient if the thread handle is in the EDI register, but any 32-bit register is allowed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter which specifies the debugging level for which the macro should generate code. The default is DeblevelNormal. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i USES_FLAGS}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter which, if equal to the literal USES_FLAGS, indicates that the macro is allowed to modify the flags register. The default is to preserve flags. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro does not generate code unless the DEBUG symbol is defined. If the macro generates code, the code calls the Debug_Test_Valid_Thread_Handle service. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assert_VM_Handle 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assert_VM_Handle VM, level, USES_FLAGS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Determines whether the specified virtual machine handle is valid. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. The macro does not return if the handle is not valid. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the register containing the virtual machine handle to check. The macro is more efficient if the virtual machine handle is in the EBX register, but any 32-bit register is allowed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter that specifies the debugging level for which the macro should generate code. The default value is DevlevelNormal. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i USES_FLAGS}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter which, if equal to the literal USES_FLAGS, indicates that the macro is allowed to modify the flags register. The default value preserves flags. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is only available in the debugging version of Windows. 
\par This macro does not generate code unless the DEBUG symbol is defined. If the macro generates code, the code calls the {\b Debug_Test_Valid_Handle} service. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Assumes_Fall_Through 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Assumes_Fall_Through labelname
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Asserts at compile time that the indicated label comes next. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i labelname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the label to check. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro may be used when one procedure falls through to another, so that an error will be raised at compile time if the condition is not met. Example: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 BeginProc FirstProc
\par \tab mov\tab \tab eax, 1
\par \tab Assumes_Fall_Through SecondProc\tab \tab ; fall through to SecondProc
\par EndProc FirstProc
\par 
\par BeginProc SecondProc
\par \tab ... do something with EAX ...
\par \tab retd
\par EndProc SecondProc
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If anybody ever inserts code between FirstProc and SecondProc, the Assumes_Fall_Through macro will raise an error, thus catching the bug automatically. This may look stupid here,
 but imagine if there was a 200-line comment block between the two procedures. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Control_Dispatch 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Begin_Control_Dispatch DeviceName
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Builds a table for dispatching messages passed to the control procedure for the specified virtual device. This macro is used in conjunction with the {\b Control_Dispatch} and {\b End_Control_Dispatch} macros. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DeviceName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the virtual device. The macro uses this parameter to construct the label for the control procedure (appends {\b _Control}
 to the end of this name). This control procedure label must also be specified in the {\b Declare_Virtual_Device} macro. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b Control_Dispatch} macro can be used without {\b Begin_Control_Dispatch}
, but then it the programmer's responsibility to declare a procedure in locked code (VxD_LOCKED_CODE_SEG), and clear the carry flag for any unprocessed messages. The advantage in using {\b Begin_Control_Dispatch}
 macro is when a large number of messages are processed by a device. The macro builds a jump table which usually requires less code than the sequence of compare and jump instructions that are generated when {\b Control_Dispatch} is used alone. 
\par The following example builds a complete dispatch table for the virtual device named MyDevice: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Begin_Control_Dispatch MyDevice
\par Control_Dispatch  Device_Init, MyDeviceInitProcedure
\par Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
\par Control_Dispatch  Create_VM,   MyDeviceCreateVMProcedure
\par End_Control_Dispatch MyDevice
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 An alternative method for writing the control procedure is as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 BeginProc MyDevice_Control
\par Control_Dispatch  Device_Init, MyDeviceInitProcedure
\par Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
\par Control_Dispatch  Create_VM,   MyDeviceCreateVMProcedure
\par clc                                              ; Don't forget
\par ret                                              ; these two lines!
\par EndProc MyDevice_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If you use the CallType variant of the {\b Control_Dispatch} macro, you may not use the {\b Begin_Control_Dispatch} macro; you must use this alternative method. 
\par {\b Control_Dispatch}, {\b Declare_Virtual_Device}, {\b End_Control_Dispatch}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 BeginProc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par BeginProc ProcName, Attributes
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks the start of a procedure having the specified attributes. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ProcName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure to create. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Attributes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 One or more procedure attributes. Can be any number of these attributes, with multiple attributes separated by commas: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Attribute \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HIGH_FREQ \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Specifies a frequently called procedure. The macro aligns the start of the procedure on a doubleword boundary to optimize calls to the procedure. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
PUBLIC \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Creates a global procedure that other procedures in the virtual device can call. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PCALL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use the Pascal calling convention. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 CCALL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use the C calling convention. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SCALL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use the StdCall calling convention. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ESP \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Use ESP instead of EBP to access arguments. See caveats below. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 HOOK_PROC, hook_var \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 This procedure is being used to hook a service or fault. See remarks below. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 segment_type \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Place the procedure in the segment_type code segment. Valid segment types are LOCKED, INIT, PAGEABLE, STATIC, DEBUG_ONLY, SYSEXIT, INT21, RARE, W16, W32, VMCREATE, VMDESTROY, THCREATE, THDESTROY, VMSUSPEND, VMRESUME, PNP, DOSVM, and LOCKABLE. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 If the DEBUG symbol is defined, then the following keywords are also recognized. (If the DEBUG symbol is not defined, then the following keywords have no effect.) 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Attribute \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 NO_LOG \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Prevents entry to this procedure from being logged via Log_Call_Proc. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 SERVICE \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Indicates that this procedure is an exported service. Additional code is generated to ensure that the service is not called asynchronously, as well some code for system performance profiling, and checking that basic ring 0 assumptions are not violated. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ASYNC_SERVICE \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
The same as SERVICE, except that the check that the service is not called asynchronously is not performed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 NO_PROFILE \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 If the procedure is a service, disables the generation of code which does performance profiling. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 NO_TEST_CLD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Disables the normal check that the processor direction flag is clear (up). \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 TEST_BLOCK \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Generate code to check on entry to the procedure that there are no outstanding ENTER_NOBLOCK calls. This is the default if the procedure resides in pageable code. See _Debug_Flags_Service for more information. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 TEST_REENTER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Generate code to check on entry to the procedure that VMM has not been re-entered. See _Debug_Flags_Service for more information. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 NEVER_REENTER 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Generate code to check on entry to the procedure that VMM has not been re-entered, not even when Begin_Reentrant_Execution has been called. See _Debug_Flags_Service for more information. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 NOT_SWAPPING \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Generate code to check on entry to the procedure that the current thread is not swapping. See _Debug_Flags_Service for more information. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If a procedure is mark
ed ASYNC_SERVICE, then it must be re-entrant, must not call synchronous services, and must restrict itself to locked code and data. Asynchronous services may be called by interrupt handling routines when processing interrupts. Therefore, virtual devices w
hich export asynchronous services must be prepared for the service to be called any time interrupts are disabled. 
\par Marking a procedure as PCALL, SCALL, or CCALL indicates to the ArgVar, LocalVar, EnterProc, LeaveProc and Return macros how code should be gen
erated to access procedure parameters and local variables, and how code should be generated to return to the calling procedure. 
\par If a procedure is marked ESP, then extra care must be taken to maintain the assumptions made by the ArgVar and LocalVar macros. All stack pushes must be performed with the SaveReg macro, and all stack pops must be performed with the RestoreReg macro. You 
may not adjust the stack manually, and you may not jump over code that adjusts the stack. These are relatively severe restrictions, but that's the way it is. If you can't live within them, then don't use the ESP attribute. Nobody's forcing you. 
\par If a procedure will be passed to Hook_Device_Service, Hook_V86_Fault, Hook_PM_Fault, or Hook_VMM_Fault, then it must be marked with the HOOK_PROC attribute so that the service can be unhooked. This is important, even if you do not plan to unhook the servi
ce or fault yourself. Failure to comply may prevent other virtual devices from unhooking the service. The hook_var parameter is the name of
 the variable into which the address of the previous hook will be stored. See the discussion of hook procedure in the Overview for additional information about hook procedures. 
\par If a segment type is provided, then the procedure will be placed in the segment named VxD_segment_type_CODE_SEG. This is provided for convenience in procedure-level page tuning. 
\par {\b EndProc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Service_Table 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Begin_Service_Table DeviceName
\par Begin_Service_Table DeviceName, DefSegment
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks the start of the service table for a virtual device. A virtual device uses the service table to export the names and addresses of its services. Other virtual devices can use the {\b VxDCall}
 macro to call these services. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DeviceName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the virtual device. This name is used to create a macro, named {\i DeviceName}{\b _Service}
, that is used in the table to define each exported service. For more information about the macro, see below. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DefSegment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Not used with Windows95 VxDs. This parameter exists solely for compatibility with Windows 3.1 VxDs. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device exports its services by defining the symbol {\b Create_}{\i DeviceName}{\b _Service_Table} before using the {\b Begin_Service_Table} macro. Virtual devices that call these service also use the {
\b Begin_Service_Table} macro but must {\i not} define the {\b Create_}{\i DeviceName}{\b _Service_Table} symbol. 
\par The complete service table has the following form: 
\par {\b Begin_Service_Table} {\i DeviceName}
\par {\i DeviceName}{\b _Service} {\i Procedure}, {\i LocalSeg}
\par  . 
\par  . 
\par  . 
\par {\b End_Service_Table} {\i DeviceName}
\par The {\i DeviceName}{\b _Service} macro, created by {\b Begin_Service_Table}, adds the specified service to the table. A table may have any number of these macros. 
\par The {\i Procedure} parameter specifies the name of the service to add to the table. If RESERVED is given, the macro reserves an entry in the table instead of adding a procedure. 
\par The {\i LocalSeg} parameter specifies which segment contains the procedure. This parameter is optional and exists for compatibility with Windows 3.1. You shouldn't need to provide a local segment. 
\par {\b End_Service_Table}, {\b VxD_LOCKED_DATA_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Touch_1st_Meg 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Begin_Touch_1st_Meg
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Enables the first 1 megabyte of memory for the current virtual machine. Virtual devices use this macro to examine and modify addresses in the first megabyte. This macro is intended to be used for debugging purposes. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro does not generate code unless the DEBUG symbol is defined. If the macro generates code, the code calls the {\b Enable_Touch_1st_Meg} service. 
\par {\b Enable_Touch_1st_Meg}, {\b End_Touch_1st_Meg}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_VxD_IO_Table 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Begin_VxD_IO_Table TableName
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks the beginning of an I/O table. Virtual devices use the macro in conjunction with the {\b End_VxD_IO_Table} and {\b VxD_IO} macros to create a table of I/O callback procedures for the {\b 
Install_Mult_IO_Handlers} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TableName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the table. This parameter can be used in subsequent calls to the {\b Install_Mult_IO_Handlers} to specify the address of the table. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Install_Mult_IO_Handlers}, {\b End_VxD_IO_Table}, {\b VxD_IO}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 CallRet 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par CallRet Procedure
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Calls or jumps to the specified procedure, depending on whether the DEBUG symbol is defined. If DEBUG is defined, the macro generates a call to the procedure followed by a return instruction. Otherwise, the macro generates a jump to the procedure. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Procedure}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure or service to call. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Log_Proc_Call}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 cCall 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par cCall Procedure
\par cCall Procedure, Param1, Flags
\par cCall Procedure, <Param1, Param2, Param3, ..., ParamN>, Flags
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pushes the specified parameters on the stack and calls the specified procedure. When the procedure returns, the macro pops the parameters from the stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The return value depends on the specified procedure. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Procedure}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure to call. This parameter can be either a local or public procedure, but must be defined within the virtual device making the call. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1, Param2, Param3, ..., ParamN}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameters to pass to the procedure. If more than one parameter is given, they must be separated with commas and enclosed in angle brackets (<>). 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter, that if set to the value PRESERVE_FLAGS, causes the {\b cCall} macro to preserve the flags register on return from the called procedure. The {\b cCall}
 macro normally changes the contents of the flags register as part of its cleanup operations. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro pushes the parameters using the C-language calling convention, in order from right to 
left, then removes the parameters from the stack after the procedure returns. It also assumes that the called procedure follows the C-language register conventions, viz., that the EAX, ECX, EDX, and flags registers may be modified by the call, and that th
e return value is placed in the EAX register (and sometimes also the EDX register). If your procedure does not follow these rules, you should not use the {\b cCall} macro. 
\par {\b VMMCall}, {\b VxDCall}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Client_Ptr_Flat 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Client_Ptr_Flat LinAddr, Segment, Offset
\par Client_Ptr_Flat LinAddr, Segment, Offset, USES_EAX
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Converts the specified segment:offset or selector:offset or segment:offset pair from the client register into a linear address. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns the linear address in the register specified by the LinAddr parameter, if successful. If the specified selector is invalid, the service returns \endash  1 in the specified register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i LinAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 32-bit register to receive the linear address. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Segment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Client segment register containing the segment address or selector to convert. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Client register containing the address offset to convert. If this optional parameter is not given, the macro converts the address using address offset 0. You can specify either a 16-bit or 32-bit general-purpose register. The macro will use the low word o
r the full 32-bit register, depending on whether the client is in 16-bit or 32-bit mode. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i USES_EAX}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
If the word USES_EAX is appended to the macro call, the macro will use the EAX register as a scratch register. Normally the macro preserves all registers except LinAddr. The macro is slightly more efficient if it is allowed to damage the EAX register. 

\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The Client_Ptr_Flat macro uses the {\b Map_Flat} service. 
\par This example converts the address {\b Client_DS}:{\b Client_(E)DX}, and places the corresponding linear address in the EAX register: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Client_Ptr_Flat eax, DS, DX
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Map_Flat}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Control_Dispatch 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Control_Dispatch Message, Procedure
\par Control_Dispatch Message, Procedure, CallType, <Param1, Param2, ...>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Dispatches the given control message to the specified procedure. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Message}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Identifies the control message. Can be one of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Description \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Begin_PM_App \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A protected-mode application is starting. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Close_VM_Notify \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A virtual machine is closing. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Create_Thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 New thread being created. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Create_VM \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A virtual machine is being created. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Critical_Reboot_Notify \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 System is restarting (interrupt disabled). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Debug_Query \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Requests for virtual device's debugging interface. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Destroy_Thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread being destroyed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Destroy_VM \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A virtual machine is being destroyed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Device_Init \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual devices initializing (interrupts enabled). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Device_Reboot_Notify \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 System is restarting (interrupts enabled). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 End_PM_App \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A protected-mode application is ending. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Init_Complete \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 All virtual devices have initialized. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PNP_New_Device \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 New devnode (directed). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Power_Event \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Power is being suspended or resumed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reboot_Processor \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual device must restart system if it can. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Set_Device_Focus \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 A virtual device is taking the focus. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sys_Critical_Exit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 System is terminating (interrupt disabled). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sys_Critical_Init \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual devices initializing (interrupts disabled). \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sys_VM_Init \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 System VM is being created. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sys_Dynamic_Device_Exit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dynamic VxD being unloaded (directed). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sys_Dynamic_Device_Init \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dynamic VxD being loaded (directed). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Sys_VM_Terminate \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 System VM is being destroyed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 System_Exit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 System is terminating (interrupts enabled). \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Terminate_Thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread being terminated. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread_Init \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread being initialized. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread_Not_Executeable \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread has stopped executing. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VM_Critical_Init \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine being created (interrupts disabled). \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VM_Init \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine being created (interrupts enabled). \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VM_Not_Executable \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine has stopped executing. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VM_Resume \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine execution resumed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VM_Suspend \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine execution suspended. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VM_Terminate \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine begin destroyed. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 W32_DeviceIoControl \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Win32 DeviceIoControl entry (directed). \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Another value defined in vmm.h is also acceptable. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Procedure}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure to which to dispatch the message. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CallType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Optional parameter that describes the calling convention employed by the procedure. The default value indictates that the procedure is called directly without any special pre- or post-processing. Otherwise, the value may be {\b cCall}, {\b pCall}, or {\b 
sCall}, indicating that the procedure should be called with the C, Pascal, or StdCall calling convention, respectively. See below for additional remarks. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1, Param2, ...}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameters to be passed to the procedure. Typically, registers are pushed as parameters. See below for additional remarks. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is typically used in conjunction with the {\b Begin_Control_Dispatch} and {\b End_Control_Dispatch} macros to build a dispatch table. The {\b Control_Dispatch} macro can be used without the {\b 
Begin_Control_Dispatch} macro, but becomes the programmer's responsibility to declare a procedure in locked code (VxD_LOCKED_CODE_SEG), and clear the carry flag for any messages not processed. 
\par If you use the {\i CallType} variant of this macro, then this macro may not be combined with the {\b Begin_Control_Dispatch} and {\b End_Control_Dispatch} macros. 
\par {\b Begin_Control_Dispatch}, {\b End_Control_Dispatch}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Debug_Out String
\par Debug_Out String, level
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes the specified string to the debugging device, and halts in the debugger if a debugger is attached. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 String to display. The string must be enclosed in double quotation marks. The string can contain register placeholders in the same forms as described for the {\b Out_Debug_String} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Optional symbol indicating the debugging level for which code should be generated. If the value of the Deblevel symbol is greater than or equal to level, then code is generated. Otherwise, code is not generated. The s
ymbol can be DeblevelNormal or DeblevelMax. The default is DeblevelNormal. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Additional macros exist, such as Debug_OutX, where X is a conditional jump type, i.e., something that can follow the letter j to form a conditional jump instruction. In such case, the debug-out is performed only if the condition is satisfied. 
\par Examples: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 ; The following message is printed only if Deblevel  Deblevelmax
\par Debug_Out "Error!  Mumble mumble", Deblevelmax
\par cmp    nFrobs, 5
\par Debug_OutA "Error! More than 5 frobs!"
\par 
\par cmp [esi].dwSignature, 31415927h
\par Debug_OutNZ "Error!  Invalid signature!"
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The assembler generates code for the macro only if the constant DEBUG is defined before including the DEBUG.INC file. 
\par {\b Out_Debug_String}, {\b Test_Debug_Installed}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Printf 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Debug_Printf FormatString, <Param1, Param2, ...>, level
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes the specified string to the debugging device, using C-style formatting. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i FormatString}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Format string for output. This string may contain C-style formatting sequences. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1, Param2, ...}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Substitution arguments for the format string. This parameter is optional; if omitted, the FormatString must not contain any % substitutions. Moreover, there must be enough parameters to correspond to the number of substitutions required by the format stri
ng. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional symbol indicating the debugging level for which code should be generated. If the value of the Deblevel symbol is greater than or equal to level, then code is generated. Otherw
ise, code is not generated. The symbol can be DeblevelNormal or DeblevelMax. The default is DeblevelNormal. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The assembler generates code for the macro only if the constant DEBUG is defined before including the DEBUG.INC file, in which case it uses _Debug_Printf_Service to do the work. See the description of _Debug_Printf_Service for additional remarks and restr
ictions. 
\par {\b Out_Debug_String}, {\b Test_Debug_Installed}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Declare_Virtual_Device 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Declare_Virtual_Device Name, MajorVer, MinorVer, CtrlProc, DeviceNum,
\par                        InitOrder, V86Proc, PMProc
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the name, device number, control procedure, and other attributes of a virtual device. Every virtual device must use the {\b Declare_Virtual_Device} macro. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Name}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the virtual device. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i MajorVer}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the major version number for the virtual device. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i MinorVer}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the minor version number for the virtual device. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CtrlProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Name of the control procedure for the virtual device. The control procedure handles all system control messages sent to the virtual device. For most virtual devices, this parameter is the name of the procedure created by the {\b Begin_Control_Dispatch}
 macro. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DeviceNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Device identifier for the virtual device. If the virtual device replaces an existing virtual device, the device identifier must be be identical to the device identifier of the virtual device being replaced. Otherwise, the value must be Undefined_
Device_ID or a value previously obtained from Microsoft. 
\par Since Windows 95 supports name-based VxD services, it is no longer necessary to obtain a virtual device identifier from Microsoft. Instead, set the DeviceNum to Undefined_Device_ID and use name-based services to access your VxD. (Do not make up device num
bers.) 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i InitOrder}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value speifying the initialization order of the virtual device rel
ative to other virtual devices. If you are replacing an existing virtual device, this value must be the same as that of the device you are replacing. If your device is not sensitive to initialization order, use Undefined_Init_Order. If your device needs t
o initialize at a particular time relative to another device, make the initialization order relative to the init order of that other device. When doing so, use a generous offset such as XX_Init_Order + 00040000h or XX_Init_Order \endash 
 0004000h, so as to allow room for additional devices to be inserted later. Do not use values like XX_Init_Order + 1 or XX_Init_Order \endash  1. Do not use VMM_Init_Order or Debug_Init_Order. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i V86Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the V86-mode API procedure. This procedure processes any calls to the virtual device made by V86-mode applications running in a virtual machine. This parameter is optional. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PMProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the protected-mode API procedure. This procedure processes any calls to the virtual device made by protected-mode applications running in a virtual machine. This parameter is optional. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_Control_Dispatch}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Dispatch_Byte_IO 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Dispatch_Byte_IO In_Proc, Out_Proc
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Checks the size of the I/O request and dispatches the request to either the {\b Simulate_IO}
 service, or to the specified single-byte input or output procedure. I/O callback procedures use this macro to simplify processing of I/O requests. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i In_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure to carry out a single-byte input operation. If this parameter is the {\b Fall_Through} keyword, the macro ignores input operations. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Out_Proc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure to carry out a single-byte output operation. If this parameter is the {\b Fall_Through} keyword, the macro ignores output operations. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The EAX, EBX, ECX, EDX, and EBP registers must contain values specified as valid input parameters for the {\b Simulate_IO} service. {\b Dispatch_Byte_IO}
 checks the ECX register for the I/O type. If this type specifies an I/O request that is larger than a byte, the macro jumps to the {\b Simulate_IO} service. 
\par {\b Emulate_Non_Byte_IO}, {\b Simulate_IO}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Dword_Align 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Dword_Align SegName
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Aligns the specified segment on a doubleword boundary by inserting {\b nop} instructions. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SegName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the segment to align. This parameter can be _TEXT, _ITEXT, or _LTEXT. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Emulate_Non_Byte_IO 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Emulate_Non_Byte_IO
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Checks the size of the I/O request and jumps to the {\b Simulate_IO} service if the request is larger than a byte. I/O callback procedures use this macro to simplify processing of I/O requests. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The EAX, EBX, ECX, EDX, and EBP registers must contain values specified as valid input parameters for the {\b Simulate_IO} service. {\b Emulate_Non_Byte_IO}
 checks the ECX register for the I/O type. If this type specifies an I/O request that is larger than a byte, the macro jumps to the {\b Simulate_IO} service. 
\par {\b Dispatch_Byte_IO}, {\b Simulate_IO}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Control_Dispatch 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par End_Control_Dispatch DeviceName
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks the end of a dispatch table for a virtual device. This macro is used in conjunction with the {\b Control_Dispatch} and {\b Begin_Control_Dispatch} macros to build the table. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DeviceName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the virtual device. This name must have been used with the {\b Begin_Control_Dispatch} macro that started the table. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_Control_Dispatch}, {\b Control_Dispatch}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 EndProc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par EndProc ProcName
\par EndProc ProcName, NoCheck
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks the end of a procedure definition. This macro is used in conjunction with the {\b BeginProc} macro to define a procedure in a virtual device. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ProcName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure. This name must have been used in the {\b BeginProc} macro that started the procedure definition. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NoCheck}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 If the optional NoCheck keyword is provided, then the normal compile-time checks for stack balance and proper use of the {\b ArgVar}, {\b LocalVar}, {\b EnterProc}, {\b LeaveProc}, and {\b Return}
 macros is suppressed. The default value performs the checks. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b BeginProc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Service_Table 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par End_Service_Table DeviceName, DefSegment
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks the end of the service table for a virtual machine. This macro is used in conjunction with the {\b Begin_Service_Table} macro to create a service table. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DeviceName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the virtual device. This name must be the same as specified by the corresponding {\b Begin_Service_Table} macro. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i DefSegment}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Not used by Windows95 VxDs and should be omitted. This parameter exists for compatibility with Windows 3.1 VxDs. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_Service_Table}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Touch_1st_Meg 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par End_Touch_1st_Meg
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Disables the first 1 megabyte of memory for the current virtual machine. Virtual devices use this macro in conjunction with the {\b Begin_Touch_1st_Meg}
 macro to examine and modify addresses in the first megabyte. This macro is intended to be used for debugging purposes. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro does not generate code unless the DEBUG symbol is defined. If the macro generates code, the code calls the {\b Disable_Touch_1st_Meg} service. 
\par {\b Begin_Touch_1st_Meg}, {\b Disable_Touch_1st_Meg}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_VxD_IO_Table 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par End_VxD_IO_Table TableName
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Marks the end of an I/O table. Virtual devices use the macro in conjunction with the {\b Begin_VxD_IO_Table} and {\b VxD_IO} macros to create a table of I/O callback procedures for the {\b 
Install_Mult_IO_Handlers} service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TableName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the I/O table. This parameter must have been previously defined in a matching {\b Begin_VxD_IO_Table} macro. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_VxD_IO_Table}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Fatal_Error 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Fatal_Error Msg_Ptr, Exit_Flags
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Calls the {\b Fatal_Error_Handler} service which terminates Windows. A virtual device typically calls this macro in response to an unrecoverable error. The macro passes the {\i Msg_Ptr} and {\i Exit_Flags}
 parameters (if given) to {\b Fatal_Error_Handler}. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This macro never returns. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Msg_Ptr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a null-terminated string. This parameter is optional. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Exit_Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Exit flags. This optional parameter can be the following value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 EF_Hang_On_Exit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Hangs the system on a fatal exit. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following example quits Windows without displaying an error message: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Fatal_Error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following example quits Windows, and prints the error message pointed to by My_Err_Msg: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Fatal_Error <OFFSET32 My_Err_Msg>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Fatal_Error_Handler}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 GetVxDServiceOrdinal 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par GetVxDServiceOrdinal reg, ServiceName
\par 
\par #include <vmm.h>
\par 
\par DWORD dwServiceOrdinal = GetVxDServiceOrdinal(ServiceName);
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Obtains the virtual device service ordinal, for use by {\b Hook_Device_Service}. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
The assembly language macro returns the ordinal for the named service in the specified register. The C language macro returns the ordinal as its return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i reg}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Register to receive the virtual device service ordinal. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ServiceName}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of service for which to obtain the ordinal. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro must be used whenever you need to obtain a virtual device service ordinal. The method employed by Windows 3.1 no longer works. 
\par Example: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16     GetVxDServiceOrdinal eax, DOSMGR_Begin_V86_App
\par     mov      esi, offset32 BeginPmAppHook
\par     VMMCall  Hook_Device_Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b VxD_REAL_INIT_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 IO_Delay 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par IO_Delay
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Delays the execution of the next instruction so that an I/O device has time to carry out an I/O operation. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro generates a {\b jmp} instruction to the next instruction. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 IsDebugOnlyLoaded 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par IsDebugOnlyLoaded
\par IsDebugOnlyLoaded labelname
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Skips to the named label if debug-only segments are not loaded. Yes, this macro's name is backwards. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab If labelname is omitted, sets the zero flag if debug-only segments are not present. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i labelname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional label to jump to if debug-only segments are not loaded. If omitted, this macro sets flags as described above. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro must be used whenever code that is unconditionally loaded calls into code or accesses memory in debug-only segments, lest you accidentally access objects that don't exist. Example: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 \tab IsDebugOnlyLoaded notracing
\par \tab call\tab Tracing\tab \tab \tab ; the Tracing procedure resides in a debug-only segment
\par notracing:
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 LeaveProc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par LeaveProc
\par LeaveProc PRESERVE_FLAGS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Prepares to exit a procedure by removing local stack variables. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PRESERVE_FLAGS}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
An optional parameter, normally omitted. If present and identical to the word PRESERVE_FLAGS, indicates that the act of removing local stack variables should not modify the flags register. This is in violation of the C, Pascal, and StdCall calling convent
ions (that flags are unimportant) and generates slower code, so it should be avoided if at all possible. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is used in writing assembly-language procedures which use the C, Pascal, or StdCall calling convention. See the description of the {\b ArgVar} macro for additional information. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 LocalVar 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par LocalVar varname, size
\par LocalVar varname, size, PACK
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Declares a stack local variable for a procedure. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i varname}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the name of the variable. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i size}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
A numeric expression specifying the size of the variable in bytes. The words BYTE, WORD, and DWORD, are acceptable as synonyms for 1, 2, and 4, respectively. If the value is not a multiple of four, the variable is padded to the next multiple of four. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PACK}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
An optional parameter, normally omitted. If present and identical to the word PACK, indicates that the traditional padding to the next multiple of four is suppressed. Packing local variables should be done with care, lest you end up with a total size of l
ocal variables not a multiple of four. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is used in writing assembly-language procedures which use the C, Pascal, or StdCall calling convention. See the description of the {\b ArgVar} macro for additional information. 
\par If the variable is a WORD, then two additional symbols are defined: varnameL refers to the low byte and varnameH refers to the high byte. If the variable is a DWORD, then six additional symbols are defined: {\i varnameL }refers to the low word, {\i 
varnameLL} to the low byte of the low word, {\i varnameLH} to the high byte of the low word, {\i varnameH} to the high word, {\i varnameHL} to the low byte of the high word, and {\i varnameHH} to the high byte of the high word. 
\par When the {\b EndProc}
 is reached, the names of all LocalVar variables are set to an intentionally undefined symbol so that they cannot be used by accident later. (This behavior can be overridden by using the KEEPFRAMEVARS attribute on EndProc.) Here is an example of the PACK 
attribute: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 LocalVar MyLocal, DWORD
\par LocalVar First, BYTE, PACK
\par LocalVar Second, BYTE, PACK
\par LocalVar Third, BYTE, PACK
\par LocalVar Fourth, BYTE, PACK
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This example declares eight bytes of local variables. The first four bytes are a DWORD, named MyLocal. The fifth byte is a BYTE variable named First, the sixth a BYTE variable named Second, the seventh a BYTE variable named Third, and the eighth a BYTE va
riable named Fourth. If the PACK attributes were omitted, this sequence of declarations would have created twenty bytes of local variables, with three bytes of padding inserted after each BYT
E variable. Note carefully that the BYTE variables come in groups of four so as to maintain stack dword alignment. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Mono_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Mono_Out String, nocrlf
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Calls the {\b Out_Mono_String} service to display the given string. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 String to display, enclosed in double quotation marks. The string can contain register placeholders in the same forms as described for the {\b Out_Mono_String} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nocrlf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter specifying that the macro should {\i not} append a carriage return and newline character combination to the string. If this parameter is {\i not}
 given, the macro appends the character combination by default. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The assembler generates code for the macro only if the DEBUG constant is defined before including the DEBUG.INC file. 
\par The following example writes a string to the secondary display device: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Mono_Out "Element not found"
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following example writes a string containing the value of the AX register to the debugging device: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Mono_Out "AX value is #AX"
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Out_Mono_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Mono_Out_At 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Mono_Out_At Row, Column, String, nocrlf
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Calls the {\b Set_Mono_Cur_Pos} service to position the cursor, then calls the {\b Out_Mono_String} service to display the given string. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Row} and {\i Column}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Row and column number at which to position the cursor before displaying the string. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 String to display, enclosed in double quotation marks. The string can contain register placeholders in the same forms as described for the {\b Out_Mono_String} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nocrlf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter specifying that the macro should {\i not} append a carriage return and newline character combination to the string. If this parameter is {\i not}
 given, the macro appends the character combination by default. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The assembler generates code for the macro only if the DEBUG constant is defined before including the DEBUG.INC file. 
\par The following example writes a string starting at the position (10,10) on the secondary display device: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Mono_Out_At 10,10,"Element not found"
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Out_Mono_String}, {\b Set_Mono_Cur_Pos}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 pCall 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par pCall Procedure
\par pCall Procedure, Param1
\par pCall Procedure, <Param1, Param2, Param3, ..., ParamN>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pushes the specified parameters on the stack and calls the specified procedure. The called procedure is expected to remove the parameters from the stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The return value depends on the specified procedure. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Procedure}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure to call. This parameter can be either a local or public procedure, but must be defined within the virtual device making the call. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1, Param2, Param3, ..., ParamN}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Parameters to pass to the procedure. If more than one parameter is given, they must be separated with commas and enclosed in angle brackets (<>). Parameters are optional. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro pushes the parameters using the Pascal-language calling convention, in order from left to right. I
t also assumes that the called procedure follows the Pascal-language register conventions, viz., that the EAX, ECX, EDX, and flags registers may be modified by the call, and that the return value is placed in the EAX register (and sometimes also the EDX r
egister). If your procedure does not follow these rules, you should not use the pCall macro. 
\par {\b VMMCall}, {\b VxDCall}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Pop_Client_State 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Pop_Client_State
\par Pop_Client_State USES_ESI
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Restores the client registers for the virtual machine. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i USES_ESI}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter specifying that the macro may use the ESI register as a scratch register. Normally, {\b Pop_Client_State}
 preserves all registers. Slightly more efficient code is generated if ESI may be used. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro must not be used unless the {\b Push_Client_State} macro was previously used to save the client registers. 
\par {\b Push_Client_State}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Push_Client_State 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Push_Client_State
\par Push_Client_State USES_ESI
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Copies the client state to the protected-mode stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i USES_ESI}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter specifying that the macro may use the ESI register as a scratch register. Normally, {\b Push_Client_State}
 preserves all registers. Slightly more efficient code is generated if ESI may be used. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro reserves space on the stack for the client registers. 
\par A virtual device must use the {\b Pop_Client_State} macro to restore the client registers, and free the reserve stack space. 
\par {\b Pop_Client_State}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Queue_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Queue_Out String, Value1, Value2
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Calls the {\b Queue_Debug_String} service to queue the given string for display at a later time. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 String to display, enclosed in double quotation marks. The string can contain register placeholders in the same forms as described for the {\b Queue_Debug_String} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Value1}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to queue with the string. If the string contains the #EAX or ?EAX placeholder, this value is used when the string is displayed. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Value2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to queue with the string. If the string contains the #EBX or ?EBX placeholder, this value is used when the string is displayed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The assembler generates code for the macro only if the DEBUG constant is defined before including the DEBUG.INC file. 
\par The following example queues a string: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Queue_Out "Element not found"
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following example queues a string containing the value of the EAX register to the debugging device: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Queue_Out "EAX value is #EAX", EAX
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Queue_Debug_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 RestoreReg 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par RestoreReg <reg1, reg2, reg3, ...>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pops values off the stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b RestoreReg} pops the values off the stack in the order specified. Note that if this is to match a corresponding {\b SaveReg}, the values need to be specified in reverse order in the {\b RestoreReg}
, compared to the {\b SaveReg}. The arguments are typically the names of registers, but can be anything that can validly follow the 'pop' opcode. The special name 'fd' pops flags via
 the 'popfd' instruction and the special name 'ad' pops all registers via the 'popad' instruction. 
\par Using the {\b RestoreReg} macro instead of coding the corresponding instructions manually is required if the procedure is using an ESP-based stack frame. 
\par See the description of the {\b ArgVar} macro for additional information. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Return 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Return
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Return from a procedure, possibly removing stack arguments as well. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro
 is used in writing assembly-language procedures which use the C, Pascal, or StdCall calling convention. If the Pascal or StdCall calling convention is used, the procedure will remove parameters from the stack on return. f the C calling convention is used
, then it is the caller's responsibility to remove the parameters from the stack. 
\par See the description of the {\b ArgVar }macro for additional information. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 SaveReg 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par SaveReg <reg1, reg2, reg3, ...>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Push registers or other things onto the stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This macro pushes each of its arguments onto the stack in the order specified. The arguments are typically the names of registers, but can be anything that can validly follow the 'push' opcode. The special name 'fd' pushes flags via the 'pushfd' instructi
on and the special name 'ad' pushes all registers via the 'pushad' instruction. 
\par Using the {\b SaveReg }macro instead of coding the corresponding instructions manually is required if the procedure is using an ESP-based stack frame. 
\par See the description of the {\b ArgVar} macro for additional information. 
\par {\b Debug_Test_Valid_Handle}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 sCall 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par sCall Procedure
\par sCall Procedure, Param1
\par sCall Procedure, <Param1, Param2, Param3, ..., ParamN>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pushes the specified parameters on the stack and calls the specified procedure. The called procedure is expected to remove the parameters from the stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The return value depends on the specified procedure. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Procedure}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the procedure to call. This parameter can be either a local or public procedure, but must be defined within the virtual device making the call. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Param1, Param2, Param3, ..., ParamN}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Parameters to pass to the procedure. If more than one parameter is given, they must be separated with commas and enclosed in angle brackets (<>). Parameters are optional. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro pushes the parameters using the StdCall calling convention, in order from left to right. It also assumes t
hat the called procedure follows the StdCall-language register conventions, viz., that the EAX, ECX, EDX, and flags registers may be modified by the call, and that the return value is placed in the EAX register (and sometimes also the EDX register). If yo
ur procedure does not follow these rules, do not use the sCall macro. 
\par {\b VMMCall}, {\b VxDCall}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 ShiftState 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vkd.inc
\par 
\par ShiftState Mask, Compare
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the EBX register with the shift state mask and shift state compare value required for a call to the {\b VKD_Define_Hot_Key} service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Mask}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Shift state bits that should be excluded before the comparison is done. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Compare}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value to compare. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Trace_Out 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include debug.inc
\par 
\par Trace_Out String, nocrlf
\par Trace_Out String, level
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Writes the specified string to the debugging device, but continues execution. Compare the {\b Debug_Out} macro, which stops execution if a debugger is attached. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i String}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 String to display, enclosed in double quotation marks. The string can contain register placeholders in the same forms as described for the {\b Out_Debug_String} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i level}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Optional symbol indicating the debugging level for which code should be generated. If the value of the Deblevel symbol is greater than or equal to level, then code is generated. Otherwise, code is not generated. The symbol can be DeblevelNormal or Debleve
lMax. The default is DeblevelNormal. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nocrlf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter specifying that the macro should {\i not} append a carriage return and newline character combination to the string. If this parameter is {\i not}
 given, the macro appends the character combination by default. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The assembler generates code for the macro only if the DEBUG constant is defined before including the DEBUG.INC file. 
\par There are additional macros {\b Trace_OutX}, where X is a conditional jump type, i.e., something that can follow the letter j to form a conditional jump instruction. In such case, the trace-out is performed only if the condition is satisfied. 
\par The following example writes a string to the debugging device: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Trace_Out "Element not found"
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The following example writes a string containing the value of the AX register to the debugging device if the zero flag is set: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 Trace_OutZ "AX value is #AX"
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Out_Debug_String}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMMCall 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMCall Service, Parameters
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pushes the specified parameters on the stack, and calls the specified VMM service. When the service returns, the macro pops the parameters from the stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The return value is as specified for the given service. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Service}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the service to call. This parameter can be any service that is explicitly defined in the service table for the VMM. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Parameters}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Parameters to pass to the service. If more than one parameter is given, they must be separated with commas enclosed in angle brackets (<>). This parameter is optional. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is identical to the VxDCall macro, except that it also validates that the service being called is a VMM service. 
\par {\b VxDCall}, {\b VMMJmp}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMMJmp 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMJmp Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Jumps to the specified VMM service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Service}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the service to jump to. This parameter can be any service that is explicitly defined in the service table for the VMM. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is identical to the {\b VxDJmp} macro, except that it also validates that the service being called is a VMM service. 
\par {\b VMMCall}, {\b VxDJmp}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxDCall 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxDCall Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Pushes the specified parameters on the stack, and then calls the specified virtual device service. When the service returns, the macro pops the parameters from the stack. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The return value is as specified for the given service. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Service}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the service to call. This parameter can be any service that is explicitly defined in the service table for a virtual device. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Parameters}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Parameters to pass to the service. If more than one parameter is given, they must be separated with commas enclosed in angle brackets (<>). This parameter is optional. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
If parameters are passed, it is assumed that the called service conforms to the C-language parameter-passing and register-usage convention: Parameters are passed from right to left, and the service returns a value in the EAX register (possibly also the ED
X register), modifying the ECX and flags register along the way. The C-language calling convention dictates that the caller is responsible for cleaning the stack parameters, {\i but the called procedure is allowed to modify them}
. Do not assume that the called procedure will leave stack parameters unchanged. 
\par The macro creates a dynamic link in the form of an {\b int 20h} instruction followed by a value identifying the service. When the interrupt is executed, the VMM replaces the dynamic link with a {\b call} instruction. 
\par {\b VMMCall}, {\b VxDJmp}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_CODE_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_CODE_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of a code segment. Virtual devices use this macro with in conjunction with the {\b VxD_CODE_SEG} macro to create segments for noninitialization code. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is equal to the {\b VxD_LOCKED_CODE_ENDS} macro. 
\par {\b VxD_CODE_SEG}, {\b VxD_LOCKED_CODE_ENDS}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_CODE_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_CODE_SEG
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the start of a code segment. Virtual devices use this segment for all code that is not explicitly for initialization of the device. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro creates a 32-bit segment named _LTEXT. The segment is assembled for flat model memory so segment registers CS, DS, ES, and SS are assumed to be flat. 
\par This macro is equal to the {\b VxD_LOCKED_CODE_SEG} macro. 
\par {\b VxD_CODE_ENDS}, {\b VxD_DATA_SEG}, {\b VxD_ICODE_SEG}, {\b VxD_LOCKED_CODE_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_DATA_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_DATA_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of a data segment. Virtual devices use this macro with in conjunction with the {\b VxD_DATA_SEG} macro to create segments for noninitialization data. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is equal to the {\b VxD_LOCKED_DATA_ENDS} macro. 
\par {\b VxD_DATA_SEG}, {\b VxD_LOCKED_DATA_ENDS}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_DATA_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_DATA_SEG NoAlign
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the start of a data segment. Virtual devices use this segment for all data that is not explicitly for the initialization of the device. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NoAlign}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies that data be aligned at the next byte. If this optional parameter is {\i not} given, the macro aligns data at the next available doubleword. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro creates a 32-bit segment named _LDATA. 
\par This macro is equal to the {\b VxD_LOCKED_DATA_SEG} macro. 
\par {\b VxD_CODE_SEG}, {\b VxD_DATA_ENDS}, {\b VxD_IDATA_SEG}, {\b VxD_LOCKED_DATA_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_ICODE_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_ICODE_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of an initialization code segment. Virtual devices use this macro in conjunction with the {\b VxD_ICODE_SEG} macro to create initialization code. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b VxD_ICODE_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_ICODE_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_ICODE_SEG
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the star
t of an initialization code segment. Virtual devices typically use this segment for code that initializes the corresponding device. The system discards the segment after the initialization is complete (after the {\b Init_Complete}
 message has been processed by all virtual devices). 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro creates a 32-bit segment named _ITEXT. The segment is assembled for flat model memory so segment registers CS, DS, ES, and SS are assumed to be flat. 
\par {\b VxD_CODE_SEG}, {\b VxD_ICODE_ENDS}, {\b VxD_IDATA_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_IDATA_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_IDATA_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of an initialization data segment. Virtual devices use this macro with in conjunction with the {\b VxD_IDATA_SEG} macro to create initialization data. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b VxD_IDATA_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_IDATA_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_IDATA_SEG
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Defines the start of an initialization data segment. Virtual devices typically use this segment for data used to initialize the corresponding device. The system discards the segment after the initialization is complete (after the {\b Init_Complete}
 message has been processed by all virtual devices). 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro creates a 32-bit segment named _IDATA. 
\par {\b VxD_DATA_SEG}, {\b VxD_ICODE_SEG}, {\b VxD_IDATA_ENDS}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxDint 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxDint Int_Number
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Executes the specified software interrupt. This macro pushes the interrupt number on the stack, and calls the {\b Exec_VxD_Int} service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns values in one or more registers, depending on the function of the specified interrupt. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Int_Number}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the software interrupt to execute. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Exec_VxD_Int}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_IO 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_IO  Port, IOCallback
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Adds an I/O callback procedure and I/O port number to an I/O table. Virtual devices use the macro in conjunction with the {\b Begin_VxD_IO_Table} and {\b End_VxD_IO_Table}
 macros to create a table of I/O callback procedures for the {\b Install_Mult_IO_Handlers} service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Port}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of the I/O port to be trapped. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i IOCallback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the I/O callback procedure. For information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The I/O table can contain any number of {\b VxD_IO} macros. Each macro must specify an unique I/O port number, but the same I/O callback procedure can be assigned to more than one port. In such cas
e, the I/O callback procedure can use the EDX register to determine which port was accessed by the vritual machine. 
\par After a virtual device installs the callback procedures, the system calls a procedure whenever a program in the virtual machine attempts to access the corresponding port. The system calls the procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     ebx, VM             ; current VM handle
\par mov     ecx, IOType         ; type of I/O
\par mov     edx, Port           ; port number
\par mov     ebp, OFFSET32 crs   ; points to a Client_Reg_Struc
\par mov     eax, Data           ; output data (if I/O type is output)
\par call    [IOCallback]
\par 
\par mov     [Data], eax         ; input data (if I/O type is input)
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i VM} parameter specifies the current virtual machine, {\i Port} specifies the I/O port, and {\i crs} points to a {\b Client_Reg_Struc}
 structure containing the register contents for the current virtual machine. 
\par The {\i IOType} parameter specifies the type of input or output operation requested, and determines whether the callback procedure receives data in the EAX register or must return data in the EAX register. The {\i IOType}
 parameter can be a combination of the following values: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Addr_32_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Use 32-bit address offsets for input or output string operations. If this value is not given, the 16-bit offsets are used. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Byte_Input \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Input a single byte; place in AL if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Byte_Output 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Output a single byte from AL if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Dword_Input 
\cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Input a double word; place in EAX if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Dword_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Output a double word from EAX if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Rep_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Repeat the input or output string operation the number of times specified by the {\b Client_CX} field in the {\b Client_Reg_Struc} structure. ({\b Client_ECX}
 if Addr_32_IO is set.) \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reverse_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Decrement string address on each input or output operation. If this value is not given, the string address is incremented on each operation. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
String_IO \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Input or output a string. The high 16-bits specifies segment address of buffer containing the string to output or to receive the string input. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Word_Input \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Input a word; place in AX if String_IO not given. \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Word_Output \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Output a word from AX if String_IO not given. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 In memory, an I/O table consists of a {\b VxD_IOT_Hdr} structure followed by one or more {\b VxD_IO_Struc}
 structures. The first word in the table specified the number of entries. Each entry consists of a word specifying the port number and a double word specifying the 32-bit offset of the callback procedure. 
\par The {\i Data} parameter is used only when I/O type is for output. 
\par {\b Begin_VxD_IO_Table}, {\b End_VxD_IO_Table}, {\b Install_Mult_IO_Handlers}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxDJmp 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxDJmp Service
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Jumps to the specified virtual device service. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Service}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Name of the service to jump to. This parameter can be any service that is explicitly defined in the service table for a virtual device. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The macro creates a dynamic link in the form of an {\b int 20h} instruction followed by a value identifying the service. When the interrupt is execucuted, the VMM replaces the dynamic link with a {\b jmp}
 instruction. 
\par {\b VMMJmp}, {\b VxDCall}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_LOCKED_CODE_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_LOCKED_CODE_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of a code segment. Virtual devices use this macro in conjunction with the {\b VxD_LOCKED_CODE_SEG} macro to create segments for noninitialization code. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is equal to the {\b VxD_CODE_ENDS} macro. 
\par {\b VxD_CODE_ENDS}, {\b VxD_LOCKED_CODE_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_LOCKED_CODE_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_LOCKED_CODE_SEG
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the start of a code segment. Virtual devices use this segment for all code that is not explicitly for initialization of the device. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro creates a 32-bit segment named _LTEXT. The segment is assembled for flat model memory so segment registers CS, DS, ES, and SS are assumed to be equal. 
\par This macro is equal to the {\b VxD_CODE_SEG} macro. 
\par {\b VxD_CODE_SEG}, {\b VxD_LOCKED_CODE_ENDS}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_LOCKED_DATA_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_LOCKED_DATA_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of a data segment. Virtual devices use this macro in conjunction with the {\b VxD_LOCKED_DATA_SEG} macro to create segments for noninitialization data. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro is equal to the {\b VxD_DATA_ENDS} macro. 
\par {\b VxD_DATA_ENDS}, {\b VxD_LOCKED_DATA_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_LOCKED_DATA_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_LOCKED_DATA_SEG NoAlign
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the start of a data segment. Virtual devices use this segment for all data that is not explicitly for initialization of the device. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i NoAlign}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Optional parameter specifying that data be aligned at the next byte. If this optional parameter is {\i not} given, the macro aligns data at the next available doubleword. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro creates a 32-bit segment named _LDATA. 
\par This macro is equal to the {\b VxD_DATA_SEG} macro. 
\par {\b VxD_DATA_SEG}, {\b VxD_LOCKED_DATA_ENDS}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_PAGEABLE_CODE_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_PAGEABLE_CODE_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of a pageable code segment. Virtual devices use this macro in conjunction with the {\b VxD_PAGEABLE_CODE_SEG} macro. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 At any given time, pageable code may be paged out to the system swap file. For this reason, any code that may be executed during hardware interrupt processing must {\i not} be in a {\b VxD_PAGEABLE_CODE_SEG}
 segment. 
\par Code in a {\b VxD_PAGEABLE_CODE_SEG} segment is actually locked if MS-DOS or BIOS functions are used for paging. 
\par {\b VxD_CODE_ENDS}, {\b VxD_LOCKED_CODE_ENDS}, {\b VxD_PAGEABLE_CODE_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_PAGEABLE_CODE_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_PAGEABLE_CODE_SEG
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the start of a pageable code segment. Virtual devices use this macro in conjunction with the {\b VxD_PAGEABLE_CODE_ENDS} macro. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 At any given time, pageable code may be paged out to the system swap file. For this reason, any code that may be executed during hardware interrupt processing must {\i not} be in a {\b VxD_PAGEABLE_CODE_SEG}
 segment. 
\par Code in a {\b VxD_PAGEABLE_CODE_SEG} segment is actually locked if MS-DOS or BIOS functions are used for paging. 
\par {\b VxD_CODE_SEG}, {\b VxD_LOCKED_CODE_SEG}, {\b VxD_PAGEABLE_CODE_ENDS}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_REAL_INIT_ENDS 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_REAL_INIT_ENDS
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the end of a real-mode initialization segment. Virtual devices use this macro with in conjunction with the {\b VxD_REAL_INIT_SEG} macro to create initialization code for real-mode execution. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b VxD_REAL_INIT_SEG}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VxD_REAL_INIT_SEG 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VxD_REAL_INIT_SEG
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Defines the start of a real-mode initialization segment. Virtual devices typically use this segment for code that initializes the corresponding device
 before Windows changes to protected-mode execution. The system discards the segment after the initialization is complete. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab No return value. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This macro creates a 16-bit segment named _RCODE. The segment is assembled for the real-mode tiny model memory so segment registers CS, DS, ES, and SS are assumed to be equal. 
\par {\b VxD_ICODE_SEG}, {\b VxD_REAL_INIT_ENDS}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 28 VMM Messages{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 28
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 VMM Messages 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About VMM Messages 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This chapter is an alphabetic listing of the system control messages sent to virtual devices by the virtual machine manager (VMM). Other components (for example, Vcomm, Vwin32, and the Configuration Manager) also direct system control messages to particul
ar VxDs. Consult documentation for those other components for additional information. 
\par In this chapter, the term "general registers" refers to the registers consisting of EAX, EBX, ECX, EDX, ESI, EDI, and EBP. 
\par The purpose of the {\i xx}2 messages (such as SYS_VM_TERMINATE2 and VM_TERMINATE2) is to address a problem in Windows 3.1 where exit-like messages were sent in {\i increasing}
 initialization order, which created complicated dependencies in a layered device architecture. For example, suppose virtual device {\i B} always requires virtual device {\i A}. This is traditionally solved by giving virtual device {\i A}
 a lower initialization order. This solves the problem at initialization, but since Windows 3.1 sent shutdown messages in increasing initialization order, virtual device {\i A}
 would get the shutdown message first and uninstall itself. Then virtual device {\i B} got into trouble when it received the shutdown message because it requires services from virtual device {\i A}
, which is already gone. There are various ways of working around this problem, none of them entirely satisfactory. 
\par By introducing {\i xx}2 messages which are sent in reverse initialization order, virtual devices {\i A} and {\i B} can perform their shutdown on the {\i xx}2 message, in which case virtual device {\i B} will shut down first, while virtual device {\i A}
 is still ready to service requests, and only after {\i B} has finished processing the shutdown message will it then be given to virtual device {\i A}. 
\par Note that these messages are sent by the virtual machine manager or other system components. Virtual devices should not send these messages on their own, unless otherwise indicated. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_Message_Mode 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, Begin_Message_Mode
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtual dis
play, keyboard, and mouse devices to prepare to display messages and read input from the keyboard. The system sends this message to all virtual devices in order to prepare the system for a full-screen error message (informally known as a 'blue-screen mess
age' because of the color traditionally used for such messages). The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear from this message. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine entering message mode. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This message is usually processed only by the virtual keyboard, mouse, and display devices. 
\par {\b End_Message_Mode}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Begin_PM_App 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edx, Flags
\par mov     edi, OFFSET32 acb
\par mov     eax, Begin_PM_App
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtual device that the system is starting a protected-mode application. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
The virtual device returns with carry clear if the virtual device can support the protected-mode application. Otherwise, it returns carry set to indicate an error, in which case the program is not allowed to enter protected mode. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Bitmask of flags. Only one flag is currently supported: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 BPA_32_Bit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Application has 32-bit segments. If this value is not given, the application has 16-bit segments. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i abc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an application control block, which is a {\b pmcb_s} structure. A virtual device can allocate memory in the application control block with the {\b Allocate_PM_App_CB_Area} service. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Protected-mode applications may nest. Virtual devices are notified for each application, and each application has its own application control block. 
\par {\b End_PM_App}, {\b pmcb_s}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Close_VM_Notify 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edx, Flags
\par mov     eax, Close_VM_Notify
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies a virtual device that the {\b Close_VM} service has been called and the specified virtual machine is terminating. The virtual device may use all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to close. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flag. Can be this value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 CVNF_Crit_Close \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 The virtual machine has not released the critical section. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Close_VM}, {\b Close_VM_Notify2}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Close_VM_Notify2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edx, Flags
\par mov     eax, Close_VM_Notify2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b Close_VM_Notify}, except that {\b Close_VM_Notify2 }is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b Close_VM_Notify2}
 is sent immediately after {\b Close_VM_Notify}. 
\par {\b Close_VM}, {\b Close_VM_Notify}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Create_Thread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, Create_Thread
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies a virtual device that the system is creating a new thread. Virtual devices typically create and initialize any structures needed to support the new thread. The virtual device may use all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
The virtual device returns with carry clear to allow the thread to be created, or with carry set to prevent it from being created. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread being created. The thread being created is not the current thread. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If the virtual device sets the carry flag to prevent creation the thread, it should free any system resource it may have allocated to support the thread. 
\par Interrupt simulation is not permitted in the new thread during this message. 
\par Note that this mesage is not sent when a new virtual machine is created, even though each virtual machine also comes with a thread. Therefore, if you need to do something whenever a new thread is created, even if it is the thread of a virtual machine, you
 need to perform the operation on the {\b VM_Create} message as well. 
\par {\b VMMCreateThread}, {\b Thread_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Create_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, Create_VM
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies a virtual device that the system is creating a new virtual machine. Virtual devices typically initialize data associated with the virtual machine, such as data in the control block for the virtual machine. The virtual device may use all general r
egisters and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The virtual device r
eturns carry clear if the virtual device can support the new virtual machine. Otherwise, it returns with carry set to indicate an error and prevent the system from creating the virtual machine. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the new virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Note that this mesage is delivered out of context; the new virtual machine has not yet started executing. Virtual devices typically ignore this message and act on the {\b VM_Init} message instead. 
\par {\b Destroy_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Crit_Reboot_Notify 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Crit_Reboot_Notify
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies a virtual device that the system is about to restart. Virtual devices typically prepare for restarting by cleaning up data or resetting devices. The system disables interrupts before it sends this message. The virtual device may use all general r
egisters and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual device must not enable interrupts, nor is simulated interrupt activity allowed. See the description of the {\b Device_Reboot_Notify} message for additional information. 
\par {\b Crit_Reboot_Notify2}, {\b Device_Reboot_Notify}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Crit_Reboot_Notify2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Crit_Reboot_Notify2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b Crit_Reboot_Notify}, except that {\b Crit_Reboot_Notify2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b Crit_Reboot_Notify2} is sent 
immediately after {\b Crit_Reboot_Notify}. 
\par {\b Crit_Reboot_Notify}, {\b Device_Reboot_Notify}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Debug_Query 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Debug_Query
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies a virtual device that the user has typed ".VxDNAME" in the debugger. (that is, a period followed by the name of the VxD.) This is a directed system control message. The virtual device typically responds to the message by displaying a menu of debu
gging services and reading command input from the user via {\b In_Debug_Chr}. The virtual device may use all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The handler for this message must not be in pageable memory. A Windows 95 VxD should placed the handler in the {\b Debug_Only} code segment. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Destroy_Thread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, Destroy_Thread
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies a virtual device that the specified non-initial thread is about to be destroyed. This is a virtual devi
ce's last chance to free resources associated with the thread before the thread goes away. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Interrupt simulation is not permitted in the thread during this message. 
\par This message is sent only to virtual devices marked 4.0, and it is sent in reverse initialization order. When a virtual machine is destroyed, no {\b Destroy_Thread} message is sent. Use the {\b Destroy_VM} message instead. 
\par {\b VMMCreateThread}, {\b Create_Thread}, {\b Destroy_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Destroy_VM 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, Destroy_VM
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies the virtual device that the system is about to destroy the virtual machine. Virtual devices typically remove any data associated with the specified virtual machine. The virtual device may use all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine about to be destroyed. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b Destroy_VM} message is sent to all virtual devices in initialization order. 
\par The virtual device must {\i not} call the {\b Simulate_Int} or {\b Exec_Int} service in the specified virtual machine. 
\par Considerable time can elapse between receipt of the {\b VM_Not_Executeable} message and this message. Once all virtual devices return from the {\b Destroy_VM} and {\b Destroy_VM2} messages, the virtual machine is destroyed and the handle becomes invalid. 

\par {\b Create_VM}, {\b Destroy_VM2}, {\b VM_Not_Executeable}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Destroy_VM2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, Destroy_VM2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b Destroy_VM}, except that {\b Destroy_VM2} is sent only to all Windows 95 virtual devices in reverse initialization order. {\b Destroy_VM2} is sent immediately after {\b Destroy_VM}. The {\b 
Destroy_VM2} message is not sent to Windows 3.1 virtual devices. 
\par {\b Create_VM}, {\b Destroy_VM}, {\b VM_Not_Executeable}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Device_Init 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     esi, OFFSET32 CommandTail
\par mov     eax, Device_Init
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Directs the virtual device to initialize itself. The virtual device typically allocates memory for a device-specific section in the control block, allocates other memory areas, hooks interrupts and I/O ports, and specifies instance data. The virtual devic
e may use all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab The virtual device returns carry clear if it initialized successfull
y. If the virtual device returns carry set, the system considers the device as having failed to initialize and removes it from the list of VxDs loaded in the system. Before returning carry set, a virtual device must release all resources it had claimed du
ring previous initialization phases. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CommandTail}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the command tail retrieved from the program segment prefix (PSP) of VMM32.VXD. The first byte in the command tail specifies the length in bytes of the tail. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual device should allocate a device-specific section in the control block of the system virtual machine and then initialize the section. 
\par The virtual device can call the {\b Simulate_Int} and {\b Exec_Int} services in the system virtual machine. 
\par For dynamically loaded VxDs, the EBX register does not contain a VM handle. 
\par {\b Init_Complete}, {\b Sys_Critical_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Device_Reboot_Notify 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Device_Reboot_Notify
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtual device that the system is about to restart. Interrupts remain enabled while virtual devices process this message. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When the system is about to be rebooted abnormally, virtual devices will first receive the {\b Device_Reboot_Notify} message (and possibly also the {\b Device_Reboot_Notify2}
 message), at which time interrupts are enabled and simulated interrupt activity is allowed (although not encouraged). Next, virtual devices receiveS the {\b Crit_Reboot_Notify} message (and possibly also the {\b Crit_Reboot_Notify2}
 message) with interrupts disabled, during which time interrupts must not be enabled by the virtual device, and at which time simulated interrupt activity is not allowed. Finally, virtual devices receive the {\b Reboot_Processor}
 message, which all devices except the virtual keyboard device should ignore. 
\par {\b Crit_Reboot_Notify}, {\b Device_Reboot_Notify2}, {\b Reboot_Processor}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Device_Reboot_Notify2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Device_Reboot_Notify2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b Device_Reboot_Notify}, except that {\b Device_Reboot_Notify2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b Device_Reboot_Notify2}
 is sent immediately after {\b Device_Reboot_Notify}. 
\par {\b Crit_Reboot_Notify}, {\b Device_Reboot_Notify}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Message_Mode 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, End_Message_Mode
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Directs the virtual device to end message-mode processing. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine leaving message mode. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_Message_Mode}, {\b End_Message_Mode2}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_Message_Mode2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, End_Message_Mode2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b End_Message_Mode}, except that {\b End_Message_Mode2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b End_Message_Mode2}
 is sent immediately after {\b End_Message_Mode}. 
\par {\b Begin_Message_Mode}, {\b End_Message_Mode}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_PM_App 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edi, OFFSET32 acb
\par mov     eax, End_PM_App
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtual device that a protected-mode application is ending. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i abc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the application control block for the application that is terminating. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Begin_PM_App}, {\b End_PM_App2}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 End_PM_App2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edi, OFFSET32 acb
\par mov     eax, End_PM_App2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b End_PM_App}, except that {\b End_PM_App2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b End_PM_App2} is sent immediately after {\b 
End_PM_App}. 
\par {\b Begin_PM_App}, {\b End_PM_App}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Init_Complete 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     esi, OFFSET32 CommandTail
\par mov     eax, Init_Complete
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtual device that the system and virtual devices have initialized successfully. Virtual devices that use V86 memory typically search for
 available pages, in the range 0xA0h through 100h, when processing this message. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Clears the carry flag if the virtual device successfully completes its initialization. Otherwise, sets the carry flag to prevent the system from loading the virtual device. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CommandTail}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the command tail retrieved from the program segment prefix (PSP) of VMM32.VXD. The first byte in the command tail specifies the length in bytes of the tail. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system sends this message just before it releases its INIT pages and takes the instance snapshot. 
\par Virtual devices can use the {\b Simulate_Int} and {\b Exec_Int} services to execute code in the system virtual machine. 
\par {\b Device_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 PNP_NEW_DEVNODE 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par include configmg.inc
\par 
\par mov     ebx, hDevnode
\par mov     edx, LoadType
\par mov     eax, PNP_NEW_DEVNODE
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies a dynamically loadable VxD that a new device node has been loaded. Uses the C calling convention. This is a directed system control message. The virtual device may modify the EAX, ECX, EDX, and Flags registers, but it must preserve the EBX, EDI, 
ESI, and EBP registers. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
The virtual device returns a configuration manager return value (CR_) in EAX. The carry flag must be set if a value other than CR_SUCCESS is returned. It doesn
't hurt to return carry set even if you are returning CR_SUCCESS, so it's safest to always return carry set. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hDevnode}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the new device node. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i LoadType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Type of functionality that the VxD should handle. Can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DLVXD_LOAD_DEVLOADER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Device loader \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DLVXD_LOAD_DRIVER \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Device driver \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160
\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 DLVXD_LOAD_ENUMERATOR \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Device enumerator \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s103\qr\sl-140\slmult1 \f4\fs12 
\par 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Power_Event 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par include power.inc
\par 
\par mov     esi, Event
\par mov     edi, OFFSET32 Return
\par mov     eax, Power_Event
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtual device that a power event has just occurred. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
The virtual device must return with carry clear, even to fail the call. See the description of Return for information on how to fail the call. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Event}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Type of power event. Can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PWR_CRITICALRESUME \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Resume critical operations after suspension. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PWR_SUSPENDREQUEST \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Suspend operation. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PWR_SUSPENDRESUME \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Resume operation after suspension. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Return}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the doubleword that receives the return value, which can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PWR_FAIL \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual device failed to process the event. \cell \pard\plain \intbl 
\f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PWR_OK \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Virtual device processed the event successfully. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 To fail the call, a virtual device should store the value PWR_FAIL in the doubleword pointed to by {\i Return}. For the call to succeed, the virtual device must leave the doubleword pointed to by {\i Return}
 unchanged. If a VxD stores PWR_OK through {\i Return}, it might overwrite a PWR_FAIL value that was written there by the previous device. 
\par Only the virtual power device (VPOWERD) is permitted to send this message to devices. The EBX register must be zero on entry. The EDX register is reserved. 
\par Note that this message is sent for compatibility with Windows 3.1 virtual devices. New virtual devices should use the {\b VPOWERD_Register_Power_Handler} service to be notified of changes in power state. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Query_Destroy 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, Query_Destroy
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Directs the virtual device to display a warning message if the destruction of the specified virtual machine will disrupt the operation of the virtual device. The virtual shell device sends this message before attempting to destroy a virtual machine that h
as not terminated normally. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Sets the carry flag if the destruction of the virtual machine will disrupt the virtual device. Otherwise, clears the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to destroy. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual devices that set the carry flag must also display a message box, using the {\b SHELL_Message}
 service to inform the user of the potential problem. The user can then decide whether to continue destroying the virtual machine. 
\par {\b Destroy_VM}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Reboot_Processor 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Reboot_Processor
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Directs the virtual device to restart the computer. The system continues to call the virtual devices until one that can restart the computer (usually the virtual keyboard device) does so. The virtual device may modify all general registers and flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Crit_Reboot_Notify}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Set_Device_Focus 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edx, VID
\par mov     esi, Flags
\par mov     edi, AssocVMHandle
\par mov     eax, Set_Device_Focus
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Sets the focus of the specified virtual device to the specified virtual machine. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Identifier of the virtual device that should change its focus. If this parameter is zero, all virtual devices should change their focus to the indicated virtual machine. Otherwise, all devices whose device IDs are different from {\i VID}
 should ignore the message. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Flags specifying how to set the focus if the {\i VID} parameter is zero. Can be this value: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 1 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Used by the virtual shell device to determine which virtual machine to set focus for. If this value is given, the {\i AssocVMHandle} parameter may specify a virtual machine. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 
\f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i AssocVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of a virtual machine associated with a problem. This parameter is zero if there is no such virtual machine. This parameter is used only if the {\i Flags} parameter is set to 1. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device that is instructed to change its focus should take steps, such as disabling I/O trapping, to allow the specified virtual machine to run as fast as possible. 
\par This is one of the few messages that arbitrary virtual devices are permitted to send. Typically, a virtual device sends this message with EDX = ESI = 0, to indicate that all devices should set the focus to the indicated virtual machine. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Sys_Critical_Exit 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Sys_Critical_Exit
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies the virtual device that the system is exiting either normally or as a result of a crash. Virtual devices should reset their associated hardware to allow for a return to the state before Windows was started. The virtual device may modify all gener
al registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This message is sent with interrupts disabled and the virtual device must not enable interrupts while this message is being processed. 
\par The handler for this message must not be in pageable memory, and must not call the {\b Simulate_Int} or {\b Exec_Int} service. 
\par {\b Sys_Critical_Exit2}, {\b Sys_Critical_Init}, {\b Sys_VM_Terminate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Sys_Critical_Exit2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, Sys_Critical_Exit2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b Sys_Critical_Exit}, except that {\b Sys_Critical_Exit2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b Sys_Critical_Exit2}
 is sent immediately after {\b Sys_Critical_Exit}. 
\par {\b Sys_Critical_Exit}, {\b Sys_Critical_Init}, {\b Sys_VM_Terminate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Sys_Critical_Init 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     esi, OFFSET32 CommandTail
\par mov     eax, Sys_Critical_Init
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtu
al device that Windows is starting. The system sends this message to direct virtual devices to carry out, as quickly as possible, the minimum number of tasks needed to prepare the device for enabled interrupts. This message is sent with interrupts disable
d, and the virtual device must not enable interrupts while handling this message. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag if the virtual device initialized successfully. Othe
rwise, sets the carry flag to prevent the system from loading the virtual device. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i CommandTail}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the command tail retrieved from the program segment prefix (PSP) of VMM32.VXD. The first byte in the command tail specifies the length in bytes of the tail. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 While processing this message, virtual devices typically initialize any critical functions needed to support interrupts, and claim any V86 pages required to support the device. For example, the vi
rtual display device claims the video memory. If a virtual device provides services, it should initialize any data associated with those services. 
\par The virtual device must not use the {\b Simulate_Int} or {\b Exec_Int}
 services. Also it must not access conventional memory unless it is certain that the memory will be there. This means, for example, that scanning memory for the signature of a TSR is not allowed. Upper memory blocks are also off-limits because the V86MMGR
 device has yet to set them up. 
\par {\b Device_Init}, {\b Sys_Critical_Exit}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Sys_VM_Init 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     eax, Sys_VM_Init
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Directs the virtual device to initialize the state of the software in the system virtual machine. For example, the virtual display device issues an Interrupt 10h function to set the initial display mode. The virtual device may modify all general registers
 and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This message is the System VM version of the {\b VM_Init} message. It is sent after the instance snapshop has been completed and initialization code and data have been discarded. 
\par {\b VM_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Sys_VM_Terminate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     eax, Sys_VM_Terminate
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies the virtual device that the system virtual machine is terminating. The system sends this message only after all other virtual machines have terminated, and only when the system is terminating normally. The virtual device may modify all general re
gisters and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual device can use the {\b Simulate_Int} and {\b Exec_Int} services in the system virtual machine. 
\par {\b Sys_VM_Terminate2}, {\b VM_Terminate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Sys_VM_Terminate2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     eax, Sys_VM_Terminate2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b Sys_VM_Terminate}, except that {\b Sys_VM_Terminate2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b Sys_VM_Terminate2}
 is sent immediately after {\b Sys_VM_Terminate}. 
\par {\b Sys_VM_Terminate}, {\b VM_Terminate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 System_Exit 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     eax, System_Exit
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies the virtual device that the system is terminating, either normally or as a result of a crash. Interrupts remain enabled while virtual devices process this message. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i SysVMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the system virtual machine. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual device must {\i not} call the {\b Simulate_Int} or {\b Exec_Int}
 service, but the virtual device may modify the system virtual machine memory to restore the system state to allow Windows to exit without complication. 
\par The system restores the instance snapshot before sending this message. 
\par The virtual device may not access pageable data during the processing of the {\b System_Exit}
 message because the swap file may be in a bad state (which is why the system is crashing in the first place), or the swap file may already have been closed. Virtual devices which wish to access pageable data during {\b System_Exit}
 must lock the data during {\b Sys_VM_Terminate}. During a system crash, the {\b Sys_VM_Terminate} message is not sent, so the virtual device should have some way of determining during {\b System_Exit}
 whether or not it was able to lock its data; if not, it should skip any procedures which use the pageable data. 
\par {\b Sys_Critical_Exit}, {\b Sys_VM_Terminate}, {\b System_Exit2}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 System_Exit2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, SysVMHandle
\par mov     eax, System_Exit2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b System_Exit}, except that {\b System_Exit2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b System_Exit2} is sent immediately after {
\b System_Exit}. 
\par {\b Sys_Critical_Exit}, {\b System_Exit}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Terminate_Thread 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, Terminate_Thread
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies a virtual device that the specified non-initial thread is about to terminate. Virtual devices typically free resources associated with the thread. The virtual device may modi
fy all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread being terminated. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This message is sent only to virtual devices marked 4.0, and it is sent in reverse initialization order. When a virtual machine terminates, no {\b Terminate_Thread} message is sent. Use the {\b VM_Terminate}
 message instead. 
\par {\b VMMTerminateThread}, {\b VM_Terminate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Thread_Init 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, Thread_Init
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies a virtual device that a new thread was created. Virtual devices typically perform initialization procedures that must take place in the context of the new thread. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the new thread. This is also the current thread. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Interrupt simulation is not permitted in the new thread during this message. 
\par {\b VMMCreateThread}, {\b Create_Thread}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Thread_Not_Executeable 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     edi, ThreadHandle
\par mov     eax, Thread_Not_Executeable
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies a virtual device that the specified non-initial thread has stopped executing. Virtual devices typically free resources associated with the thread. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ThreadHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the thread. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Interrupt simulation is not permitted in the thread during this message. 
\par This message is sent only to virtual devices marked 4.0, and it is sent in reverse initialization order. When a virtual machine stops executing, no {\b Thread_Not_Executeable} message is sent. Use the {\b VM_Not_Executeable} message instead. 
\par {\b VM_Not_Executeable}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Critical_Init 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, VM_Critical_Init
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Directs the virtual device to initialize itself for the new virtual machine. This message is sent with interrupts disabled, and the virtual device must not enable interrupts while processing the message. The virtual device may modify all general registers
 and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Clears the carry flag if the virtual device initialized successfully. Otherwise, sets the carry flag to prevent the virtual machine from being created. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to create. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual device must {\i not} use the {\b Simulate_Int} or {\b Exec_Int} services in the specified virtual machine. 
\par {\b Create_VM}, {\b VM_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Init 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, VM_Init
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Directs the virtual device to initialize the state of the software in the new virtual machine. For example, the virtual display device issues Interrupt 10h to set the initial display mode. The system enables interrupts before sending this message. The vir
tual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Clears the carry flag if the virtual device initialized the virtual machine successfully. Otherwise, sets the carry flag to prevent the system from creating the virtual machine. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to create. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual device can use the {\b Simulate_Int} and {\b Exec_Int} services in the specified virtual machine. 
\par {\b Create_VM}, {\b VM_Critical_Init}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Not_Executeable 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edx, Flags
\par mov     eax, VM_Not_Executeable
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies the virtual device that the virtual machine is no longer capable of executing. The system sends this message as the first phase of terminating the virtual machine. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reason the virtual machine is no longer executable. Can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VNE_Crashed \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine has crashed. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VNE_Nuked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine was destroyed while active. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VNE_CreateFail \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Some device failed {\b Create_VM}. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VNE_CrInitFail \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Some device failed {\b VM_Critical_Init}. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VNE_InitFail \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Some device failed {\b VM_Init}. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 When destroying a running virtual machine, the system sends this message first and never sends the {\b VM_Terminate} message. 
\par The virtual device must {\i not} call the {\b Simulate_Int} or {\b Exec_Int} service in the specified virtual machine. 
\par {\b VM_Not_Executeable2}, {\b VM_Terminate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Not_Executeable2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     edx, Flags
\par mov     eax, VM_Not_Executeable2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b VM_Not_Executeable}, except that {\b VM_Not_Executeable2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b VM_Not_Executeable2}
 is sent immediately after {\b VM_Not_Executeable}. 
\par {\b VM_Not_Executeable}, {\b VM_Terminate}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Resume 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, VM_Resume
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies the virtual device that the virtual machine is resuming after having been suspended. The virtual device should lock any resources, and prepare internal data structures for the virtual machine to start running again. The virtual device may modify 
all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Clears the carry flag is clear if the virtual 
device can support resumption of the virtual machine. Otherwise, sets the carry flag to prevent the system from resuming the virtual machine. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to resume. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system never sends the {\b VM_Resume} message without having first sent a {\b VM_Suspend} message. 
\par {\b VM_Suspend}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Suspend 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, VM_Suspend
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Notifies the virtual device that the system is suspending execution of the virtual machine. The virtual device s
hould unlock any resources associated with the virtual machine. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to suspend. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual machine remains suspended until explicitly resumed. The system sends the {\b VM_Suspend} message when the virtual machine's suspend count changes from zero to one, and not every time the {\b 
Suspend_VM} service is called. Similarly, it sends a {\b VM_Resume} message when the virtual machine's suspend count changes from one to zero, and not every time the {\b Resume_VM} service is called. 
\par The {\b CB_VM_Status} field in the control block for the virtual machine specifies whether the virtual machine is suspended. 
\par {\b Resume_VM}, {\b Suspend_VM}, {\b VM_Resume}, {\b VM_Suspend2}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Suspend2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, VM_Suspend2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b VM_Suspend}, except that {\b VM_Suspend2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b VM_Suspend2} is sent immediately after {\b 
VM_Suspend}. 
\par {\b VM_Resume}, {\b VM_Suspend}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Terminate 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, VM_Terminate
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Notifies the virtual device that the system is terminating the specified virtual machine. The system sends this message when a virtual machine terminates normally. The virtual device may modify all general registers and flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab This message cannot be failed. The virtual device must return carry clear. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine being terminated. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The virtual machine can call the {\b Simulate_Int} and {\b Exec_Int} services in the specified virtual machine. 
\par {\b System_Exit}, {\b VM_Not_Executeable}, {\b VM_Terminate2}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VM_Terminate2 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     ebx, VMHandle
\par mov     eax, VM_Terminate2
\par VMMcall System_Control
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Similar to {\b VM_Terminate}, except that {\b VM_Terminate2} is sent only to virtual devices marked version 4.0 and it is sent in reverse device initialization order. {\b VM_Terminate2} is sent immediately after 
{\b VM_Terminate}. 
\par {\b System_Exit}, {\b VM_Not_Executeable}, {\b VM_Terminate}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 29 VMM Structures{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 29
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 VMM Structures 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About VMM Structures 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This chapter contains an alphabetic listing of the structures used with virtual machine manager (VMM) services. There are these structures: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b cb_s}\cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
Client_Reg_Struc}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Exception_Handler_Struc}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b IPF_Data}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b pmcb_s}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Pushad_Struc}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b tcb_s}\cell \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b VMFaultInfo}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 pmcb_s 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par pmcb_s  struc
\par PMCB_Flags   dd  ?  ; control-block flags
\par PMCB_Parent  dd  ?  ; parent of the protected-mode application
\par pmcb_s  ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Application control block. Contains information about a protected-mode application. 
\par {\b Get_Cur_PM_App_CB}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Client_Reg_Struc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Client_Reg_Struc   struc
\par Client_EDI      dd      ?       ; client's EDI
\par Client_ESI      dd      ?       ; client's ESI
\par Client_EBP      dd      ?       ; client's EBP
\par                 dd      ?       ; ESP when pusha instruction is executed
\par Client_EBX      dd      ?       ; client's EBX
\par Client_EDX      dd      ?       ; client's EDX
\par Client_ECX      dd      ?       ; client's ECX
\par Client_EAX      dd      ?       ; client's EAX
\par Client_Error    dd      ?       ; doubleword error code
\par Client_EIP      dd      ?       ; EIP
\par Client_CS       dw      ?       ; CS
\par                 dw      ?       ;   (padding)
\par Client_EFlags   dd      ?       ; EFLAGS
\par Client_ESP      dd      ?       ; ESP
\par Client_SS       dw      ?       ; SS
\par                 dw      ?       ;   (padding)
\par Client_ES       dw      ?       ; ES
\par                 dw      ?       ;   (padding)
\par Client_DS       dw      ?       ; DS
\par                 dw      ?       ;   (padding)
\par Client_FS       dw      ?       ; FS
\par                 dw      ?       ;   (padding)
\par Client_GS       dw      ?       ; GS
\par                 dw      ?       ;   (padding)
\par Client_Alt_EIP  dd      ?
\par Client_Alt_CS   dw      ?
\par                 dw      ?
\par Client_Alt_EFlags  dd   ?
\par Client_Alt_ESP  dd      ?
\par Client_Alt_SS   dw      ?
\par                 dw      ?
\par Client_Alt_ES   dw      ?
\par                 dw      ?
\par Client_Alt_DS   dw      ?
\par                 dw      ?
\par Client_Alt_FS   dw      ?
\par                 dw      ?
\par Client_Alt_GS   dw      ?
\par                 dw      ?
\par Client_Reg_Struc   ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b Client_Reg_Struc} structure contains the CPU register values of the virtual device or other program calling a service. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 cb_s 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par cb_s    struc
\par CB_VM_Status        dd   ?  ; VM status; see below
\par CB_High_Linear      dd   ?  ; base linear address; see below
\par CB_Client_Pointer   dd   ?  ; see below
\par CB_VMID             dd   ?  ; virtual machine ID
\par CB_Signature        dd   ?  ; see below
\par cb_s    ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Virtual machine control block. Contains information about and the status of a virtual machine. The handle of a virtual machine is also the address of its corresponding {\b cb_s}
 structure. All fields in this structure are read-only. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b CB_VM_Status}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the status of the virtual machine. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Awakening \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is waking up after being blocked on a semaphore. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Background \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine runs in the background. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Blocked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is blocked on a semaphore. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Closing \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine has received a {\b Close_VM} message. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Creating \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is being created. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Exclusive \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is in exclusive mode. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_High_Pri_Back \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Virtual machine has high priority background execution. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Idle \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Virtual machine has released its time slice. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Not_Executable \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is partially destroyed. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_PageableV86 \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine has pageable V86 memory (protected-mode application). The default behavior for one or more pages in V86 memory has been modified and the {\b _GetV86PageableArray}
 service returns at least one nonzero bit in the array. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_PM_App \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Virtual machine contains a protected-mode application. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_PM_Exec \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine execution currently in a protected-mode application. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
VMStat_PM_Use32 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine contains a 32-bit protected-mode application. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_Suspended \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is not scheduled. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_TS_Sched \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine is scheduled by the time slicer. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_V86IntsLocked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Virtual machine locks any V86 memory that cannot be paged. Locking regardless of the pager type has been enabled for the virtual machine. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 VMStat_VxD_Exec \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Virtual machine has received a call from a virtual device. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b CB_High_Linear}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Base address of the virtual machine's memory in the ring-0 linear address space. Virtual devices can access memory in a virtual machine by adding the appropriate V86-mode linear address to this value. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b CB_Client_Pointer}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a {\b Client_Reg_Struc} structure containing the register values for the virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b CB_VMID}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Virtual machine identifier. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b CB_Signature}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value VMCB_ID. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Close_VM}, {\b Client_Reg_Struc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Exception_Handler_Struc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Exception_Handler_Struc struc
\par EH_Reserved     dd      ?
\par EH_Start_EIP    dd      ?
\par EH_End_EIP      dd      ?
\par EH_Handler      dd      ?
\par Exception_Handler_Struc ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b Exception_Handler_Struc} structure contains information about a ring-0 exception handler. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b EH_Reserved}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved; must be zero. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b EH_Start_EIP}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the starting address of the exception handler's supported range of addresses. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b EH_End_EIP}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the ending address of the exception handler's supported range of addresses. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b EH_Handler}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Points to the exception handler. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Install_Exception_Handler}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 IPF_Data 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par IPF_Data    struc
\par IPF_LinAddr     dd  ?   ; CR2 address of fault
\par IPF_MapPageNum  dd  ?   ; possible converted page number of fault
\par IPF_PTEEntry    dd  ?   ; contents of PTE that faulted
\par IPF_FaultingVM  dd  ?   ; may not = current VM (IPF_V86PgH set)
\par IPF_Flags       dd  ?   ; flags
\par IPF_Data    ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b IPF_Data} structure contains information about the current invalid page fault. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b IPF_LinAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the CR2 address of the page fault. Do not read from the CR2 register directly; use this value instead. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b IPF_MapPageNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the possible converted page number of the fault. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b IPF_PTEEntry}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the contents of the page-table entry that caused the fault. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b IPF_FaultingVM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the handle identifying the virtual machine that caused the fault. This is not necessarily the current virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b IPF_Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the invalid page-fault flags. It can be a combination of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_InvTyp \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Page has invalid not-present type. \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_PgDir \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Page directory entry not present (not-present page table). \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_PgErr \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Page swap device could not page for some reason. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_PM \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Page fault caused by virtual machine running in protected mode. \cell \pard\plain 
\intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_ReFlt \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Re-entrant page fault. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_V86 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Page fault caused by virtual machine running in V86 mode. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_V86Pg \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Unexpected not-present page in V86. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_V86PgH \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Unexpected not-present page in V86 at high linear address. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 IPF_VMM \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Page fault caused by a virtual device. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Invalid page faults occur in a virtual machine other than the current virtual machine if the high linear address of the virtual machine is accessed. In this case, the {\b IPF_FaultingVM}
 field is set to the handle of the virtual machine that owns the high linear address. 
\par {\b Hook_Invalid_Page_Fault}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Pushad_Struc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par Pushad_Struc struc
\par Pushad_EDI  dd  ?  ; EDI register at time of pushad
\par Pushad_ESI  dd  ?  ; ESI register at time of pushad
\par Pushad_EBP  dd  ?  ; EBP register at time of pushad
\par Pushad_ESP  dd  ?  ; ESP register at time of pushad
\par Pushad_EBX  dd  ?  ; EBX register at time of pushad
\par Pushad_EDX  dd  ?  ; EDX register at time of pushad
\par Pushad_ECX  dd  ?  ; ECX register at time of pushad
\par Pushad_EAX  dd  ?  ; EAX register at time of pushad
\par Pushad_Struc ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Describes the stack frame built by the {\b pushad} instruction. Its typical uses are to reach back into a 'pushad' frame to recover a value that was saved in it, or to shove a value into
 it to be restored by a subsequent 'popad'. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 tcb_s 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par tcb_s    struc
\par TCB_Flags            dd  ?  ; thread status flags; see below
\par TCB_Reserved1        dd  ?  ; reserved for use by VMM
\par TCB_Reserved2        dd  ?  ; reserved for use by VMM
\par TCB_Signature        dd  ?  ; SCHED_OBJ_THREAD_ID
\par TCB_ClientPtr        dd  ?  ; address of client registers
\par TCB_VMHandle         dd  ?  ; VM to which this thread belongs
\par TCB_ThreadId         dw  ?  ; thread ID 
\par TCB_PMLockOrigSS     dw  ?  ; client SS at Begin_Use_Locked_PM_Stack
\par TCB_PMLockOrigESP    dd  ?  ; client ESP at Begin_Use_Locked_PM_Stack
\par TCB_PMLockOrigEIP    dd  ?  ; client EIP at Begin_Use_Locked_PM_Stack
\par TCB_PMLockStackCount dd  ?  ; number of outstanding 
\par                             ;   Begin_Use_Locked_PM_Stack calls
\par TCB_PMLockOrigCS     dw  ?  ; client CS at Begin_Use_Locked_PM_Stack
\par TCB_PMPSPSelector    dw  ?  ; used by Vwin32
\par TCB_ThreadType       dd  ?  ; used by Vwin32
\par TCB_pad1             db  ?  ; padding
\par TCB_pad2             db  ?  ; padding
\par TCB_extErrLocus      db  ?  ; used by Vwin32
\par TCB_extErrAction     db  ?  ; used by Vwin32
\par TCB_extErrClass      db  ?  ; used by Vwin32
\par TCB_extErrPtr        dd  ?  ; used by Vwin32
\par tcb_s ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Thread control block. Contains information about, and the status of, a thread. The handle of a thread is also the address of its corresponding {\b tcb_s} structure. All fields in this structure are read-only. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Value specifying the status of the thread. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_Suspended \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread is not scheduled. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_Not_Executeable \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread has stopped executing. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_Thread_Creation \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread being created. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_Thread_Blocked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread is blocked on a semaphore. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_Ring0_Thread \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread runs completely at ring 0. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_ANSI THFLAG_OEM THFLAG_UNICODE THFLAG_RESERVED \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Used by Vwin32 to indicate file system character set. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_Extended_Handles \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Thread uses extended handles. \cell \pard\plain 
\intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 THFLAG_Open_As_Immovable_File \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Used by Vwin32 to prevent defragmenter from moving an open file. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 
These bits are read-only. Virtual devices should not attempt to modify any of these bits. Some of the descriptions might not be directly meaningful; don't worry. Only Vwin32 really cares about them. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_Reserved1, TCB_Reserved2}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved by VMM for internal bookkeeping. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_Signature}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 The value SCHED_OBJ_THREAD_ID. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_ClientPtr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Pointer to thread client registers. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_VMHandle}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of VM to which this thread belongs. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_ThreadId}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 16-bit value that uniquely identifies the thread during its lifetime. Note that thread IDs are recycled. When a thread is destroyed, its ID becomes available for use. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_PMLockOrigSS}, {\b TCB_PMLockOrigESP}, {\b TCB_PMLockStackCount}, and {\b TCB_PMLockOrigCS}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Used internally by the {\b Begin_Use_Locked_PM_Stack} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b TCB_PMPSPSelector}, {\b TCB_ThreadType, TCB_extErrLocus}, {\b  TCB_extErrAction}, {\b TCB_extErrClass}, and {\b TCB_extErrPtr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Used internally by Vwin32. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Close_VM}, {\b Client_Reg_Struc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 VMFaultInfo 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMFaultInfo    struc
\par VMFI_EIP   dd      ?   ; 
\par VMFI_CS    dw      ?   ; 
\par VMFI_Ints  dw      ?   ; 
\par VMFaultInfo    ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b VMFaultInfo} structure contains data which describes the client state at the time of a fault in the virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b VMFI_EIP} and {\b VMFI_CS}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the value of the instruction pointer and the code segment address at the time the fault occurred. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b VMFI_Ints}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Indicates the interrupt request lines (IRQs) that were in service when the fault occurred. Bit 0 is set if IRQ 0 was in service, bit 1 is set if IRQ 1 was in service, and so on. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b GetSetDetailedVMError}
\par \sect \sectd \binfsxn1\binsxn1\sbkodd\linex0\headery2350\footery360\colsx0\endnhere\titlepg {\headerl \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 {\field{\*\fldinst PAGE}{\fldrslt 2}}{\expnd50\expndtw250   }
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }{\headerr \pard\plain \s113\li-1800\sl-210\slmult1\tqr\tx6960 \b\f30\fs19 \tab Chapter 30 V86 Address Space Mapping and Allocation{\expnd50\expndtw250   }{\field{\*\fldinst PAGE}{\fldrslt 3}}
\par \pard\plain \s59\li-1770\ri30\sb50\sl-80\slmult1\brdrt\brdrs\brdrw15\brdrcf2 \f4\fs12 
\par }\pard\plain \s53\li-1800\sa280\sl-240\slmult1\keepn \caps\f4\expnd24\expndtw120 Chapter 30
\par \pard\plain \s43\sl-540\slmult1\keepn\pvpara\phmrg\posnegx-1801\posy0\absh-2460\absw6720\nowrap \b\f30\fs48 V86 Address Space Mapping and Allocation 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 About V86 Address Space Mapping and Allocation 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 There are the following V86 address space mapping and allocation services: 
\par \trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Add_Global_V86_Data_Area}\cell \cell \pard\plain \intbl \f4\fs21 \row \trowd \cellx2880\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _AddInstanceItem}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Allocate_Device_CB_Area}\cell \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Allocate_Global_V86_Data_Area}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
_Allocate_Temp_V86_Data_Area}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Assign_Device_V86_Pages}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Deallocate_Device_CB_Area}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _DeAssign_Device_V86_Pages}\cell \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _Free_Temp_V86_Data_Area}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
_Get_Device_V86_Pages_Array}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _GetFirstV86Page}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _GetInstanceInfo}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _GetLastV86Page}\cell \cell \pard\plain \intbl \f4\fs21 
\row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _GetV86PageableArray}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _LinMapIntoV86}\cell \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _MapIntoV86}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _ModifyPageBits}
\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _PhysIntoV86}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b 
_SetResetV86Pageable}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b _TestGlobalV86Mem}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Hook_V86_Page}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b InstDataStruc}\cell \cell \pard\plain \intbl \f4\fs21 \row 
\trowd \cellx2880\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 {\b Unhook_V86_Page}\cell \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 The HMA and Address Wrapping 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 In real mode or V86 mode it is possible to form a linear address as large as 10FFEFh (FFFF0h + FFFFh), or roughl
y 1MB + 64K. On the 8086, which has only 20 address lines, linear addresses greater than 1MB wrap to first 64K of physical memory. Incredibly, some software designed for the 8086 relies on this behavior. 
\par The largest address that can be formed in V86 mode is FFFF:FFFF, which is equivalent to the linear address 10FFEFh (FFFF0h + FFFFh). 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Instanced Pages 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 An {\i instanced} page is a page that contains both global and local data. At any given time, a instanced page is marked present for one VM, and not present for all other VMs. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Structure of the DOS Arena 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
The DOS arena is the range of linear addresses from MINDOSLADDR through MAXDOSLADDR, and is used for virtual machines (VMs). The DOS arena is divided into several areas, parallelling the organization of memory under MS-DOS in real mode. The following illu
stration shows the structure of the DOS arena: The V86 global area is used for MS-DOS system code, device drivers, and TSRs. Pages in the global area are mapped such that linear and physical addresses are identical. Data in the global area that is {\i 
not }shared by all VMs must be instanced using the {\b _AddInstanceItem} service. 
\par The V86 private area is used for MS-DOS application code and data. Pages in this address range are mapped to different physical storage for each VM. The first page of the V86 private area depends on the size of the V86 global area. To get the page numbers
 of the first and last pages in the V86 private area, use the {\b _GetFirstV86Page} and {\b _GetLastV86Page} services. 
\par The V86-Mode Memory Manager (V86MMGR) manages the pages in the V86 private area. During device initialization, the V86MMGR assigns the pages to itself by using the {\b _Assign_Device_V86_Pages} service. 
\par Video memory is managed by the video display device (VDD). The VDD assigns the pages in this range to itself during device initialization. It then installs its own page fault handler for the pages by using the {\b Hook_V86_Page} service. 
\par The VM control block heap is used by virtual devices to allocate memory that is local to each VM. To allocate memory from the VM control block heap, use the {\b _Allocate_Device_CB_Area} service. 
\par See also {\b _AddInstanceItem}, {\b _Allocate_Device_CB_Area}, {\b _Assign_Device_V86_Pages}, {\b Hook_V86_Page}, {\b _GetFirstV86Page}, {\b _GetLastV86Page}
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Memory Mapping and Hooked Pages 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b _Assign_Device_V86_Pages} service assigns to a virtual device one or more pages of the V86 address space. 
\par The {\b _DeAssign_Device_V86_Pages} service frees a region in the V86 address space which was previously assigned using the {\b _Assign_Device_V86_Pages} service. 
\par The {\b _Get_Device_V86_Pages_Array} service gets a copy of the assignment array used by the {\b _Assign_Device_V86_Pages} and {\b _DeAssign_Device_V86_Pages} services. 
\par The {\b _LinMapIntoV86} service maps one or more pages into the V86 address space of the specified virtual machine. 
\par The {\b _MapIntoV86} service maps one or more pages of a memory block into the V86 address space of the specified virtual machine. 
\par The {\b _PhysIntoV86} service maps the specified physical pages in the V86 address space. 
\par The {\b _GetInstanceInfo} service retrieves a value indicating whether the given VM address range is fully instanced, partially instanced, or not instanced. 
\par The {\b _TestGlobalV86Mem} service tests whether a V86 address range is global, local, or instanced. 
\par The {\b _GetFirstV86Page} service gets the page number of the first page in the current virtual machine. 
\par The {\b _GetLastV86Page} service gets the page number of the last page of V86 memory in the current virtual machine. 
\par The {\b Hook_V86_Page} service installs a callback procedure to handle faults for the specified page. 
\par The {\b _ModifyPageBits} service modifies the page attribute bits for pages in the V86 address space of a virtual machine. 
\par \pard\plain \s2\li-1800\sb140\sa60\sl-380\slmult1\keepn \b\f30\fs34 Memory Allocation for Virtual Machines 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b _Allocate_Device_CB_Area} service allocates an area in the control block of the current virtual machine for exclusive use by the virtual device. 
\par The {\b _Add_Global_V86_Data_Area service} adds a region to the list of regions available for allocation as global V86 data areas. 
\par The {\b _Allocate_Global_V86_Data_Area} service allocates a block of memory from the global V86 data area. 
\par The {\b _Allocate_Temp_V86_Data_Area} service allocates a block of memory from the global V86 data area. 
\par The {\b _Free_Temp_V86_Data_Area} service frees a block allocated using the {\b _Allocate_Temp_V86_Data_Area} service. 
\par \pard\plain \s1\li-1800\sb200\sa80\sl-440\slmult1\keepn \b\f30\fs40 Reference 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Add_Global_V86_Data_Area 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Add_Global_V86_Data_Area, <LinAddr, nBytes, flags>
\par 
\par or      eax, eax        ; nonzero if added, zero if error
\par jz      not_added
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Adds a region to the list of regions available for allocation as global V86 data areas. This service is only available during initialization, and only for Windows version 3.1 or later. Uses EAX, ECX, EDX, Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i LinAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear address of the first byte of the region. This address must be less than 100000h, and must not lie between the first and last V86 page for the specified virtual machine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nBytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size of the region, in bytes. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
This service supports virtual devices, such as the virtual MS-DOS manager and the V86MMGR device, which can manage high memory above the last V86 page. The service lets these devices add available regions which would otherwise go unused. Typically, such r
egions are nonpage-aligned fragments which cannot be used for normal operations requiring page-aligned memory. 
\par Calls to this service should be made during processing of the {\b Sys_Critical_Init} message. Virtual devices should not wait for the {\b Device_Init} or {\b Init_Complete}
 messages because most of the allocation of global V86 data areas is done while processing the {\b Device_Init} message. 
\par If this service adds a region that is above the last V86 page, virtual devices should not attempt to allocate the region until the {\b Sys_Critical_Init} message has been processed. 
\par {\b _Allocate_Global_V86_Data_Area}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _AddInstanceItem 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _AddInstanceItem, <<OFFSET32 InstStruc>, flags>
\par 
\par or      eax, eax        ; nonzero if added, zero if error
\par jz      not_added
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Identifies a region of instance data in the V86 address space. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i InstStruc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of an {\b InstDataStruc} structure containing information about the block of memory to instance. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 To prevent errors, a virtual device must {\i not} change the location and content of any {\b InstDataStruc}
 structures until after the system has completed its initialization. To achieve this, a virtual can either statically allocate the structures in its INIT data segment or dynamically allocate the structures on the system heap using the {\b _HeapAllocate}
 service. If the structures are in the INIT data segment, the system automatically frees the structure when it reclaims the INIT segment space. If the structures are in the system heap, the virtual device must free the structures using the {\b _HeapFree}
 service while processing the {\b Sys_VM_Init} message. 
\par If a virtual device the structures on the system heap, it must {\i not} attempt to reallocate the structure before system initialization has completed because this invalidates the structure address. 
\par Only one, contiguous region of instance data can be identified with each structure. The virtual device can cut down the call overhead and data space requirements by coalescing adjacent blocks of instance data and identifying the coalesced blocks as a sing
le instance item. 
\par {\b InstDataStruc}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Allocate_Device_CB_Area 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Allocate_Device_CB_Area, <nBytes, flags>
\par 
\par or      eax, eax        ; zero if error
\par jz      not_allocated
\par 
\par mov     [Offset], eax   ; offset from start of control block to new area
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Allocates an area in the control block of all virtual machines for exclusive use by the virtual device. Virtual devices typically uses this service to allocate space to store data that is specific to a given virtual machine. This service is only avai
lable during initialization. Unlike Windows 3.1 which restricted this service to initialization, Windows 95 supports this service after initialization. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns, in the EAX register, the offset of the new area relative to the start of the control block, if successful. The EAX register is zero if an error occurs, such as insufficient memory to satisfy the request. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nBytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of bytes to allocate. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If this service returns an error, the virtual device should consider this a fatal error and respond accordingly. 
\par Although this service aligns the new area on a doubleword boundary and rounds the {\i nBytes} parameter up to the next multiple of 4, the virtual device must not rely on this behavior. 
\par The service fills the newly allocated area with zeros. When the system creates a new virtual machine, it fills all bytes of the control block with zeros. 
\par {\b _Deallocate_Device_CB_Area}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Allocate_Global_V86_Data_Area 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Allocate_Global_V86_Data_Area, <nBytes, flags>
\par 
\par or      eax, eax        ; zero if error
\par jz      error
\par mov     [Address], eax  ; ring-0 linear address of block
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Allocates a block of memory from the global V86 data area. The block is for exclusive use by the virtual device. Virtual devices use this service to allocate memory for device-specific objects which must be accessible to both the virtual device and softwa
re running in the virtual machine. This service is only available during initialization. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the ring-0 linear address of the block in the EAX register if successful, zero otherwise. 
\par \pard\plain \s50\li280\sa80\sl-240\slmult1\tqr\tx160\tx280 \f4\fs21 
If GVDAInquire is given, EAX contains the size in bytes of the largest block that satisfies the request, but that does not move the first V86 page. EAX contains zero if all such requests move the first V86 page. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nBytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of bytes to allocate. This parameter should be a multiple of 4096. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be zero or more of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDADWordAlign \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Aligns block on a doubleword boundary. If no alignment value is given, the service aligns the block on a byte boundary. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAHighSysCritOK \cell 
\pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Informs the service that the virtual device can manage a block that resides in high MS-DOS memory. The service allocates from high MS-DOS memory only if such memory is available (for example, implemented as XMS UMBs) and the virtual device specifies this 
value. A virtual device can use this value only while processing the {\b Sys_Critical_Init} message. 
\par n first allocated, a block in high MS-DOS memory may not be immediately usable since memory supporting the area may not yet have been mapped. The system maps the memory for the area at some time during the {\b Sys_Critical_Init}
 message, but there is no guarantee as to when. 
\par  GVDAHighSysCritOK value is only available for Windows version 3.1 or later. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAInquire \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Returns the size in bytes of the largest block that satisfies the requested alignment but does not require the first V86 page to be moved. The {\i nBytes}
 parameter is not used if this value is specified. 
\par irtual device typically uses this value, while processing the {\b Init_Complete} message, to allocate portions of the global V86 data area that might otherwise go unused. The GVDAInquire value is only available for Windows version 3.1 or later. \cell 
\pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAInstance \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Creates an instance data block allowing the virtual device to maintain different values in the block for each virtual machine. If this value is not given, the service creates a global block in which the same data is available to all virtual machines. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAOptInstance \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Allows the virtual machine manager to determine whether to create an instance data block or a global data block. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAPageAlign \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Aligns block on a page (4 kilobyte) boundary. If no alignment value is given, the service aligns the block on a byte boundary. 
\par  GVDAWordAlign, GVDADWordAlign, GVDAParaAlign, and GVDAPageAlign values are mutually exclusive. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAParaAlign \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Aligns block on a paragraph (16-byte) boundary. If no alignment value is given, the service aligns the block on a byte boundary. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAReclaim \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Unmaps any physical pages in the block while mapping the system nul page into the block. The service places unmapped physical pages in the free list. This value only applies if the GVDAPageAlign value is also given. If this value is not given, the service
 ignores any physical pages it unmaps. It is up to the virtual device to reclaim these pages. 
\par  GVDAReclaim and GVDAInstance values are mutually exclusive. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAWordAlign \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 Aligns block on a word boundary. If no alignment value is given, the service aligns the block on a byte boundary. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain 
\s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 GVDAZeroInit \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Fills the block with zeros. If this value is not given, the initial content of the block is undefined. 
\cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If this service returns an error, the virtual device should consider this a fatal error and respond accordingly. 
\par The size returned when the GVDAInquire value is given may be less than a reasonable minimum. For instance, if GVDAPageAlign is specified, the return size may be less than 4096. It is up to the virtual device to check for this. 
\par For blocks allocated with GVDAInstance, this service calls automatically calls the {\b _AddInstanceItem} service. 
\par The {\b _Allocate_Global_V86_Data_Area} service is not available and must not be called if the virtual device has allocated a temporary block using the {\b _Allocate_Temp_V86_Data_Area}
 service. The virtual device must free the block before it can call the {\b _Allocate_Global_V86_Data_Area} service. 
\par If GVDAReclaim is not given, the virtual device should reclaim the physical addresses of any unmapped physical pages, and map the pages to other addresses. A virtual device reclaims the physical addresses by using the {\b _CopyPageTable}
 service to retrieve the page-table entries for the system virtual machine. The virtual device can then use the {\b _PhysIntoV86} service to map the physical pages into the V86 address space. 
\par {\b _CopyPageTable}, {\b _PhysIntoV86}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Allocate_Temp_V86_Data_Area 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Allocate_Temp_V86_Data_Area, <nBytes, flags>
\par 
\par or      eax, eax        ; zero if error
\par jz      error
\par mov     [Address], eax  ; address of temporary block
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
Allocates a block of memory from the global V86 data area. The block is for exclusive use by the virtual device during system initialization only. A virtual device typically allocates a temporary block to serve as a buffer for calls to MS-DOS or BIOS
 functions. A virtual device makes such calls using the {\b Simulate_Int} service while inside a nested execution block. This service is only available during initialization. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the ring-0 linear address of the block in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nBytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of bytes to allocate. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service always aligns the temporary block on a paragraph boundary and fills the block with zeros. 
\par Virtual devices must free the temporary block as soon as possible. The system provides only one temporary data area, therefore only one temporary block can be allocated at a time. Attempts to allocate a temporary block when it is already allocated will re
sult in an error. 
\par {\b _Free_Temp_V86_Data_Area}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Assign_Device_V86_Pages 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Assign_Device_V86_Pages, <VMLinrPage, nPages, VM, flags>
\par 
\par or      eax, eax            ; nonzero if assigned, zero if error
\par jz      not_assigned
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Assigns to a virtual device one or more pages of the V86 address space. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinrPage}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page of V86 address space to assign. The page number must be in the range 0 through 10Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to assign. The service returns an error if the page range does not fall entirely within the V86 address space, or if any page in the range is already assigned. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Handle of a virtual machine, or zero. If this parameter is a valid handle, the page assignments are made in the context of the specified virtual machine. If this parameter is zero, the page assignments are made globally. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device can make global assignments at any time, including during device initialization. For global assignments, the {\i VM}
 parameter must be zero. The virtual device must not attempt to assign a page that is already assigned. A virtual device can make local assignments only after device initialization is complete. 
\par {\b _DeAssign_Device_V86_Pages}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Deallocate_Device_CB_Area 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Deallocate_Device_CB_Area, <Control_Block_Offset, Flags>
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Deallocates part of each virtual machine's control-block, which was previously allocated by {\b _Allocate_Device_CB_Area}. Uses EAX, ECX, EDX and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns zero on error, nonzero on success. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Control_Block_Offset}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Control block offset previously allocated by the {\b _Allocate_Device_CB_Area} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i Control_Block_Offset} must be a valid offset that was returned by a previously successful call to {\b _Allocate_Device_CB_Area}. Do not pass an invalid value to deallocate. 
\par {\b _Allocate_Device_CB_Area}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _DeAssign_Device_V86_Pages 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _DeAssign_Device_V86_Pages, <VMLinrPage, nPages, VM, flags>
\par 
\par or      eax, eax        ; nonzero if unassigned, zero if error
\par jz      not_unassigned
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees a region in the V86 address space which was previously assigned using the {\b _Assign_Device_V86_Pages} service. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinrPage}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page to free. The page number must be in the range 0 through 10Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to free. The service returns an error if the page range does not fall entirely within the V86 address space, or if any page in the range is not assigned. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Handle of a virtual machine, or zero. If this parameter is a valid handle, the assigned pages are freed in the context of the specified virtual machine. If this parameter is zero, the page assignments are freed globally. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service only works after device initialization is complete. 
\par A virtual device must not attempt to free pages that have not been assigned, or attempt to globally free pages that were only assigned in the context of a specific virtual machine. 
\par {\b _Assign_Device_V86_Pages}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Free_Temp_V86_Data_Area 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Free_Temp_V86_Data_Area
\par 
\par or      eax, eax        ; nonzero if freed, zero if error
\par jz      not_freed
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Frees a block allocated using the {\b _Allocate_Temp_V86_Data_Area} service. This service is only available during initialization. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b _Allocate_Global_V86_Data_Area} service is not available while a temporary block is allocated. The virtual device must free the block before the {\b _Allocate_Global_V86_Data_Area} service can be called. 

\par This service invalidates the address of the temporary block. Attempting to use the address can cause a system crash. 
\par {\b _Allocate_Temp_V86_Data_Area}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _Get_Device_V86_Pages_Array 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _Get_Device_V86_Pages_Array, <VM, <OFFSET32 ArrayBuf>, flags>
\par 
\par or      eax, eax        ; nonzero if retrieved, zero if error
\par jz      not_retrieved
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets a copy of the assignment array used by the {\b _Assign_Device_V86_Pages} and {\b _DeAssign_Device_V86_Pages}
 services. Virtual devices use the assignment array to determine which regions of the V86 address space are currently assigned, and which are available. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which to retrieve the assignment array. If this parameter is zero, the service retrieves the global assignment array. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ArrayBuf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of a 36-byte buffer that receives the assignment array. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The assignment array consists of 110h bits, each of which represents a single page in the V86 address space. A page is assigned if the corresponding bit is 1. 
\par The global assignment array does not indicate which pages are available. A page is available for global assignment only if it is neither globally nor locally assigned. To determine whether a page is available for global assignment, a virtual device must c
heck the global assignment array, and then check the assignment arrays for each virtual machine. 
\par {\b _Assign_Device_V86_Pages}, {\b _DeAssign_Device_V86_Pages}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetFirstV86Page 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetFirstV86Page
\par 
\par mov     [FirstPage], eax        ; first page of V86 memory
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Gets the page number of the first page in the current virtual machine. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the page number in the EAX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The first page in a virtual machine moves during virtual device initialization, so the page number returned by this service during initialization will not be valid at any later time. 
\par {\b _GetLastV86Page}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetLastV86Page 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetLastV86Page
\par 
\par mov     [LastPage], eax     ; last page in V86 memory
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns the page number of the last page of V86 memory for the current virtual machine. This service is only available for Windows version 3.1 or later. Uses EAX. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns the page number in the EAX register. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The last page in V86 memory moves during initialization. Virtual devices that retrieve the last page when processing initialization messages must retrieve the page number again to use it later. 
\par {\b _GetFirstV86Page}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetInstanceInfo 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par 
\par VMMCall _GetInstanceInfo, <pRegion, cbRegion>
\par mov     [InstanceInfo], eax
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Retrieves a value indicating whether the given VM address range is fully instanced, partially instanced, or not instanced. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns, in EAX, a value identifying the region's state if the function succeeds. In can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 INSTINFO_NONE (0) \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Region is not instanced. \cell \pard\plain \intbl \f4\fs21 \row 
\pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 INSTINFO_SOME (1) \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Region is partially instanced. \cell \pard\plain \intbl \f4\fs21 \row \trowd 
\trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 INSTINFO_ALL (2) \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Region is fully instanced. \cell \pard\plain \intbl 
\f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pRegion}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear v86 address of region. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i cbRegion}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size of region in bytes. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _GetV86PageableArray 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _GetV86PageableArray, <VM, <OFFSET32 ArrayBuf>, flags>
\par 
\par or      eax, eax            ; nonzero if array retrieved, zero if error
\par jz      error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Returns a copy of the bit array of pages whose behavior has been modified using the {\b _SetResetV86Pageable}
 service. Virtual devices use this service to determine whether regions in the V86 address space in a virtual machine have had the normal lock and unlock behavior modified. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine to examine. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i ArrayBuf}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the buffer to receive the array. The array contains 100h bits (32 bytes), one bit for each page in the range 0 through 100h. If
 a bit is set, the lock and unlock behavior for the corresponding page is disabled. Otherwise, the behavior is enabled. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be 0. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 All bits in the returned bit array are zero if the VMStat_PageableV86 value is not given in the {\b CB_VM_Status} field of the control block for the virtual machine. 
\par {\b _SetResetV86Pageable}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _LinMapIntoV86 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _LinMapIntoV86, <HLinPgNum, VM, VMLinPgNum, nPages, flags>
\par or      eax, eax            ; zero if error
\par jz      not_mapped
\par mov     [V86Address], eax   ; V86 address for mapped pages
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Maps one or more pages into the V86 address space of the specified virtual machine. This service is similar to the {\b _MapIntoV86} service. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns a nonzero value in the EAX register if successful, zero otherwise. If EAX is nonzero, the EDX register contains the V86-mode address to which the specified pages are mapped. Otherwise, the value of EDX is undefined. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i HLinPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page to map. A linear page number is a ring-0 linear address shifted right by 12 bits. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which memory is mapped. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of an address in the V86 address space. The service maps the specified pages to this address if the {\i HLinPgNum}
 parameter does not already specify a valid V86 address. This parameter must be a page number in the range 10h through 10Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to map. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Operation flags. Can be zero or the MAPV86_IGNOREWRAP value. This value enables the caller to treat the high memory area (HMA) simply as an extension of the V86 address space, whether or not wrap is enabled. 
\par If MAPV86_IGNOREWRAP is specified and wrap is enabled, the service updates only the HMA alias mapping for pages in the HMA, not the currently-visible mapping. The HMA corresponds to page numbers 100h through 10Fh. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 A virtual device typically uses this service to map buffers having protected-mode addres
ses into the V86 address space. This gives software running in the virtual machine a means of passing data to and receiving data from the virtual device. 
\par If {\i HLinPgNum} is a V86 page number (that is less than or equal to 100h), this service returns {\i HLinPgNum} immediately and does nothing else. Otherwise, the service returns {\i VMLinPgNum}. 
\par If the specified linear pages belong to a free physical region, this service calls the {\b _PhysIntoV86} service to carry out the request. 
\par If the specified linear pages belong to the high addressing region for a virtual machine, this service maps the memory from that virtual machine into the virtual machine specified by the {\i VM}
 parameter. The V86MMGR device uses this capability to map a region of V86 address space which is currently local to one VM into a global region that is addressable by all virtual machines. Virtual devices must {\i not}
 use this capability directly; they should always use the V86MMGR services to map local memory into global memory. 
\par Although a virtual device can map the same page into multiple addresses in the V86 address space, this is not recommended. 
\par For each mapped page, this service sets the P_USER, P_PRES, and P_WRITE bits, but clears the P_DIRTY and P_ACC bits. The service sets the page type to be identical to the page type for the pages at the specified protected-mode linear address. 
\par If the virtual page swap device uses MS-DOS or BIOS functions to write to the device, this service automatically locks all mapped pages and unlocks any previously mapped pages. 
\par If a virtual device no longer needs the mapped region, it should map the system nul page into the V86 address space using the {\b _MapIntoV86} service. A virtual device can retrieve the handle for the system nul page using the {\b _GetNulPageHandle}
 service. 
\par This service accepts V86 page numbers between 10h and the page number returned by the {\b _GetFirstV86Page} service. This supports virtual devices that use the {\b _Allocate_Global_V86_Data_Area} service. Mapping a region which spa
ns across the first V86 page is not allowed. Mapping pages in this region to other addresses can easily crash the system, and should be avoided. 
\par {\b _Allocate_Global_V86_Data_Area}, {\b _GetFirstV86Page}, {\b _GetNulPageHandle}, {\b _MapIntoV86}, {\b _PageLock}, {\b _PhysIntoV86}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _MapIntoV86 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _MapIntoV86, <hMem, VM, VMLinPgNum, nPages, PageOff, flags>
\par 
\par or      eax, eax            ; nonzero if pages mapped, zero if error
\par jz      not_mapped
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Maps one or more pages of a memory block into the V86 address space of the specified virtual machine. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i hMem}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle (base linear address) of the memory block to map. This address must have been returned by the {\b PageAllocate, PageReAllocate,} or {\b _PageReserve} service. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which to map the memory. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number in the virtual machine's address space. The service maps the first page to the c
orresponding linear address in the V86 address space. This parameter must be in the range 10h through 10Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to map. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PageOff}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Offset in pages from the beginning of the memory block to the first page to map. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PageDEBUGNulFault \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables page faults for system nul pages. If the
 memory block contains system nul pages, a page fault occurs whenever a nul page is accessed. This value only applies when running the debugging version of the Windows virtual machine manager. If this value is not given or the debugging version is not run
ning, no page faults occur. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 MAPV86_IGNOREWRAP \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
If the specified pages are in the high memory area (HMA) and wrap is on, only update the HMA alias mapping, not the currently visible mapping. The HMA corresponds to pages in the range 100h to 10Fh. This allo
ws the caller to treat the HMA simply as an extension of the V86 address space, regardless of whether wrap is enabled. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 
A virtual device typically uses this service to map buffers having protected-mode addresses into the V86 address space. This gives software running in the virtual machine a means of passing data to and receiving data from the virtual device. 
\par The service returns an error if the sum of the {\i PageOff} and {\i nPages} parameters is greater than the size of the memory block. 
\par Although a virtual device can map the same page into multiple addresses in the V86 address space, this is not recommended. 
\par For each mapped page, this service sets the P_USER, P_PRES, and P_WRITE bits and clears the P_DIRTY and P_ACC bits. 
\par If the virtual page swap device uses MS-DOS or BIOS functions to write to the hardware, {\b _MapIntoV86}
 automatically locks the mapped pages and unlocks any previously mapped pages. If the virtual page swap device writes directly to the hardware, this service neither locks nor unlocks the pages. 
\par If a virtual device no longer needs the mapped region, it should map the system nul page into the V86 address space using the {\b _MapIntoV86} service. A virtual device can retrieve the handle of the system nul page using the {\b _GetNulPageHandle}
 service. 
\par This service accepts V86 page numbers between 10h and the page number returned by the {\b _GetFirstV86Page} service. This supports virtual devices that use the {\b _Allocate_Global_V86_Data_Area} service. Mapping a region which spans across 
the first V86 page is not allowed. Mapping pages in this region to other addresses can easily crash the system and should be avoided. 
\par {\b _Allocate_Global_V86_Data_Area}, {\b _GetFirstV86Page}, {\b _GetNulPageHandle}, {\b _LinMapIntoV86}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _ModifyPageBits 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _ModifyPageBits, <VM, VMLinPgNum, nPages, bitAND, bitOR, pType, flags>
\par 
\par or      eax, eax            ; nonzero if modified, zero if error
\par jz      not_modified
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Modifies the page attribute bits for pages in the V86 address space of a virtual machine. V
irtual devices use this service to modify page permissions, or to mark a hooked page as not present. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine owning the pages to modify. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page to modify. All pages must be in the 1 megabyte V86 address space. Page numbers below the first page of the specified virtual machine or above 10Fh cause an error. 

\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to modify. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i bitAND}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
AND mask for the page attribute bits. All bits except P_PRES, P_WRITE, and P_USER must be one. The P_PRES, P_WRITE, and P_USER bits can be zero or one to clear or preserve the corresponding page attributes. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i bitOR}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 OR mask for the page attribute bits. All bits except P_PRES and P_WRITE must be zero. The P_PRES and P_WRITE bits can be 0 or 1 to preserve or set the corresponding page attributes. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i pType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Page type. This parameter can be be either PG_IGNORE or PG_HOOKED, but must be PG_HOOKED if the P_PRES bit of the {\i bitAND} parameter is zero. This parameter has no real effect. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service always clears the P_DIRTY and P_ACC bits regardless of the AND and OR mask values. 
\par This service can be used to mark a range of pages as not present (clear the P_PRES bit). In this case, fault handlers {\i must} have been previously installed for the specified pages using the {\b Hook_V86_Page} service, and the {\i pType}
 parameter must be PG_HOOKED. 
\par This service cannot be used to set the P_PRES bit. Use the {\b _MapIntoV86} or {\b _PhysIntoV86} service to make pages present. 
\par If using the P_WRITE bit to simulate ROM in a virtual machine, a virtual device should map the pages using the {\b _PhysIntoV86} service and immediately call the {\b _ModifyPageBits} service to clear the P_WRITE bit. 
\par {\b Hook_V86_Page}, {\b _MapIntoV86}, {\b _PhysIntoV86}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _PhysIntoV86 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _PhysIntoV86, <PhysPage, VM, VMLinPgNum, nPages, flags>
\par 
\par or      eax, eax                ; nonzero if mapped, zero if an error
\par jz      not_mapped
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Maps the specified physical pages in the V86 address space. This service is similar to the {\b _MapIntoV86}
 service, but takes physical page numbers instead of memory handles. Virtual devices use this service to associate physical device memory (such as the video memory) with a particular virtual machine. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PhysPage}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Physical page number of the start of the region to map. A physical page number is a physical address shifted right by 12 bits. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which the memory is mapped. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 
Linear page number in the virtual machine's address space. The service maps the first physical page to the corresponding linear address in the V86 address space. This parameter must be in the range 10h through 10Fh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to map. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation 
flags. Can be zero or the MAPV86_IGNOREWRAP value. This value enables the caller to treat the high memory area (HMA) simply as an extension of the V86 address space, whether or not wrap is enabled. 
\par If MAPV86_IGNOREWRAP is specified and wrap is enabled, the service updates only the HMA alias mapping for pages in the HMA, not the currently-visible mapping. The HMA corresponds to page numbers 100h through 10Fh. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 If more than one physical page is specified, this service maps the pages contiguously. If the physical memory is not contiguous, the virtual device must make individual calls for each page. 
\par Virtual devices must not map physical pages that do not contain actual memory, or that belong to some other device. 
\par For each mapped page, this service sets the P_USER, P_PRES, and P_WRITE bits, but clears the P_DIRTY and P_ACC bits. 
\par {\b _MapIntoV86}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _SetResetV86Pageable 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _SetResetV86Pageable, <VM, VMLinPgNum, nPages, flags>
\par 
\par or      eax, eax    ; nonzero if set or reset, zero if error
\par jz      error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Modifies the locking and unlocking behavior associated with a specific range of V86 memory. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns a nonzero value in the EAX register if successful, zero otherwise. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VM}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Handle of the virtual machine for which the behavior is modified. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinPgNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Linear page number of the first page in 1 megabyte V86 address space to modify. This parameter must not be below the page number for the first V86 page, or above 100h. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nPages}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Number of pages to modify. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Can be one of these values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PageClearV86IntsLocked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Disables locking of all V86 memory that cannot be paged regardless of whether the virtual page swap device uses MS-DOS or BIOS functions. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
PageClearV86Pageable \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables normal locking behavior. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
PageSetV86IntsLocked \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Enables locking of all V86 memory that cannot be paged regardless of whether the virtual page swap device uses MS-DOS or BIOS functions. \cell 
\pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 PageSetV86Pageable \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Disables normal locking behavior of {\b _MapIntoV86} and allows V86 memory to be paged. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 All other values are reserved. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 This service is intended to be used to support protected-mode applications running in a virtual machine. Virtual devices must {\i not} use this service for any other purpose. 
\par This service returns an error if the VMStat_PageableV86 or VMStat_V86IntsLocked state is inconsistent with the specified PageSetV86Pageable, PageClearV86Pageable, PageSetV86IntsLocked, or PageClearV86IntsLocked values. 
\par This service returns an error if the PageClearV86Pageable or PageSetV86IntsLocked values are given, but the service cannot lock the specified memory. 
\par The V86MMGR device uses the PageSetV86IntsLocked value for virtual machines which are created with their base memory specified as locked. 
\par Virtual device should avoid manipulating the locking and unlocking behavior of regions above page 0A0h. A virtual device should not modify these pages unless it owns a global or local region set by the {\b _Assign_Device_V86_Pages} service. 
\par If the PageSetV86IntsLocked or PageClearV86IntsLocked value is given, the service applies the modification to every page that that cannot be paged. For this reason the {\i VMLinPgNum} and {\i nPages} parameters should be set to zero. 
\par By default, the {\b _MapIntoV86} service locks the memory it maps. For a virtual machine running a protected-mode application, it is desirable change this default behavior. 
\par {\b _Assign_Device_V86_Pages}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 _TestGlobalV86Mem 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par VMMcall _TestGlobalV86Mem, <VMLinAddr, nBytes, flags>
\par 
\par mov     [Result], eax           ; 0 if local, 1 if global, 2 if mixed,
\par                                 ; 3 if includes instance data region
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Tests whether a V86 address range is global, local, or instanced. Uses EAX, ECX, EDX, and Flags. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns one of these values in the EAX register: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 0 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Address range either contains local memory, or is not a valid V86 address range. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 1 \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Address range contains global memory. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 2 \cell \pard\plain 
\s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Address range contains both local and global memory. \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 3 \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Address range contains global memory, but also includes an instance data region. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 
\f4\fs12 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i VMLinAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Ring-0 linear address of the first byte of the V86 address range. For example, the linear address of the V86 address 02C1h:0FC5h is 3BD5h (02C10h + 0FC5h). 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i nBytes}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Size of the V86 address range, in bytes. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i flags}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Operation flags. Must be zero. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Global V86 memory has addresses that are valid and identical
 in all virtual machines. Local memory has addresses that are only valid in one virtual machine. Instanced memory has addresses that are valid in all virtual machines, but the content of the memory varies with each virtual machine. 
\par This service may incorrectly report the type of memory in addresses above page 0A0h (in the device adapter area). If this service returns global for memory in this area, it is global. If the service returns local, however, the memory may actually be globa
l. Generally, this region is local. 
\par Operations involving global address ranges typically do not need to be virtualized since the range is valid and addressable in all virtual machines. Operations involving local address ranges may have to be virtualized since it is possible for software, su
ch as an interrupt handler, to use a local address in the wrong virtual machine. 
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Hook_V86_Page 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par mov     eax, PageNum            ; page number
\par mov     esi, OFFSET32 Callback  ; points to address of trap routine
\par VMMcall Hook_V86_Page
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Installs a callback procedure to handle faults for the specified page. Virtual devices, such as the virtual display device, use this service to detect when particular address ranges are accessed. Uses Flags. 

\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab 
Returns with the carry flag clear if successful, set otherwise. The service fails if the specified page number is invalid or the page is already hooked. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PageNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Page number of the V86 page to install the callback procedure for. This number must be within the range specified by the number of the last V86 page and 0FFh. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i Callback}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of the callback procedure to install. For more information about the callback procedure, see below. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The system calls the callback procedure whenever a page fault occurs for the specified page regardless of the current virtual machine. It calls the procedure as follows: 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 mov     eax, Page     ; faulting page number
\par mov     ebx, VM       ; current VM handle
\par call    [Callback]
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\i Page} parameter specifies the number of the page that caused the page fault, and the {\i VM} parameter is the handle of the current virtual machine. The EBP register does {\i not}
 point to a client register structure. 
\par The callback procedure must either map physical memory into pages causing the page fault, or terminate the virtual machine. In unusual circumstances, the virtual device may need to map the system nul page into the faulting page. 
\par Virtual devices must not rely on the contents of the CR2 (page fault) register. Instead, the callback procedure must use the {\i Page} parameter to determine which page caused the fault. 
\par Call {\b Unhook_V86_Page }to remove the hook procedure. 
\par {\b Unhook_V86_Page}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 InstDataStruc 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc
\par 
\par InstDataStruc struc
\par InstLinkF     dd      ?   ; reserved; do not use
\par InstLinkB     dd      ?   ; reserved; do not use
\par InstLinAddr   dd      ?   ; linear address of start of block
\par InstSize      dd      ?   ; size of block in bytes
\par InstType      dd      ?   ; type of the block
\par InstDataStruc ends
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 The {\b InstDataStruc} structure contains information about an instance data block. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b InstLinkF}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved. This field is filled by the instance data manager, and must not be used. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b InstLinkB}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Reserved. This field is filled by the instance data manager, and must not be used. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b InstLinAddr}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the linear address of the start of the block of instance data. Thus, the correct value for 40:2F would be 42F. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b InstSize}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the size in bytes of the instance data block. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\b InstType}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Specifies the instance data type. It can be one of the following values: 
\par \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s85\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Value \cell \pard\plain \s37\li240\sb20\sa60\sl-220\slmult1\keepn\intbl \b\f4\fs19 Meaning \cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 
\cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 ALWAYS_FIELD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Indicates that the field must always be switched when a virtual machine is switched. All instance data specified by devices should be of this type. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 
\f4\fs19 INDOS_FIELD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 Reserved for special types of MS-DOS internal data which only need to be switched with the virtual machine if the virtual machine is currently InDOS. 
\cell \pard\plain \intbl \f4\fs21 \row \trowd \trleft280 \cellx3160\cellx6660 \pard\plain \s82\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 OPTIONAL_FIELD \cell \pard\plain \s38\li240\sb20\sa60\sl-220\slmult1\intbl\tx280\tx560 \f4\fs19 
Indicates optional instance data. \cell \pard\plain \intbl \f4\fs21 \row \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b _AddInstanceItem}
\par \pard\plain \s103\qr\sl-140\slmult1 \f4\fs12 
\par \pard\plain \s3\sb80\sa40\sl-340\slmult1\keepn \b\f30\fs30 Unhook_V86_Page 
\par \pard\plain \s44\sl-220\slmult1\tx390\tx780\tx1170\tx1560\tx1950\tx2340\tx2730\tx3120\tx3510\tx3900\tx4290\tx4680\tx5070\tx5460\tx5850\tx6240\tx6630 \f31\fs16 include vmm.inc 
\par 
\par mov eax, PageNum
\par mov esi, TrapProc
\par VMMCall Unhook_V86_Page
\par 
\par jc error
\par 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 Allows VxDs to stop intercepting page faults in portions of the V86 address space of every virtual machine. It is used to undo the work of the {\b Hook_V86_Page} service. Uses Flags. 
\par You must specify a page number and address of a call-back routine to this service. If the given page is currently hooked with the specified call-back routine, the hook will be removed. Otherwise, the carry flag will be set on return to indicate error. 

\par After being unhooked the page will be mapped to a null page. 
\par \pard\plain \s45\fi-280\li280\sa80\sl-240\slmult1\tx280 \f4\fs21 {\field\flddirty{\*\fldinst SYMBOL 117 \\f "MSIcons" \\s 9.5 \\h }{\fldrslt }}\tab Returns with the carry flag clear if successful; otherwise sets the carry flag. 
\par \pard\plain \s40\qr\sl-160\slmult1 \f4\fs12 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i PageNum}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Page number (Last_VM_Page - 10Fh) to unhook. 
\par \pard\plain \s64\sl-240\slmult1\keepn \f4\fs21 {\i TrapProc}
\par \pard\plain \s65\li280\sa80\sl-240\slmult1 \f4\fs21 Address of callback procedure. 
\par \pard\plain \sa160\sl-240\slmult1 \f4\fs21 {\b Hook_V86_Page}
\par 
\par }